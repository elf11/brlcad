Index: src/libged/simulate/simrt.c
===================================================================
--- src/libged/simulate/simrt.c	(revision 53222)
+++ src/libged/simulate/simrt.c	(working copy)
@@ -33,55 +33,45 @@
 #include "simrt.h"
 
 
-#define USE_VELOCITY_FOR_NORMAL 1
-
-/*
- * Global lists filled up while raytracing : remove these as in the forward
- * progression of a ray, the y needs to be increased gradually, no need to
- * record other info
- */
-#define MAX_OVERLAPS 4
-#define MAX_HITS 4
-#define MAX_AIRGAPS 4
-
 int num_hits = 0;
 int num_overlaps = 0;
 int num_airgaps = 0;
+int checker = 1;
+int currentRay = 0;
+
 struct overlap overlap_list[MAX_OVERLAPS];
 struct hit_reg hit_list[MAX_HITS];
 struct hit_reg airgap_list[MAX_AIRGAPS];
-
 struct rayshot_results rt_result;
 
-
 void
 print_overlap_node(int i)
 {
-	bu_log("--------- Index %d -------\n", overlap_list[i].index);
+	    
+    bu_log("--------- Index %d -------\n", overlap_list[i].index);
 
 
     bu_log("insol :%s -->> outsol :%s \n", overlap_list[i].insol->st_name,
-									   overlap_list[i].outsol->st_name);
+									       overlap_list[i].outsol->st_name);
 
 
     bu_log("Entering at (%f,%f,%f) at distance of %f",
-	   V3ARGS(overlap_list[i].in_point), overlap_list[i].in_dist);
-	bu_log("Exiting  at (%f,%f,%f) at distance of %f",
-	   V3ARGS(overlap_list[i].out_point), overlap_list[i].out_dist);
+	       V3ARGS(overlap_list[i].in_point), overlap_list[i].in_dist);
+    bu_log("Exiting  at (%f,%f,%f) at distance of %f",
+	       V3ARGS(overlap_list[i].out_point), overlap_list[i].out_dist);
 
-	bu_log("in_normal: %f,%f,%f  -->> out_normal: %f,%f,%f",
-		       V3ARGS(overlap_list[i].in_normal),
-		       V3ARGS(overlap_list[i].out_normal) );
+    bu_log("in_normal: %f,%f,%f  -->> out_normal: %f,%f,%f",
+			   V3ARGS(overlap_list[i].in_normal),
+			   V3ARGS(overlap_list[i].out_normal) );
 
-	bu_log("incurve pdir : (%f,%f,%f), curv in dir c1: %f, curv opp dir c2: %f",
-	   V3ARGS(overlap_list[i].incur.crv_pdir), overlap_list[i].incur.crv_c1,
-											   overlap_list[i].incur.crv_c2);
+    bu_log("incurve pdir : (%f,%f,%f), curv in dir c1: %f, curv opp dir c2: %f",
+	       V3ARGS(overlap_list[i].incur.crv_pdir), overlap_list[i].incur.crv_c1,
+											       overlap_list[i].incur.crv_c2);
 
-	bu_log("outcurve pdir : (%f,%f,%f), curv in dir c1: %f, curv opp dir c2: %f",
-		   V3ARGS(overlap_list[i].outcur.crv_pdir), overlap_list[i].outcur.crv_c1,
-												    overlap_list[i].outcur.crv_c2);
+    bu_log("outcurve pdir : (%f,%f,%f), curv in dir c1: %f, curv opp dir c2: %f",
+		       V3ARGS(overlap_list[i].outcur.crv_pdir), overlap_list[i].outcur.crv_c1,
+													overlap_list[i].outcur.crv_c2);
 
-
 }
 
 
@@ -99,6 +89,8 @@
 int
 get_overlap(struct rigid_body *rbA, struct rigid_body *rbB, vect_t overlap_min, vect_t overlap_max)
 {
+    /*bu_log("get_overlap\n");
+    */
     bu_log("Calculating overlap between BB of %s(%f, %f, %f):(%f,%f,%f) \
 			and %s(%f, %f, %f):(%f,%f,%f)",
 		   rbA->rb_namep,
@@ -129,6 +121,8 @@
 if_hit(struct application *ap, struct partition *part_headp, struct seg *UNUSED(segs))
 {
 
+    /*bu_log("if_hit\n");
+*/
     /* iterating over partitions, this will keep track of the current
      * partition we're working on.
      */
@@ -153,10 +147,10 @@
     vect_t onormal;
 
     /* used for calculating the air gap distance */
-    vect_t v;
+  /*  vect_t v;
+*/
+    int i = 0;/*, j = 0;*/
 
-    int i = 0, j = 0;
-
     /* iterate over each partition until we get back to the head.
      * each partition corresponds to a specific homogeneous region of
      * material.
@@ -177,7 +171,7 @@
 				pp->pt_regionp->reg_regionid,
 				pp->pt_regionp->reg_aircode,
 				pp->pt_regionp->reg_gmater);
-
+	    
 	    if(pp->pt_regionp->reg_aircode != 0)
 		 bu_log("AIR REGION FOUND !!");
 
@@ -287,24 +281,24 @@
 			 * though they may belong to the same comb(A or B) but
 			 * we do not check that here. We just record the points and prims in the airgap_list[].
 			 */
-			if( (num_hits > 1) &&
+			/*if( (num_hits > 1) &&
 				(!VEQUAL(hit_list[i].in_point, hit_list[i-1].out_point))
-			){
+			){*/
 				/* There has been at least 1 out_point recorded and the
 				 * in_point of current hit reg. does not match out_point of previous hit reg.
 				 */
 
-				if(num_airgaps < MAX_AIRGAPS){
+			/*	if(num_airgaps < MAX_AIRGAPS){
 					j = num_airgaps;
 
 					VMOVE(airgap_list[j].in_point,  hit_list[i].in_point);
-					VMOVE(airgap_list[j].out_point, hit_list[i-1].out_point); /* Note: i-1 */
-					VSUB2(v, airgap_list[j].out_point, airgap_list[j].in_point);
+					VMOVE(airgap_list[j].out_point, hit_list[i-1].out_point);*/ /* Note: i-1 */
+	/*				VSUB2(v, airgap_list[j].out_point, airgap_list[j].in_point);
 					airgap_list[j].out_dist = MAGNITUDE(v);
 
 					airgap_list[j].in_stp   = hit_list[i].in_stp;
-					airgap_list[j].out_stp  = hit_list[i-1].out_stp; /* Note: i-1 */
-
+					airgap_list[j].out_stp  = hit_list[i-1].out_stp; *//* Note: i-1 */
+/*
 					airgap_list[j].index = j;
 
 					bu_log("\nRecorded AIR GAP in %s(%f,%f,%f), out %s(%f,%f,%f), gap size %f mm\n",
@@ -321,8 +315,8 @@
 					bu_log("if_hit: WARNING Skipping AIR region as maximum AIR regions reached");
 
 			}
+*/
 
-
 		}
 		else{
 			bu_log("if_hit: WARNING Skipping hit region as maximum hits reached");
@@ -347,11 +341,15 @@
 {
     int i = 0;
 
+    /*bu_log("if_overlap : num_overlaps = %d\n", num_overlaps);
+
     bu_log("if_overlap: OVERLAP between %s and %s", reg1->reg_name, reg2->reg_name);
+*/
 
-
     if(num_overlaps < MAX_OVERLAPS){
+		/*bu_log("DAMN!\n");*/
 		i = num_overlaps;
+		/*bu_log("if_overlap : i = %d\n", i);*/
 		overlap_list[i].ap = ap;
 		overlap_list[i].pp = pp;
 		overlap_list[i].reg1 = reg1;
@@ -401,7 +399,12 @@
 		bu_log("if_overlap: WARNING Skipping overlap region as maximum overlaps reached");
 	}
 
-    return rt_defoverlap (ap, pp, reg1, reg2, InputHdp);
+    /*bu_log("if_overlap : after finding overlaps the number of num_overlaps = %d\n", num_overlaps);
+*/
+   /* int k;
+    k = rt_defoverlap(ap, pp, reg1, reg2, InputHdp);
+    bu_log("if_overlap : k = %d\n", k);
+    */return rt_defoverlap(ap, pp, reg1, reg2, InputHdp);
 }
 
 
@@ -410,6 +413,8 @@
 {
     struct application ap;
 
+    /*bu_log("shoot_ray : Calling this function\n");
+*/
     /* Initialize the table of resource structures */
     /* rt_init_resource(&res_tab, 0, rtip); */
 
@@ -418,6 +423,8 @@
     ap.a_hit = if_hit;        /* branch to if_hit routine */
     ap.a_miss = if_miss;      /* branch to if_miss routine */
     ap.a_overlap = if_overlap;/* branch to if_overlap routine */
+    /*bu_log("shoot_ray : num_overlaps = %i\n", num_overlaps);
+    bu_log("shoot_ray : ap.a_overlap = %f ap.a_hit = %f ap.a_miss = %f\n", ap.a_overlap, ap.a_hit, ap.a_miss);  */  
     /*ap.a_logoverlap = rt_silent_logoverlap;*/
     ap.a_onehit = 0;          /* continue through shotline after hit */
     ap.a_purpose = "Sim Manifold ray";
@@ -516,6 +523,8 @@
     struct bu_vls reg_vls = BU_VLS_INIT_ZERO;
     struct rt_comb_internal *comb =(struct rt_comb_internal *)NULL;
 
+   /* bu_log("traverse_xray_lists : num_overlaps = %d\n", num_overlaps);
+*/
     /* Draw all the overlap regions : lines are added for overlap segments
      * to help visual debugging
      */
@@ -601,7 +610,8 @@
     struct bu_vls reg_vls = BU_VLS_INIT_ZERO;
     struct rt_comb_internal *comb =(struct rt_comb_internal *)NULL;
 
-
+   /* bu_log("traverse_yray_lists : num_overlaps = %d\n", num_overlaps);
+*/
     /* Draw all the overlap regions : lines are added for overlap segments
      * to help visual debugging
      */
@@ -677,20 +687,22 @@
 
 int
 traverse_zray_lists(
-		struct sim_manifold *current_manifold,
+		struct sim_manifold *UNUSED(current_manifold),
 		struct simulation_params *sim_params,
 		point_t pt, point_t dir)
 {
-    int i, rv;
+    int i;/* rv;*/
 
     /*struct hit_reg *hrp;*/
     struct bu_vls reg_vls = BU_VLS_INIT_ZERO;
-    struct rt_comb_internal *comb =(struct rt_comb_internal *)NULL;
+  /*  struct rt_comb_internal *comb =(struct rt_comb_internal *)NULL;
+*/
+    bu_log("traverse_zray_lists : num_overlaps = %d\n", num_overlaps);
 
-
     /* Draw all the overlap regions : lines are added for overlap segments
      * to help visual debugging
      */
+
     for(i=0; i<num_overlaps; i++){
 
 		bu_vls_sprintf(&reg_vls, "ray_overlap_%s_%s_%d_%f_%f_%f_%f_%f_%f",
@@ -704,7 +716,7 @@
 		line(sim_params->gedp, bu_vls_addr(&reg_vls),
 			 overlap_list[i].in_point,
 			 overlap_list[i].out_point,
-			 0, 210, 0);
+			 0, 0, 255);
 
 		bu_log("traverse_zray_lists: %s", bu_vls_addr(&reg_vls));
 
@@ -714,17 +726,17 @@
 		/* Fill up the result structure */
 
 		/* Only check with the comb of rigid body B */
-		comb = (struct rt_comb_internal *)(current_manifold->rbB->intern.idb_ptr);
-
+		/*comb = (struct rt_comb_internal *)(current_manifold->rbB->intern.idb_ptr);
+		*/
 		/* Check if the in solid belongs to rbB */
-		rv = check_tree_funcleaf(sim_params->gedp->ged_wdbp->dbip,
+		/*rv = check_tree_funcleaf(sim_params->gedp->ged_wdbp->dbip,
 								 comb,
 								 comb->tree,
 								 find_solid,
 								 (genptr_t)(overlap_list[i].insol->st_name));
 		if(rv == FOUND && !exists_normal(overlap_list[i].in_normal) ){
-			/* It does, so sum the in_normal */
-			bu_log("traverse_zray_lists: %s is present in %s", overlap_list[i].insol->st_name,
+		*/	/* It does, so sum the in_normal */
+		/*	bu_log("traverse_zray_lists: %s is present in %s", overlap_list[i].insol->st_name,
 															   current_manifold->rbB->rb_namep);
 
 			bu_log("traverse_zray_lists: resultant_normal_B is (%f,%f,%f)", V3ARGS(rt_result.resultant_normal_B));
@@ -733,17 +745,17 @@
 					V3ARGS(rt_result.resultant_normal_B), V3ARGS(overlap_list[i].in_normal));
 			add_normal(overlap_list[i].in_normal);
 
-		}
+		}*/
 
 		/* Check if the out solid belongs to rbB */
-		rv = check_tree_funcleaf(sim_params->gedp->ged_wdbp->dbip,
+		/*rv = check_tree_funcleaf(sim_params->gedp->ged_wdbp->dbip,
 								 comb,
 								 comb->tree,
 								 find_solid,
 								 (genptr_t)(overlap_list[i].outsol->st_name));
 		if(rv == FOUND && !exists_normal(overlap_list[i].out_normal) ){
-			/* It does, so sum the out_normal */
-			bu_log("traverse_zray_lists: %s is present in %s", overlap_list[i].outsol->st_name,
+		*/	/* It does, so sum the out_normal */
+		/*	bu_log("traverse_zray_lists: %s is present in %s", overlap_list[i].outsol->st_name,
 															   current_manifold->rbB->rb_namep);
 
 			bu_log("traverse_zray_lists: resultant_normal_B is (%f,%f,%f)", V3ARGS(rt_result.resultant_normal_B));
@@ -752,7 +764,7 @@
 					V3ARGS(rt_result.resultant_normal_B), V3ARGS(overlap_list[i].out_normal));
 			add_normal(overlap_list[i].out_normal);
 
-		}
+		}*/
 	}
 
 
@@ -778,20 +790,23 @@
     fastf_t depth;
     struct rt_comb_internal *comb =(struct rt_comb_internal *)NULL;
 
-
+  /*  bu_log("traverse_normalray_list : num_overlaps = %d\n", num_overlaps);
+*/
     /* Draw all the overlap regions : lines are added for overlap segments
      * to help visual debugging
      */
     for(i=0; i<num_overlaps; i++){
 
+		bu_log("Do you ever enter here?\n");
+
 		bu_vls_sprintf(&reg_vls, "ray_ovrlp_%s_%s_%d_%f_%f_%f_%f_%f_%f",
 				   overlap_list[i].reg1->reg_name,
 				   overlap_list[i].reg2->reg_name,
 				   overlap_list[i].index,
 				   V3ARGS(pt), V3ARGS(dir));
-
+	
 		clear_bad_chars(&reg_vls);
-
+		    
 		line(sim_params->gedp, bu_vls_addr(&reg_vls),
 			 overlap_list[i].in_point,
 			 overlap_list[i].out_point,
@@ -870,6 +885,8 @@
 
 	} /* end-for overlap */
 
+  /*  bu_log("traverse_normalray_list : rt_result.overlap_found = %d\n", rt_result.overlap_found);
+*/
 
     /* Investigate hit regions, only if no overlap was found for the ENTIRE bunch of
      * rays being shot, thus rt_result.overlap_found is set to FALSE, before a single
@@ -879,7 +896,7 @@
 	 */
     if(!rt_result.overlap_found){
 
-	bu_log("traverse_normalray_lists : No overlap found yet, checking hit regions");
+	bu_log("traverse_normalray_lists : No overlap found yet, checking hit regions\n");
 
 
 	/* Draw the hit regions */
@@ -1105,75 +1122,51 @@
 	     vect_t overlap_max)
 {
     point_t r_pt, r_dir;
-    fastf_t starty, startx, x, y, incr_x, incr_y;
-    vect_t diff;
+    fastf_t  x, y, constant;
+    vect_t initialOverlapMin;
+    vect_t initialOverlapMax;
 
     /* Set direction as straight down Z-axis */
     VSET(r_dir, 0.0, 0.0, 1.0);
 
+    bu_log("shoot_z_rays gets called\n");
 
     bu_log("Querying overlap between A:%s & B:%s",
 	   current_manifold->rbA->rb_namep,
 	   current_manifold->rbB->rb_namep);
 
-    /* Determine the width along z axis */
-    VSUB2(diff, overlap_max, overlap_min);
-
-    /* If it's thinner than TOLerance, reduce TOL, so that only 2 boundary rays shot
-	 */
-    incr_y = TOL;
-    if(diff[Y] < TOL){
-	incr_y = diff[Y]*0.5;
+    bu_log("overlap_min (%f,%f,%f)\n", V3ARGS(overlap_min));
+    bu_log("overlap_max (%f,%f,%f)\n", V3ARGS(overlap_max));
+ 
+    if (checker == 1) {
+	bu_log("DO YOU ENTER HERE?\n");
+	VMOVE(initialOverlapMin, overlap_min);
+	VMOVE(initialOverlapMax, overlap_max);
+	checker = 0;
     }
 
-    incr_x = TOL;
-    if(diff[X] < TOL){
-	incr_x = diff[X]*0.5;
-    }
+    constant = (initialOverlapMax[X] + initialOverlapMin[X]) / MAX_NR_RAYS;
 
-    starty = overlap_min[Y] - incr_y;
+    bu_log("constant = %f\n", constant);
 
-	/* Shoot rays vertically and across the xy plane */
-	for(y=starty; y<overlap_max[Y]; ){
+    if (currentRay < MAX_NR_RAYS) {
 
-		y += incr_y;
-		if(y > overlap_max[Y])
-			y = overlap_max[Y];
+	x = overlap_min[X] + currentRay * TOL * 10;
+	y = overlap_min[Y] + currentRay * TOL * 10;
+	    
+	VSET(r_pt, x, y, overlap_min[Z]);
 
-		startx = overlap_min[X] - incr_x;
+        bu_log("*********r_pt (%f,%f,%f)\n", V3ARGS(r_pt));
+    
+	currentRay = currentRay + 1;
+	num_overlaps = 0;
+	shoot_ray(sim_params->rtip, r_pt, r_dir);
 
-		for(x=startx; x<overlap_max[X]; ){
-
-			x += incr_x;
-			if(x > overlap_max[X])
-				x = overlap_max[X];
-
-			/* Shooting towards higher z, so start from min z outside of overlap box */
-			VSET(r_pt, x, y, overlap_min[Z]);
-
-			bu_log("*****shoot_z_rays : From : (%f,%f,%f) , dir:(%f,%f,%f)*******",
-			   V3ARGS(r_pt),  V3ARGS(r_dir));
-
-			num_overlaps = 0;
-			shoot_ray(sim_params->rtip, r_pt, r_dir);
-
-			/* Traverse the hit list and overlap list, drawing the ray segments
-			 * for the current ray
-			 */
-			traverse_zray_lists(current_manifold, sim_params, r_pt, r_dir);
-
-			/* Cleanup the overlap and hit lists and free memory */
-			cleanup_lists();
-
-			/*bu_log("Last x ray fired from x = %f, overlap_max[X]=%f", x, overlap_max[X]);*/
-
-		}
-
-		/*bu_log("Last y ray fired from y = %f, overlap_max[Y]=%f", y, overlap_max[Y]);*/
-
+	traverse_zray_lists(current_manifold, sim_params, r_pt, r_dir);
+    
     }
+    cleanup_lists();
 
-
     return GED_OK;
 }
 
@@ -1346,19 +1339,19 @@
 	init_rayshot_results();
 
 
-#ifndef USE_VELOCITY_FOR_NORMAL
+//#ifndef USE_VELOCITY_FOR_NORMAL
 	/* Shoot rays right here as the pair of rigid_body ptrs are known,
 	 * TODO: ignore volumes already shot
 	 */
-	shoot_x_rays(rt_mf, sim_params, overlap_min, overlap_max);
-	shoot_y_rays(rt_mf, sim_params, overlap_min, overlap_max);
+/*	shoot_x_rays(rt_mf, sim_params, overlap_min, overlap_max);
+	shoot_y_rays(rt_mf, sim_params, overlap_min, overlap_max);*/
 	shoot_z_rays(rt_mf, sim_params, overlap_min, overlap_max);
-#endif
+//#endif
 
 
 	/* Create the contact pairs and normals : Currently just 1 manifold is allowed per pair of objects*/
-	create_contact_pairs(rt_mf, sim_params, overlap_min, overlap_max);
-
+/*	create_contact_pairs(rt_mf, sim_params, overlap_min, overlap_max);
+*/
     return GED_OK;
 }
 
Index: src/libged/simulate/simrt.h
===================================================================
--- src/libged/simulate/simrt.h	(revision 53222)
+++ src/libged/simulate/simrt.h	(working copy)
@@ -59,14 +59,28 @@
  * region in half, generating manifolds in a plane.
  */
 #define TOL 0.04
-
+#define MAX_NR_RAYS 10
 /*
  * Maximum normals allowed to be detected by ray shots
  */
 #define MAX_NORMALS 10
 
+#define USE_VELOCITY_FOR_NORMAL 1
 
 /*
+ * Global lists filled up while raytracing : remove these as in the forward
+ * progression of a ray, the y needs to be increased gradually, no need to
+ * record other info
+ */
+#define MAX_OVERLAPS 4
+#define MAX_HITS 4
+#define MAX_AIRGAPS 4
+
+extern int num_hits;
+extern int num_overlaps;
+extern int num_airgaps;
+
+/*
  * This structure is a single node of an array
  * of overlap regions: similar to the one in nirt/usrfrmt.h
  */
Index: src/libged/simulate/simulate.c
===================================================================
--- src/libged/simulate/simulate.c	(revision 53222)
+++ src/libged/simulate/simulate.c	(working copy)
@@ -305,11 +305,11 @@
 		/* Store this world transformation to undo it before next world transformation */
 		MAT_COPY(current_node->m_prev, current_node->m);
 
-		/*insert_AABB(gedp, sim_params, current_node);
+		insert_AABB(gedp, sim_params, current_node);
 
 		print_manifold_list(current_node);
 
-		insert_manifolds(gedp, sim_params, current_node);*/
+		insert_manifolds(gedp, sim_params, current_node);
 
 		current_node->num_bt_manifolds = 0;
 
@@ -442,7 +442,7 @@
 		sim_params.rtip->useair = 1;
 
 		/* Initialize the raytrace world */
-		//init_raytrace(&sim_params);
+		init_raytrace(&sim_params);
 
 		/* Recreate sim.c to clear AABBs and manifold regions from previous iteration */
 		recreate_sim_comb(gedp, &sim_params);
Index: src/libged/simulate/simutils.c
===================================================================
--- src/libged/simulate/simutils.c	(revision 53222)
+++ src/libged/simulate/simutils.c	(working copy)
@@ -237,6 +237,9 @@
     char *cmd_args[5];
     int rv, argc = 4;
 
+    bu_log("add_to_comb : target : %s\n", target);
+    bu_log("add_to_comb : add : %s\n", add);
+
     cmd_args[0] = bu_strdup("comb");
     cmd_args[1] = bu_strdup(target);
     cmd_args[2] = bu_strdup("u");
@@ -306,7 +309,7 @@
 
     cmd_args[19] = (char *)0;
 
-    /* print_command(cmd_args, 19); */
+     print_command(cmd_args, 19); 
 
     rv = ged_in(gedp, argc, (const char **)cmd_args);
     if (rv != GED_OK) {
Index: src/libged/simulate/simphysics.cpp
===================================================================
--- src/libged/simulate/simphysics.cpp	(revision 53222)
+++ src/libged/simulate/simphysics.cpp	(working copy)
@@ -141,7 +141,7 @@
 	        collision_shapes.push_back(bb_Shape);
 
 	        volume = current_node->bb_dims[0] * current_node->bb_dims[1] * current_node->bb_dims[2];
-	        mass = 1.0; //volume; // density is 1
+	        mass = 1;//volume; // density is 1
 
 	        btVector3 bb_Inertia(0, 0, 0);
 	        bb_Shape->calculateLocalInertia(mass, bb_Inertia);
@@ -249,7 +249,7 @@
 	        //Copy the transform matrix
 	        MAT_COPY(current_node->m, m);
 
-	        print_matrices(current_node->rb_namep, current_node->m, m);
+	        //print_matrices(current_node->rb_namep, current_node->m, m);
 
 	        //Get the state of the body
 	        current_node->state = bb_RigidBody->getActivationState();
@@ -522,9 +522,9 @@
     /*dispatcher->registerCollisionCreateFunc(SPHERE_SHAPE_PROXYTYPE,
 										SPHERE_SHAPE_PROXYTYPE,
 										new btRTCollisionAlgorithm::CreateFunc);*/
-  /*  dispatcher->registerCollisionCreateFunc(BOX_SHAPE_PROXYTYPE,
+    dispatcher->registerCollisionCreateFunc(BOX_SHAPE_PROXYTYPE,
 											BOX_SHAPE_PROXYTYPE,
-											new btRTCollisionAlgorithm::CreateFunc);*/
+											new btRTCollisionAlgorithm::CreateFunc);
 
     btSequentialImpulseConstraintSolver* solver = new btSequentialImpulseConstraintSolver;
 
@@ -537,7 +537,7 @@
     add_rigid_bodies(dynamicsWorld, collision_shapes);
 
     //Add a broadphase callback to hook to the AABB detection algos
-/*    btOverlapFilterCallback * filterCallback = new broadphase_callback();
+    btOverlapFilterCallback * filterCallback = new broadphase_callback();
     dynamicsWorld->getPairCache()->setOverlapFilterCallback(filterCallback);
 
     //Add a nearphase callback to hook to the contact points generation algos
@@ -546,7 +546,7 @@
     //Investigating the contact pairs used between 2 rigid bodies
     gContactAddedCallback     = contact_added;
     gContactProcessedCallback = contact_processed;
-    gContactDestroyedCallback = contact_destroyed;*/
+    gContactDestroyedCallback = contact_destroyed;
 
     //Step the physics the required number of times
     step_physics(dynamicsWorld);
Index: src/librt/primitives/extrude/extrude.c
===================================================================
--- src/librt/primitives/extrude/extrude.c	(revision 53222)
+++ src/librt/primitives/extrude/extrude.c	(working copy)
@@ -46,7 +46,7 @@
 			vect_t u_vec, vect_t v_vec, struct rt_sketch_internal *sketch_ip, genptr_t seg);
 
 struct extrude_specific {
-    mat_t rot, irot;	/* rotation and translation to get extrusion vector in +z direction with V at origin */
+    mat_t rot, irot;	/* rotation and translation to get extrsuion vector in +z direction with V at origin */
     vect_t unit_h;	/* unit vector in direction of extrusion vector */
     vect_t u_vec;	/* u vector rotated and projected */
     vect_t v_vec;	/* v vector rotated and projected */
Index: src/librt/primitives/arbn/arbn.c
===================================================================
--- src/librt/primitives/arbn/arbn.c	(revision 53222)
+++ src/librt/primitives/arbn/arbn.c	(working copy)
@@ -120,7 +120,7 @@
 
     /*
      * ARBN must be convex.  Test for concavity.
-     * Byproduct is an enumeration of all the vertices,
+     * Byproduct is an enumeration of all the verticies,
      * which are used to make the bounding RPP.  No need
      * to call the bbox routine, as the work must be duplicated
      * here to count faces.
@@ -472,7 +472,7 @@
 		point_count++;
 	    }
 	    /* Point counts of 1 are (generally) not harmful,
-	     * occurring on pyramid peaks and the like.
+	     * occuring on pyramid peaks and the like.
 	     */
 	}
     }
@@ -590,7 +590,7 @@
     struct arbn_pts *pts;
     struct arbn_edges *edges;		/* A list of edges for each plane eqn (each face) */
     size_t *edge_count;	/* number of edges for each face */
-    size_t max_edge_count; /* maximum number of edges for any face */
+    size_t max_edge_count; /* maximium number of edges for any face */
     struct vertex **verts;	/* Array of pointers to vertex structs */
     struct vertex ***loop_verts;	/* Array of pointers to vertex structs to pass to nmg_cmface */
 
@@ -952,7 +952,6 @@
     unsigned long neqn;
     int double_count;
     size_t byte_count;
-    double *eqn;
 
     RT_CK_DB_INTERNAL(ip);
     BU_CK_EXTERNAL(ep);
@@ -973,14 +972,9 @@
     aip->magic = RT_ARBN_INTERNAL_MAGIC;
     aip->neqn = neqn;
     if (aip->neqn <= 0) return -1;
+    aip->eqn = (plane_t *)bu_malloc(byte_count, "arbn plane eqn[]");
 
-    eqn = (double *)bu_malloc(byte_count, "arbn plane eqn[] temp buf");
-    ntohd((unsigned char *)eqn, (unsigned char *)ep->ext_buf + 4, double_count);
-    aip->eqn = (plane_t *)bu_malloc(double_count * sizeof(fastf_t), "arbn plane eqn[]");
-    for (i=0; i < aip->neqn; i++) {
-	HMOVE(aip->eqn[i], &eqn[i*ELEMENTS_PER_PLANE]);
-    }
-    bu_free(eqn, "arbn plane eqn[] temp buf");
+    ntohd((unsigned char *)aip->eqn, (unsigned char *)ep->ext_buf + 4, double_count);
 
     /* Transform by the matrix, if we have one that is not the identity */
     if (mat && !bn_mat_is_identity(mat)) {
@@ -1021,8 +1015,8 @@
 {
     struct rt_arbn_internal *aip;
     size_t i;
-    double *vec;
-    double *sp;
+    fastf_t *vec;
+    fastf_t *sp;
     int double_count;
     int byte_count;
 
@@ -1153,7 +1147,7 @@
 			  V4ARGS(arbn->eqn[i]));
 	}
     } else if (attr[0] == 'P') {
-	if (isdigit((int)attr[1]) == 0) {
+	if (isdigit(attr[1]) == 0) {
 	    bu_vls_printf(logstr, "ERROR: Illegal plane number\n");
 	    return BRLCAD_ERROR;
 	}
@@ -1253,7 +1247,7 @@
 		arbn->eqn = (plane_t *)bu_realloc(arbn->eqn,
 						  (arbn->neqn) * sizeof(plane_t),
 						  "arbn->eqn");
-	    } else if (isdigit((int)argv[0][1])) {
+	    } else if (isdigit(argv[0][1])) {
 		i = atoi(&argv[0][1]);
 	    } else {
 		bu_vls_printf(logstr,
Index: src/librt/primitives/revolve/revolve.c
===================================================================
--- src/librt/primitives/revolve/revolve.c	(revision 53222)
+++ src/librt/primitives/revolve/revolve.c	(working copy)
@@ -68,7 +68,7 @@
     fastf_t radius;
     point_t center;
 
-    int *endcount = NULL;
+    int *endcount;
     size_t nseg, i, j, k;
 
     RT_CK_DB_INTERNAL(ip);
@@ -79,8 +79,9 @@
      * if even, the point is ok
      * if odd, the point is at the end of a path
      */
-    if (rip->skt->vert_count)
-	endcount = (int *)bu_calloc(rip->skt->vert_count, sizeof(int), "endcount");
+    endcount = (int *)bu_calloc(rip->skt->vert_count, sizeof(int), "endcount");
+    for (i=0; i<rip->skt->vert_count; i++)
+	endcount[i] = 0;
     nseg = rip->skt->curve.count;
 
     for (i=0; i<nseg; i++) {
@@ -138,8 +139,7 @@
 	    j++;
 	}
     }
-    while (j < rip->skt->vert_count)
-	endcount[j++] = -1;
+    while (j < rip->skt->vert_count) endcount[j++] = -1;
 
     VMOVE(zUnit, rip->axis3d);
     VUNITIZE(zUnit);
@@ -158,8 +158,7 @@
     (*min)[Z] = center[Z] - radius;
     (*max)[Z] = center[Z] + radius;
 
-    if (rip->skt->vert_count)
-	bu_free(endcount, "endcount");
+    bu_free(endcount, "endcount");
 
     return 0;			/* OK */
 }
@@ -187,7 +186,7 @@
 
     vect_t xEnd, yEnd;
 
-    int *endcount = NULL;
+    int *endcount;
     size_t nseg, i, j, k;
 
     if (rtip) RT_CK_RTI(rtip);
@@ -227,9 +226,9 @@
      * if even, the point is ok
      * if odd, the point is at the end of a path
      */
-    if (rev->skt->vert_count) {
-	endcount = (int *)bu_calloc(rev->skt->vert_count, sizeof(int), "endcount");
-    }
+    endcount = (int *)bu_calloc(rev->skt->vert_count, sizeof(int), "endcount");
+    for (i=0; i<rev->skt->vert_count; i++)
+	endcount[i] = 0;
     nseg = rev->skt->curve.count;
 
     for (i=0; i<nseg; i++) {
@@ -287,8 +286,7 @@
 	    j++;
 	}
     }
-    while (j < rev->skt->vert_count)
-	endcount[j++] = -1;
+    while (j < rev->skt->vert_count) endcount[j++] = -1;
 
     rev->ends = endcount;
 
@@ -1212,7 +1210,7 @@
     vect_t ell[16], cir[16], ucir[16], height, xdir, ydir, ux, uy, uz, rEnd, xEnd, yEnd;
     fastf_t cos22_5 = 0.9238795325112867385;
     fastf_t cos67_5 = 0.3826834323650898373;
-    int *endcount = NULL;
+    int *endcount;
     point_t add, add2, add3;
 
     BU_CK_LIST_HEAD(vhead);
@@ -1275,9 +1273,10 @@
     VREVERSE(ucir[12], ucir[4]);
 
     /* find open endpoints, and determine which points are used */
-    if (nvert)
-	endcount = (int *)bu_calloc(nvert, sizeof(int), "endcount");
-
+    endcount = (int *)bu_calloc(rip->skt->vert_count, sizeof(int), "endcount");
+    for (i=0; i<rip->skt->vert_count; i++) {
+	endcount[i] = 0;
+    }
     nseg = rip->skt->curve.count;
 
     for (i=0; i<nseg; i++) {
@@ -1357,9 +1356,7 @@
 	}
     }
     nadd = j;
-    while (j < rip->skt->vert_count) {
-	endcount[j++] = -1;
-    }
+    while (j < rip->skt->vert_count) endcount[j++] = -1;
 
     /* draw sketch outlines */
     for (i=0; i<narc; i++) {
@@ -1409,8 +1406,7 @@
 	}
     }
 
-    if (nvert)
-	bu_free(endcount, "endcount");
+    bu_free(endcount, "endcount");
     return 0;
 }
 
Index: src/librt/primitives/poly/poly.c
===================================================================
--- src/librt/primitives/poly/poly.c	(revision 53222)
+++ src/librt/primitives/poly/poly.c	(working copy)
@@ -266,7 +266,7 @@
 	dn = VDOT(trip->tri_wn, rp->r_dir);
 
 	/*
-	 * If ray lies directly along the face, (i.e., dot product
+	 * If ray lies directly along the face, (ie, dot product
 	 * is zero), drop this face.
 	 */
 	abs_dn = dn >= 0.0 ? dn : (-dn);
@@ -389,7 +389,7 @@
 		dot1 = dot2;
 		dot2 = VDOT(rp->r_dir, hits[i].hit_normal);
 		if (dot1 > 0.0 && dot2 > 0.0) {
-		    /* two consecutive exits,
+		    /* two consectutive exits,
 		     * manufacture an entrance at same distance
 		     * as second exit.
 		     */
@@ -401,7 +401,7 @@
 		    nhits++;
 		    bu_log("\t\tadding fictitious entry at %f (%s)\n", hits[i].hit_dist, stp->st_name);
 		} else if (dot1 < 0.0 && dot2 < 0.0) {
-		    /* two consecutive entrances,
+		    /* two consectutive entrances,
 		     * manufacture an exit between them.
 		     */
 
Index: src/librt/primitives/pnts/pnts.c
===================================================================
--- src/librt/primitives/pnts/pnts.c	(revision 53222)
+++ src/librt/primitives/pnts/pnts.c	(working copy)
@@ -165,7 +165,7 @@
 	    register struct pnt *point;
 
 	    for (BU_LIST_FOR(point, pnt, &(((struct pnt *)pnts->point)->l))) {
-		double v[3];
+		point_t v;
 
 		/* pack v */
 		VSCALE(v, point->v, local2mm);
@@ -178,17 +178,15 @@
 	    register struct pnt_color *point;
 
 	    for (BU_LIST_FOR(point, pnt_color, &(((struct pnt_color *)pnts->point)->l))) {
-		double v[3];
+		point_t v;
 		double c[3];
-		fastf_t cf[3];
 
 		/* pack v */
 		VSCALE(v, point->v, local2mm);
 		buf = pnts_pack_double(buf, (unsigned char *)v, ELEMENTS_PER_POINT);
 
 		/* pack c */
-		bu_color_to_rgb_floats(&point->c, cf);
-		VMOVE(c, cf);
+		bu_color_to_rgb_floats(&point->c, c);
 		buf = pnts_pack_double(buf, (unsigned char *)c, 3);
 	    }
 
@@ -198,7 +196,7 @@
 	    register struct pnt_scale *point;
 
 	    for (BU_LIST_FOR(point, pnt_scale, &(((struct pnt_scale *)pnts->point)->l))) {
-		double v[3];
+		point_t v;
 		double s[1];
 
 		/* pack v */
@@ -216,8 +214,8 @@
 	    register struct pnt_normal *point;
 
 	    for (BU_LIST_FOR(point, pnt_normal, &(((struct pnt_normal *)pnts->point)->l))) {
-		double v[3];
-		double n[3];
+		point_t v;
+		vect_t n;
 
 		/* pack v */
 		VSCALE(v, point->v, local2mm);
@@ -234,9 +232,8 @@
 	    register struct pnt_color_scale *point;
 
 	    for (BU_LIST_FOR(point, pnt_color_scale, &(((struct pnt_color_scale *)pnts->point)->l))) {
-		double v[3];
+		point_t v;
 		double c[3];
-		fastf_t cf[3];
 		double s[1];
 
 		/* pack v */
@@ -244,8 +241,7 @@
 		buf = pnts_pack_double(buf, (unsigned char *)v, ELEMENTS_PER_POINT);
 
 		/* pack c */
-		bu_color_to_rgb_floats(&point->c, cf);
-		VMOVE(c, cf);
+		bu_color_to_rgb_floats(&point->c, c);
 		buf = pnts_pack_double(buf, (unsigned char *)c, 3);
 
 		/* pack s */
@@ -259,18 +255,16 @@
 	    register struct pnt_color_normal *point;
 
 	    for (BU_LIST_FOR(point, pnt_color_normal, &(((struct pnt_color_normal *)pnts->point)->l))) {
-		double v[3];
+		point_t v;
 		double c[3];
-		fastf_t cf[3];
-		double n[3];
+		vect_t n;
 
 		/* pack v */
 		VSCALE(v, point->v, local2mm);
 		buf = pnts_pack_double(buf, (unsigned char *)v, ELEMENTS_PER_POINT);
 
 		/* pack c */
-		bu_color_to_rgb_floats(&point->c, cf);
-		VMOVE(c, cf);
+		bu_color_to_rgb_floats(&point->c, c);
 		buf = pnts_pack_double(buf, (unsigned char *)c, 3);
 
 		/* pack n */
@@ -284,9 +278,9 @@
 	    register struct pnt_scale_normal *point;
 
 	    for (BU_LIST_FOR(point, pnt_scale_normal, &(((struct pnt_scale_normal *)pnts->point)->l))) {
-		double v[3];
+		point_t v;
 		double s[1];
-		double n[3];
+		vect_t n;
 
 		/* pack v */
 		VSCALE(v, point->v, local2mm);
@@ -307,19 +301,17 @@
 	    register struct pnt_color_scale_normal *point;
 
 	    for (BU_LIST_FOR(point, pnt_color_scale_normal, &(((struct pnt_color_scale_normal *)pnts->point)->l))) {
-		double v[3];
-		double s[1];
+		point_t v;
 		double c[3];
-		fastf_t cf[3];
-		double n[3];
+		double s[1];
+		vect_t n;
 
 		/* pack v */
 		VSCALE(v, point->v, local2mm);
 		buf = pnts_pack_double(buf, (unsigned char *)v, ELEMENTS_PER_POINT);
 
 		/* pack c */
-		bu_color_to_rgb_floats(&point->c, cf);
-		VMOVE(c, cf);
+		bu_color_to_rgb_floats(&point->c, c);
 		buf = pnts_pack_double(buf, (unsigned char *)c, 3);
 
 		/* pack s */
@@ -401,7 +393,7 @@
 	    pnts->point = point;
 
 	    for (i = 0; i < pnts->count; i++) {
-		double v[3];
+		point_t v;
 
 		BU_GET(point, struct pnt);
 
@@ -423,9 +415,8 @@
 	    pnts->point = point;
 
 	    for (i = 0; i < pnts->count; i++) {
-		double v[3];
+		point_t v;
 		double c[3];
-		fastf_t cf[3];
 
 		BU_GET(point, struct pnt_color);
 
@@ -435,8 +426,7 @@
 
 		/* unpack c */
 		buf = pnts_unpack_double(buf, (unsigned char *)c, 3);
-		VMOVE(cf, c);
-		bu_color_from_rgb_floats(&point->c, cf);
+		bu_color_from_rgb_floats(&point->c, c);
 
 		BU_LIST_PUSH(head, &point->l);
 	    }
@@ -452,7 +442,7 @@
 	    pnts->point = point;
 
 	    for (i = 0; i < pnts->count; i++) {
-		double v[3];
+		point_t v;
 		double s[1];
 
 		BU_GET(point, struct pnt_scale);
@@ -479,8 +469,8 @@
 	    pnts->point = point;
 
 	    for (i = 0; i < pnts->count; i++) {
-		double v[3];
-		double n[3];
+		point_t v;
+		vect_t n;
 
 		BU_GET(point, struct pnt_normal);
 
@@ -506,9 +496,8 @@
 	    pnts->point = point;
 
 	    for (i = 0; i < pnts->count; i++) {
-		double v[3];
+		point_t v;
 		double c[3];
-		fastf_t cf[3];
 		double s[1];
 
 		BU_GET(point, struct pnt_color_scale);
@@ -519,8 +508,7 @@
 
 		/* unpack c */
 		buf = pnts_unpack_double(buf, (unsigned char *)c, 3);
-		VMOVE(cf, c);
-		bu_color_from_rgb_floats(&point->c, cf);
+		bu_color_from_rgb_floats(&point->c, c);
 
 		/* unpack s */
 		buf = pnts_unpack_double(buf, (unsigned char *)s, 1);
@@ -540,10 +528,9 @@
 	    pnts->point = point;
 
 	    for (i = 0; i < pnts->count; i++) {
-		double v[3];
+		point_t v;
 		double c[3];
-		fastf_t cf[3];
-		double n[3];
+		vect_t n;
 
 		BU_GET(point, struct pnt_color_normal);
 
@@ -553,8 +540,7 @@
 
 		/* unpack c */
 		buf = pnts_unpack_double(buf, (unsigned char *)c, 3);
-		VMOVE(cf, c);
-		bu_color_from_rgb_floats(&point->c, cf);
+		bu_color_from_rgb_floats(&point->c, c);
 
 		/* unpack n */
 		buf = pnts_unpack_double(buf, (unsigned char *)n, ELEMENTS_PER_VECT);
@@ -574,9 +560,9 @@
 	    pnts->point = point;
 
 	    for (i = 0; i < pnts->count; i++) {
-		double v[3];
+		point_t v;
 		double s[1];
-		double n[3];
+		vect_t n;
 
 		BU_GET(point, struct pnt_scale_normal);
 
@@ -606,11 +592,10 @@
 	    pnts->point = point;
 
 	    for (i = 0; i < pnts->count; i++) {
-		double v[3];
-		double s[1];
+		point_t v;
 		double c[3];
-		fastf_t cf[3];
-		double n[3];
+		double s[1];
+		vect_t n;
 
 		BU_GET(point, struct pnt_color_scale_normal);
 
@@ -620,8 +605,7 @@
 
 		/* unpack c */
 		buf = pnts_unpack_double(buf, (unsigned char *)c, 3);
-		VMOVE(cf, c);
-		bu_color_from_rgb_floats(&point->c, cf);
+		bu_color_from_rgb_floats(&point->c, c);
 
 		/* unpack s */
 		buf = pnts_unpack_double(buf, (unsigned char *)s, 1);
Index: src/librt/primitives/rpc/rpc.c
===================================================================
--- src/librt/primitives/rpc/rpc.c	(revision 53222)
+++ src/librt/primitives/rpc/rpc.c	(working copy)
@@ -104,7 +104,7 @@
  * NORMALS.  Given the point W on the surface of the rpc, what is the
  * vector normal to the tangent plane at that point?
  *
- * Map W onto the unit rpc, i.e.:  W' = S(R(W - V)).
+ * Map W onto the unit rpc, ie:  W' = S(R(W - V)).
  *
  * Plane on unit rpc at W' has a normal vector N' where
  *
@@ -173,7 +173,6 @@
 
 #include "../../librt_private.h"
 
-static int rpc_is_valid(struct rt_rpc_internal *rpc);
 
 struct rpc_specific {
     point_t rpc_V;		/* vector to rpc origin */
@@ -271,6 +270,7 @@
 
     fastf_t magsq_b, magsq_h, magsq_r;
     fastf_t mag_b, mag_h, mag_r;
+    fastf_t f;
     mat_t R;
     mat_t Rinv;
     mat_t S;
@@ -279,9 +279,7 @@
     RT_CK_DB_INTERNAL(ip);
 
     xip = (struct rt_rpc_internal *)ip->idb_ptr;
-    if (!rpc_is_valid(xip)) {
-	return 1;
-    }
+    RT_RPC_CK_MAGIC(xip);
 
     /* compute |B| |H| */
     mag_b = sqrt(magsq_b = MAGSQ(xip->rpc_B));
@@ -289,6 +287,21 @@
     mag_r = xip->rpc_r;
     magsq_r = mag_r * mag_r;
 
+    /* Check for |H| > 0, |B| > 0, |R| > 0 */
+    if (NEAR_ZERO(mag_h, RT_LEN_TOL) || NEAR_ZERO(mag_b, RT_LEN_TOL)
+	|| NEAR_ZERO(mag_r, RT_LEN_TOL)) {
+	return 1;		/* BAD, too small */
+    }
+
+    /* Check for B.H == 0 */
+    f = VDOT(xip->rpc_B, xip->rpc_H) / (mag_b * mag_h);
+    if (! NEAR_ZERO(f, RT_DOT_TOL)) {
+	return 1;		/* BAD */
+    }
+
+    /*
+     * RPC is ok
+     */
     stp->st_id = ID_RPC;		/* set soltab ID */
     stp->st_meth = &rt_functab[ID_RPC];
 
@@ -657,225 +670,7 @@
     return 0;
 }
 
-/* A canonical parabola in the Y-Z plane has equation z = y^2 / 4p, and opens
- * toward positive z with vertex at the origin.
- *
- * The contour of an rpc in the plane B-R is a parabola with vertex at B,
- * opening toward -B. We can transform this parabola to get an equivalent
- * canonical parabola in the Y-Z plane, opening toward positive Z (-B) with
- * vertex at the origin (B).
- *
- * This parabola passes through the point (r, |B|). If we plug the point (r, |B|)
- * into our canonical equation, we see how p relates to r and |B|:
- *
- *   |B| = r^2 / 4p
- *     p = (r^2) / (4|B|)
- */
-static fastf_t
-rpc_parabola_p(fastf_t r, fastf_t mag_b)
-{
-    return (r * r) / (4 * mag_b);
-}
 
-/* The contour of an rpc in the plane B-R is a parabola with vertex at B,
- * opening toward -B. We can transform this parabola to get an equivalent
- * parabola in the Y-Z plane, opening toward positive Z (-B) with vertex at
- * (0, -|B|).
- *
- * The part of this parabola that passes between (0, -|B|) and (r, 0) is
- * approximated by num_points points (including (0, -|B|) and (r, 0)).
- *
- * The constructed point list is returned (NULL returned on error). Because the
- * above transformation puts the rpc vertex at the origin and the parabola
- * vertex at (0, -|B|), multiplying the z values by -1 gives corresponding
- * distances along the rpc breadth vector B.
- */
-static struct rt_pt_node *
-rpc_parabolic_curve(fastf_t mag_b, fastf_t r, int num_points)
-{
-    int count;
-    struct rt_pt_node *curve;
-
-    curve = (struct rt_pt_node *)bu_malloc(sizeof(struct rt_pt_node), "rt_pt_node");
-    curve->next = (struct rt_pt_node *)bu_malloc(sizeof(struct rt_pt_node), "rt_pt_node");
-
-    curve->next->next = NULL;
-    VSET(curve->p,       0, 0, -mag_b);
-    VSET(curve->next->p, 0, r, 0);
-
-    count = approximate_parabolic_curve(curve, rpc_parabola_p(r, mag_b), num_points - 2);
-
-    if (count != (num_points - 2)) {
-	return NULL;
-    }
-
-    return curve;
-}
-
-/* plot half of a parabolic contour curve using the given (r, b) points (pts),
- * translation along H (rpc_H), and multiplier for r (rscale)
- */
-static void
-rpc_plot_parabolic_curve(
-	struct bu_list *vhead,
-	struct rpc_specific *rpc,
-	struct rt_pt_node *pts,
-	vect_t rpc_H,
-	fastf_t rscale)
-{
-    vect_t t, Ru, Bu;
-    point_t p;
-    struct rt_pt_node *node;
-
-    VADD2(t, rpc->rpc_V, rpc_H);
-    VMOVE(Ru, rpc->rpc_Runit);
-    VMOVE(Bu, rpc->rpc_Bunit);
-
-    VJOIN2(p, t, rscale * pts->p[Y], Ru, -pts->p[Z], Bu);
-    RT_ADD_VLIST(vhead, p, BN_VLIST_LINE_MOVE);
-
-    node = pts->next;
-    while (node != NULL) {
-	VJOIN2(p, t, rscale * node->p[Y], Ru, -node->p[Z], Bu);
-	RT_ADD_VLIST(vhead, p, BN_VLIST_LINE_DRAW);
-
-	node = node->next;
-    }
-}
-
-static void
-rpc_plot_parabolas(
-	struct bu_list *vhead,
-	struct rt_rpc_internal *rpc,
-	struct rt_pt_node *pts)
-{
-    vect_t rpc_H;
-    struct rpc_specific rpc_s;
-
-    VMOVE(rpc_s.rpc_V, rpc->rpc_V);
-
-    VMOVE(rpc_s.rpc_Bunit, rpc->rpc_B);
-    VUNITIZE(rpc_s.rpc_Bunit);
-
-    VCROSS(rpc_s.rpc_Runit, rpc_s.rpc_Bunit, rpc->rpc_H);
-    VUNITIZE(rpc_s.rpc_Runit);
-
-    /* plot parabolic contour curve of face containing V */
-    VSETALL(rpc_H, 0.0);
-    rpc_plot_parabolic_curve(vhead, &rpc_s, pts, rpc_H, 1.0);
-    rpc_plot_parabolic_curve(vhead, &rpc_s, pts, rpc_H, -1.0);
-
-    /* plot parabolic contour curve of opposing face */
-    VMOVE(rpc_H, rpc->rpc_H);
-    rpc_plot_parabolic_curve(vhead, &rpc_s, pts, rpc_H, 1.0);
-    rpc_plot_parabolic_curve(vhead, &rpc_s, pts, rpc_H, -1.0);
-}
-
-static void
-rpc_plot_curve_connections(
-	struct bu_list *vhead,
-	struct rt_rpc_internal *rpc,
-	struct rt_pt_node *pts,
-	fastf_t rscale)
-{
-    struct rt_pt_node *node;
-    vect_t rpc_V, VH, Ru, Bu, R, B, RB;
-    point_t p;
-
-    VMOVE(rpc_V, rpc->rpc_V);
-    VADD2(VH, rpc_V, rpc->rpc_H);
-
-    VMOVE(Bu, rpc->rpc_B);
-    VUNITIZE(Bu);
-
-    VCROSS(Ru, Bu, rpc->rpc_H);
-    VUNITIZE(Ru);
-
-    VSCALE(R, Ru, rscale * pts->p[Y]);
-    VSCALE(B, Bu, -pts->p[Z]);
-    VADD2(RB, R, B);
-
-    node = pts;
-    while (node != NULL) {
-	/* calculate face contour point */
-	VSCALE(R, Ru, rscale * node->p[Y]);
-	VSCALE(B, Bu, -node->p[Z]);
-	VADD2(RB, R, B);
-
-	/* start at point on face containing V */
-	VADD2(p, rpc_V, RB);
-	RT_ADD_VLIST(vhead, p, BN_VLIST_LINE_MOVE);
-
-	/* draw to corresponding point on opposing face */
-	VADD2(p, VH, RB);
-	RT_ADD_VLIST(vhead, p, BN_VLIST_LINE_DRAW);
-
-	node = node->next;
-    }
-}
-
-int
-rt_rpc_adaptive_plot(struct rt_db_internal *ip, const struct rt_view_info *info)
-{
-    point_t p;
-    vect_t rpc_R;
-    int num_curve_points;
-    struct rt_rpc_internal *rpc;
-    struct rt_pt_node *pts, *node, *tmp;
-
-    BU_CK_LIST_HEAD(info->vhead);
-    RT_CK_DB_INTERNAL(ip);
-
-    rpc = (struct rt_rpc_internal *)ip->idb_ptr;
-    if (!rpc_is_valid(rpc)) {
-	return -2;
-    }
-
-    num_curve_points = sqrt(primitive_diagonal_samples(ip, info)) / 4.0;
-
-    if (num_curve_points < 3) {
-	num_curve_points = 3;
-    }
-
-    VCROSS(rpc_R, rpc->rpc_B, rpc->rpc_H);
-    VUNITIZE(rpc_R);
-    VSCALE(rpc_R, rpc_R, rpc->rpc_r);
-
-    pts = rpc_parabolic_curve(MAGNITUDE(rpc->rpc_B), rpc->rpc_r, num_curve_points);
-
-    rpc_plot_parabolas(info->vhead, rpc, pts);
-
-    /* connect both halves of the parabolic contours of the opposing faces */
-    rpc_plot_curve_connections(info->vhead, rpc, pts, 1.0);
-    rpc_plot_curve_connections(info->vhead, rpc, pts, -1.0);
-
-    /* plot rectangular face */
-    VADD2(p, rpc->rpc_V, rpc_R);
-    RT_ADD_VLIST(info->vhead, p, BN_VLIST_LINE_MOVE);
-
-    VADD2(p, p, rpc->rpc_H);
-    RT_ADD_VLIST(info->vhead, p, BN_VLIST_LINE_DRAW);
-
-    VJOIN1(p, p, -2.0, rpc_R);
-    RT_ADD_VLIST(info->vhead, p, BN_VLIST_LINE_DRAW);
-
-    VJOIN1(p, p, -1.0, rpc->rpc_H);
-    RT_ADD_VLIST(info->vhead, p, BN_VLIST_LINE_DRAW);
-
-    VJOIN1(p, p, 2.0, rpc_R);
-    RT_ADD_VLIST(info->vhead, p, BN_VLIST_LINE_DRAW);
-
-    node = pts;
-    while (node != NULL) {
-	tmp = node;
-	node = node->next;
-
-	bu_free(tmp, "rt_pt_node");
-    }
-
-    return 0;
-}
-
 /**
  * R T _ R P C _ P L O T
  */
@@ -885,24 +680,37 @@
     struct rt_rpc_internal *xip;
     fastf_t *front;
     fastf_t *back;
-    fastf_t b, dtol, h, ntol, rh;
+    fastf_t b, dtol, f, h, ntol, rh;
     int i, n;
+    mat_t R;
+    mat_t invR;
     struct rt_pt_node *old, *pos, *pts;
-    vect_t Bu, Hu, Ru, B, R;
+    vect_t Bu, Hu, Ru;
 
     BU_CK_LIST_HEAD(vhead);
     RT_CK_DB_INTERNAL(ip);
-
     xip = (struct rt_rpc_internal *)ip->idb_ptr;
-    if (!rpc_is_valid(xip)) {
-	return -2;
-    }
+    RT_RPC_CK_MAGIC(xip);
 
     /* compute |B| |H| */
     b = MAGNITUDE(xip->rpc_B);	/* breadth */
     rh = xip->rpc_r;		/* rectangular halfwidth */
     h = MAGNITUDE(xip->rpc_H);	/* height */
 
+    /* Check for |H| > 0, |B| > 0, |R| > 0 */
+    if (NEAR_ZERO(h, RT_LEN_TOL) || NEAR_ZERO(b, RT_LEN_TOL)
+	|| NEAR_ZERO(rh, RT_LEN_TOL)) {
+	bu_log("rt_rpc_plot():  zero length H, B, or rh\n");
+	return -2;		/* BAD */
+    }
+
+    /* Check for B.H == 0 */
+    f = VDOT(xip->rpc_B, xip->rpc_H) / (b * h);
+    if (! NEAR_ZERO(f, RT_DOT_TOL)) {
+	bu_log("rt_rpc_plot(): B not perpendicular to H, f=%f\n", f);
+	return -3;		/* BAD */
+    }
+
     /* make unit vectors in B, H, and BxH directions */
     VMOVE(Hu, xip->rpc_H);
     VUNITIZE(Hu);
@@ -910,11 +718,40 @@
     VUNITIZE(Bu);
     VCROSS(Ru, Bu, Hu);
 
-    if (rh < b) {
-	dtol = primitive_get_absolute_tolerance(ttol, 2.0 * rh);
+    /* Compute R and Rinv matrices */
+    MAT_IDN(R);
+    VREVERSE(&R[0], Hu);
+    VMOVE(&R[4], Ru);
+    VREVERSE(&R[8], Bu);
+    bn_mat_trn(invR, R);			/* inv of rot mat is trn */
+
+    /*
+     * Establish tolerances
+     */
+    if (ttol->rel <= 0.0 || ttol->rel >= 1.0) {
+	dtol = 0.0;		/* none */
     } else {
-	dtol = primitive_get_absolute_tolerance(ttol, 2.0 * b);
+	/* Convert rel to absolute by scaling by smallest side */
+	if (rh < b)
+	    dtol = ttol->rel * 2 * rh;
+	else
+	    dtol = ttol->rel * 2 * b;
     }
+    if (ttol->abs <= 0.0) {
+	if (dtol <= 0.0) {
+	    /* No tolerance given, use a default */
+	    if (rh < b)
+		dtol = 2 * 0.10 * rh;	/* 10% */
+	    else
+		dtol = 2 * 0.10 * b;	/* 10% */
+	} else {
+	    /* Use absolute-ized relative tolerance */
+	}
+    } else {
+	/* Absolute tolerance was given, pick smaller */
+	if (ttol->rel <= 0.0 || dtol > ttol->abs)
+	    dtol = ttol->abs;
+    }
 
     /* To ensure normal tolerance, remain below this angle */
     if (ttol->norm > 0.0)
@@ -923,6 +760,7 @@
 	/* tolerate everything */
 	ntol = bn_pi;
 
+#if 1
     /* initial parabola approximation is a single segment */
     pts = (struct rt_pt_node *)bu_malloc(sizeof(struct rt_pt_node), "rt_pt_node");
     pts->next = (struct rt_pt_node *)bu_malloc(sizeof(struct rt_pt_node), "rt_pt_node");
@@ -942,24 +780,56 @@
     pos = pts;
     i = 0;
     while (pos) {
-	/* get corresponding rpc contour point in B-R plane from the parabola
-	 * point in the Y-Z plane
-	 */
-	VSCALE(R, Ru, pos->p[Y]);
-	VSCALE(B, Bu, -pos->p[Z]);
-	VADD2(&front[i], R, B);
-
+	/* rotate back to original position */
+	MAT4X3VEC(&front[i], invR, pos->p);
 	/* move to origin vertex origin */
 	VADD2(&front[i], &front[i], xip->rpc_V);
-
 	/* extrude front to create back plate */
 	VADD2(&back[i], &front[i], xip->rpc_H);
+	i += 3;
+	old = pos;
+	pos = pos->next;
+	bu_free((char *)old, "rt_pt_node");
+    }
+#else
+    /* initial parabola approximation is a single segment */
+    pts = (struct rt_pt_node *)bu_malloc(sizeof(struct rt_pt_node), "rt_pt_node");
+    pts->next = (struct rt_pt_node *)bu_malloc(sizeof(struct rt_pt_node), "rt_pt_node");
+    pts->next->next = NULL;
+    VSET(pts->p,       0,   0, -b);
+    VSET(pts->next->p, 0,  rh,  0);
+    /* 2 endpoints in 1st approximation */
+    n = 2;
+    /* recursively break segment 'til within error tolerances */
+    n += rt_mk_parabola(pts, rh, b, dtol, ntol);
 
+    /* get mem for arrays */
+    front = (fastf_t *)bu_malloc((2*3*n-1) * sizeof(fastf_t), "fastf_t");
+    back  = (fastf_t *)bu_malloc((2*3*n-1) * sizeof(fastf_t), "fastf_t");
+
+    /* generate front & back plates in world coordinates */
+    pos = pts;
+    i = 0;
+    while (pos) {
+	/* rotate back to original position */
+	MAT4X3VEC(&front[i], invR, pos->p);
+	/* move to origin vertex origin */
+	VADD2(&front[i], &front[i], xip->rpc_V);
+	/* extrude front to create back plate */
+	VADD2(&back[i], &front[i], xip->rpc_H);
 	i += 3;
 	old = pos;
 	pos = pos->next;
 	bu_free((char *)old, "rt_pt_node");
     }
+    for (i = 3*n; i < 6*n-3; i+=3) {
+	VMOVE(&front[i], &front[6*n-i-6]);
+	front[i+1] = -front[i+1];
+	VMOVE(&back[i], &back[6*n-i-6]);
+	back[i+1] = -back[i+1];
+    }
+    n = 2*n - 1;
+#endif
 
     /* Draw the front */
     RT_ADD_VLIST(vhead, &front[(n-1)*ELEMENTS_PER_VECT],
@@ -992,7 +862,7 @@
  *
  * Approximate a parabola with line segments.  The initial single
  * segment is broken at the point farthest from the parabola if
- * that point is not already within the distance and normal error
+ * that point is not aleady within the distance and normal error
  * tolerances.  The two resulting segments are passed recursively
  * to this routine until each segment is within tolerance.
  */
@@ -1061,7 +931,7 @@
 rt_rpc_tess(struct nmgregion **r, struct model *m, struct rt_db_internal *ip, const struct rt_tess_tol *ttol, const struct bn_tol *tol)
 {
     int i, j, n;
-    fastf_t b, *back, *front, h, rh;
+    fastf_t b, *back, f, *front, h, rh;
     fastf_t dtol, ntol;
     vect_t Bu, Hu, Ru;
     mat_t R;
@@ -1079,17 +949,28 @@
     RT_CK_TESS_TOL(ttol);
 
     RT_CK_DB_INTERNAL(ip);
-
     xip = (struct rt_rpc_internal *)ip->idb_ptr;
-    if (!rpc_is_valid(xip)) {
-	return -2;
-    }
+    RT_RPC_CK_MAGIC(xip);
 
     /* compute |B| |H| */
     b = MAGNITUDE(xip->rpc_B);	/* breadth */
     rh = xip->rpc_r;		/* rectangular halfwidth */
     h = MAGNITUDE(xip->rpc_H);	/* height */
 
+    /* Check for |H| > 0, |B| > 0, |R| > 0 */
+    if (NEAR_ZERO(h, RT_LEN_TOL) || NEAR_ZERO(b, RT_LEN_TOL)
+	|| NEAR_ZERO(rh, RT_LEN_TOL)) {
+	bu_log("rt_rpc_tess():  zero length H, B, or rh\n");
+	return -2;		/* BAD */
+    }
+
+    /* Check for B.H == 0 */
+    f = VDOT(xip->rpc_B, xip->rpc_H) / (b * h);
+    if (! NEAR_ZERO(f, RT_DOT_TOL)) {
+	bu_log("rt_rpc_tess(): B not perpendicular to H, f=%f\n", f);
+	return -3;		/* BAD */
+    }
+
     /* make unit vectors in B, H, and BxH directions */
     VMOVE(Hu, xip->rpc_H);
     VUNITIZE(Hu);
@@ -1104,11 +985,33 @@
     VREVERSE(&R[8], Bu);
     bn_mat_trn(invR, R);			/* inv of rot mat is trn */
 
-    if (rh < b) {
-	dtol = primitive_get_absolute_tolerance(ttol, 2.0 * rh);
+    /*
+     * Establish tolerances
+     */
+    if (ttol->rel <= 0.0 || ttol->rel >= 1.0) {
+	dtol = 0.0;		/* none */
     } else {
-	dtol = primitive_get_absolute_tolerance(ttol, 2.0 * b);
+	/* Convert rel to absolute by scaling by smallest side */
+	if (rh < b)
+	    dtol = ttol->rel * 2 * rh;
+	else
+	    dtol = ttol->rel * 2 * b;
     }
+    if (ttol->abs <= 0.0) {
+	if (dtol <= 0.0) {
+	    /* No tolerance given, use a default */
+	    if (rh < b)
+		dtol = 2 * 0.10 * rh;	/* 10% */
+	    else
+		dtol = 2 * 0.10 * b;	/* 10% */
+	} else {
+	    /* Use absolute-ized relative tolerance */
+	}
+    } else {
+	/* Absolute tolerance was given, pick smaller */
+	if (ttol->rel <= 0.0 || dtol > ttol->abs)
+	    dtol = ttol->abs;
+    }
 
     /* To ensure normal tolerance, remain below this angle */
     if (ttol->norm > 0.0)
@@ -1649,37 +1552,7 @@
     *area = 2.0 * area_base + area_rect + area_shell;
 }
 
-static int
-rpc_is_valid(struct rt_rpc_internal *rpc)
-{
-    fastf_t mag_h, mag_b, cos_angle_bh;
-    vect_t rpc_H, rpc_B;
 
-    RT_RPC_CK_MAGIC(rpc);
-
-    VMOVE(rpc_H, rpc->rpc_H);
-    mag_h = MAGNITUDE(rpc_H);
-
-    VMOVE(rpc_B, rpc->rpc_B);
-    mag_b = MAGNITUDE(rpc_B);
-
-    /* Check for |H| > 0, |B| > 0, |R| > 0 */
-    if (NEAR_ZERO(mag_h, RT_LEN_TOL)
-	|| NEAR_ZERO(mag_b, RT_LEN_TOL)
-	|| NEAR_ZERO(rpc->rpc_r, RT_LEN_TOL))
-    {
-	return 0;
-    }
-
-    /* check B and H are orthogonal */
-    cos_angle_bh = VDOT(rpc_B, rpc_H) / (mag_b * mag_h);
-    if (!NEAR_ZERO(cos_angle_bh, RT_DOT_TOL)) {
-	return 0;
-    }
-
-    return 1;
-}
-
 /*
  * Local Variables:
  * mode: C
Index: src/librt/primitives/rpc/rpc_brep.cpp
===================================================================
--- src/librt/primitives/rpc/rpc_brep.cpp	(revision 53222)
+++ src/librt/primitives/rpc/rpc_brep.cpp	(working copy)
@@ -84,7 +84,7 @@
     parabnurbscurve->SetCV(1, ON_3dPoint(ep2));
     parabnurbscurve->SetCV(2, ON_3dPoint(ep3));
 
-    // Also need a straight line from the beginning to the end to
+    // Also need a staight line from the beginning to the end to
     // complete the loop.
 
     ON_LineCurve* straightedge = new ON_LineCurve(onp3, onp1);
Index: src/librt/primitives/ars/ars.c
===================================================================
--- src/librt/primitives/ars/ars.c	(revision 53222)
+++ src/librt/primitives/ars/ars.c	(working copy)
@@ -1160,7 +1160,7 @@
 		}
 		bu_vls_printf(logstr, " }");
 	    }
-	} else if (!isdigit((int)attr[1])) {
+	} else if (!isdigit(attr[1])) {
 	    bu_vls_printf(logstr,
 			  "ERROR: illegal argument, must be NC, PPC, C, C#, or C#P#\n");
 	    return BRLCAD_ERROR;
@@ -1169,7 +1169,7 @@
 	ptr = strchr(attr, 'P');
 	if (ptr) {
 	    /* a specific point on a specific curve */
-	    if (!isdigit((int)*(ptr+1))) {
+	    if (!isdigit(*(ptr+1))) {
 		bu_vls_printf(logstr,
 			      "ERROR: illegal argument, must be NC, PPC, C, C#, or C#P#\n");
 		return BRLCAD_ERROR;
@@ -1274,7 +1274,7 @@
 		ars->pts_per_curve = i;
 	    }
 	} else if (argv[0][0] == 'C') {
-	    if (isdigit((int)argv[0][1])) {
+	    if (isdigit(argv[0][1])) {
 		char *ptr;
 
 		/* a specific curve */
Index: src/librt/primitives/ehy/ehy.c
===================================================================
--- src/librt/primitives/ehy/ehy.c	(revision 53222)
+++ src/librt/primitives/ehy/ehy.c	(working copy)
@@ -106,7 +106,7 @@
  * NORMALS.  Given the point W on the surface of the ehy, what is the
  * vector normal to the tangent plane at that point?
  *
- * Map W onto the unit ehy, i.e.:  W' = S(R(W - V)).
+ * Map W onto the unit ehy, ie:  W' = S(R(W - V)).
  *
  * Plane on unit ehy at W' has a normal vector N' where
  *
@@ -185,9 +185,6 @@
     { {'\0', '\0', '\0', '\0'}, 0, (char *)NULL, 0, BU_STRUCTPARSE_FUNC_NULL, NULL, NULL }
 };
 
-
-static int ehy_is_valid(struct rt_ehy_internal *ehy);
-
 /**
  * R T _ E H Y _ B B O X
  *
@@ -264,12 +261,8 @@
     struct ehy_specific *ehy;
 
     fastf_t magsq_h;
-#if 0
-    /* unused compile error */
-    fastf_t mag_a;
-#endif
-    fastf_t mag_h;
-    fastf_t c, r1, r2;
+    fastf_t mag_a, mag_h;
+    fastf_t c, f, r1, r2;
     mat_t R;
     mat_t Rinv;
     mat_t S;
@@ -277,21 +270,27 @@
     RT_CK_DB_INTERNAL(ip);
 
     xip = (struct rt_ehy_internal *)ip->idb_ptr;
+    RT_EHY_CK_MAGIC(xip);
 
-    if (!ehy_is_valid(xip)) {
-	return -2;
-    }
-
-#if 0
-    /* unused compile error */
-    mag_a = MAGSQ(xip->ehy_Au); /* a is unit vector, so |A|^2 == |A| */
-#endif
-    magsq_h = MAGSQ(xip->ehy_H);
-    mag_h = sqrt(magsq_h);
+    /* compute |A| |H| */
+    mag_a = sqrt(MAGSQ(xip->ehy_Au));
+    mag_h = sqrt(magsq_h = MAGSQ(xip->ehy_H));
     r1 = xip->ehy_r1;
     r2 = xip->ehy_r2;
     c = xip->ehy_c;
+    /* Check for |H| > 0, |A| == 1, r1 > 0, r2 > 0, c > 0 */
+    if (NEAR_ZERO(mag_h, RT_LEN_TOL)
+	|| !NEAR_EQUAL(mag_a, 1.0, RT_LEN_TOL)
+	|| r1 < 0.0 || r2 < 0.0 || c < 0.0) {
+	return -2;		/* BAD, too small */
+    }
 
+    /* Check for A.H == 0 */
+    f = VDOT(xip->ehy_Au, xip->ehy_H) / mag_h;
+    if (!NEAR_ZERO(f, RT_DOT_TOL)) {
+	return -2;		/* BAD */
+    }
+
     /*
      * EHY is ok
      */
@@ -672,246 +671,14 @@
     return 0;
 }
 
-/* Our canonical hyperbola in the Y-Z plane has equation
- * z = +- (a/b) * sqrt(b^2 + y^2), and opens toward +Z and -Z with asymptote
- * origin at the origin.
- *
- * The contour of an ehy in the plane H-R (where R is one of the ehy axes A or
- * B) is the positive half of a hyperbola with asymptote origin at
- * ((|H| + c)Hu), opening toward -H. We can transform this hyperbola to get an
- * equivalent canonical hyperbola in the Y-Z plane, opening toward +Z (-H) with
- * asymptote origin at the origin.
- *
- * This hyperbola passes through the point (r, |H| + a) (where r = |A| or |B|,
- * and a = c). If we plug the point (r, |H| + a) into our canonical equation,
- * we can derive b from |H|, a, and r.
- *
- *                             |H| + a = (a/b) * sqrt(b^2 + r^2)
- *                       (|H| + a) / a = b * sqrt(b^2 + r^2)
- *                   (|H| + a)^2 / a^2 = 1 + (r^2 / b^2)
- *           ((|H| + a)^2 - a^2) / a^2 = r^2 / b^2
- *   (a^2 * r^2) / ((|H| + a)^2 - a^2) = b^2
- *      (ar) / sqrt((|H| + a)^2 - a^2) = b
- *         (ar) / sqrt(|H| (|H| + 2a)) = b
- */
-static fastf_t
-ehy_hyperbola_b(fastf_t mag_h, fastf_t c, fastf_t r)
-{
-    return (c * r) / sqrt(mag_h * (mag_h + 2.0 * c));
-}
 
-/* The contour of an ehy in the plane H-R (where R is one of the ehy axes A or
- * B) is the positive half of a hyperbola with asymptote origin at
- * ((|H| + c)Hu), opening toward -H. We can transform this hyperbola to get an
- * equivalent hyperbola in the Y-Z plane, opening toward +Z (-H) with asymptote
- * origin at (0, -(|H| + c)).
- *
- * The part of this hyperbola that passes between (0, -(|H| + c)) and (r, 0)
- * (r = |A| or |B|) is approximated by num_points points (including (0, -|H|)
- * and (r, 0)).
- *
- * The constructed point list is returned (NULL returned on error). Because the
- * above transformation puts the ehy vertex at the origin and the hyperbola
- * asymptote origin at (0, -|H| + c), multiplying the z values by -1 gives
- * corresponding distances along the ehy height vector H.
- */
-static struct rt_pt_node *
-ehy_hyperbolic_curve(fastf_t mag_h, fastf_t c, fastf_t r, int num_points)
-{
-    int count;
-    struct rt_pt_node *curve;
-
-    curve = (struct rt_pt_node *)bu_malloc(sizeof(struct rt_pt_node), "rt_pt_node");
-    curve->next = (struct rt_pt_node *)bu_malloc(sizeof(struct rt_pt_node), "rt_pt_node");
-
-    curve->next->next = NULL;
-    VSET(curve->p,       0, 0, -mag_h);
-    VSET(curve->next->p, 0, r, 0);
-
-    count = approximate_hyperbolic_curve(curve, c, ehy_hyperbola_b(mag_h, c, r), num_points - 2);
-
-    if (count != (num_points - 2)) {
-	return NULL;
-    }
-
-    return curve;
-}
-
-/* The contour of an ehy in the plane H-R (where R is one of the ehy axes A or
- * B) is the positive half of a hyperbola with asymptote origin at
- * ((|H| + c)Hu), opening toward -H. We can transform this hyperbola to get an
- * equivalent hyperbola in the Y-Z plane, with asymptote origin at
- * (0, |H| + a) (a = c) opening toward +Z.
- *
- * The equation for this hyperbola is a variant of the equation for our
- * canonical hyperbola in the Y-Z plane (z = (a/b) * sqrt(y^2 + b^2)):
- *   z = (|H| + a) - (a/b) * sqrt(y^2 + b^2)
- *
- * Solving this equation for y yields:
- *   y = (b/a) * sqrt((|H| + a - z)^2 - a^2)
- *
- * Substituting b = (ar) / sqrt(|H| (|H| + 2a)) (see above comment):
- *
- *   y = (r / sqrt(|H| (|H| + 2a))) * sqrt((|H| + a - z)^2 - a^2)
- *     = r * sqrt( ((|H| + a - z)^2 - a^2) / (|H| (|H| + 2a))) )
- */
-static fastf_t
-ehy_hyperbola_y(fastf_t mag_H, fastf_t c, fastf_t r, fastf_t z)
-{
-    fastf_t n, d;
-
-    n = pow(mag_H + c - z, 2) - c * c;
-    d = mag_H * (mag_H + 2.0 * c);
-
-    return r * sqrt(n / d);
-}
-
-/* Plot the elliptical cross section of the given ehy at distance h along the
- * ehy height vector (h >= 0, h <= |H|) consisting of num_points points.
- */
-static void
-ehy_plot_ellipse(
-	struct bu_list *vhead,
-	struct rt_ehy_internal *ehy,
-	fastf_t h,
-	fastf_t num_points)
-{
-    fastf_t mag_H;
-    vect_t V, Hu, Au, Bu, A, B, cross_section_plane;
-
-    VMOVE(V, ehy->ehy_V);
-
-    mag_H = MAGNITUDE(ehy->ehy_H);
-    VSCALE(Hu, ehy->ehy_H, 1.0 / mag_H);
-
-    VMOVE(Au, ehy->ehy_Au);
-    VCROSS(Bu, Au, Hu);
-
-    /* calculate semi-major and semi-minor axis for the elliptical
-     * cross-section at distance h along H
-     */
-    VSCALE(A, Au, ehy_hyperbola_y(mag_H, ehy->ehy_c, ehy->ehy_r1, h));
-    VSCALE(B, Bu, ehy_hyperbola_y(mag_H, ehy->ehy_c, ehy->ehy_r2, h));
-    VJOIN1(cross_section_plane, V, h, Hu);
-
-    plot_ellipse(vhead, cross_section_plane, A, B, num_points);
-}
-
-static void
-ehy_plot_hyperbola(
-	struct bu_list *vhead,
-	struct rt_ehy_internal *ehy,
-	struct rt_pt_node *pts,
-	vect_t Ru,
-	fastf_t r)
-{
-    point_t p;
-    vect_t ehy_V, Hu;
-    fastf_t mag_H, c, z;
-    struct rt_pt_node *node;
-
-    VMOVE(ehy_V, ehy->ehy_V);
-    mag_H = MAGNITUDE(ehy->ehy_H);
-    VSCALE(Hu, ehy->ehy_H, 1.0 / mag_H);
-    c = ehy->ehy_c;
-
-    z = pts->p[Z];
-    VJOIN2(p, ehy_V, ehy_hyperbola_y(mag_H, c, r, -z), Ru, -z, Hu);
-    RT_ADD_VLIST(vhead, p, BN_VLIST_LINE_MOVE);
-
-    node = pts->next;
-    while (node != NULL) {
-	z = node->p[Z];
-	VJOIN2(p, ehy_V, ehy_hyperbola_y(mag_H, c, r, -z), Ru, -z, Hu);
-
-	RT_ADD_VLIST(vhead, p, BN_VLIST_LINE_DRAW);
-
-	node = node->next;
-    }
-}
-
-int
-rt_ehy_adaptive_plot(struct rt_db_internal *ip, const struct rt_view_info *info)
-{
-    vect_t ehy_H, Hu, Au, Bu;
-    fastf_t mag_H, z, c, r1, r2;
-    int i, num_curve_points, num_ellipse_points;
-    struct rt_ehy_internal *ehy;
-    struct rt_pt_node *pts_r1, *pts_r2, *node, *node1, *node2;
-
-    num_curve_points = sqrt(primitive_diagonal_samples(ip, info)) / 4.0;
-
-    if (num_curve_points < 3) {
-	num_curve_points = 3;
-    }
-
-    num_ellipse_points = 4 * num_curve_points;
-
-    BU_CK_LIST_HEAD(info->vhead);
-    RT_CK_DB_INTERNAL(ip);
-    ehy = (struct rt_ehy_internal *)ip->idb_ptr;
-    RT_EHY_CK_MAGIC(ehy);
-
-    VMOVE(ehy_H, ehy->ehy_H);
-
-    mag_H = MAGNITUDE(ehy_H);
-    VSCALE(Hu, ehy->ehy_H, 1.0 / mag_H);
-
-    VMOVE(Au, ehy->ehy_Au);
-    VCROSS(Bu, Au, Hu);
-
-    r1 = ehy->ehy_r1;
-    r2 = ehy->ehy_r2;
-    c = ehy->ehy_c;
-
-    pts_r1 = ehy_hyperbolic_curve(mag_H, c, r1, num_curve_points);
-    pts_r2 = ehy_hyperbolic_curve(mag_H, c, r2, num_curve_points);
-
-    if (pts_r1 == NULL || pts_r2 == NULL) {
-	return -1;
-    }
-
-    node1 = pts_r1;
-    node2 = pts_r2;
-    for (i = 0; i < num_curve_points; ++i) {
-	/* Select cross-section to draw by averaging the z values and flip over y-axis
-	 * to get a distance along H.
-	 */
-	z = (node1->p[Z] + node2->p[Z]) / 2.0;
-	ehy_plot_ellipse(info->vhead, ehy, -z, num_ellipse_points);
-
-	node1 = node1->next;
-	node2 = node2->next;
-    }
-
-    ehy_plot_hyperbola(info->vhead, ehy, pts_r1, Au, r1);
-    ehy_plot_hyperbola(info->vhead, ehy, pts_r1, Au, -r1);
-    ehy_plot_hyperbola(info->vhead, ehy, pts_r1, Bu, r2);
-    ehy_plot_hyperbola(info->vhead, ehy, pts_r1, Bu, -r2);
-
-    node1 = pts_r1;
-    node2 = pts_r2;
-    for (i = 0; i < num_curve_points; ++i) {
-	node = node1;
-	bu_free(node, "rt_pt_node");
-
-	node = node2;
-	bu_free(node, "rt_pt_node");
-
-	node1 = node1->next;
-	node2 = node2->next;
-    }
-
-    return 0;
-}
-
 /**
  * R T _ E H Y _ P L O T
  */
 int
 rt_ehy_plot(struct bu_list *vhead, struct rt_db_internal *ip, const struct rt_tess_tol *ttol, const struct bn_tol *UNUSED(tol), const struct rt_view_info *UNUSED(info))
 {
-    fastf_t c, dtol, mag_h, ntol, r1, r2;
+    fastf_t c, dtol, f, mag_a, mag_h, ntol, r1, r2;
     fastf_t **ellipses, theta_prev, theta_new;
     int *pts_dbl, i, j, nseg;
     int jj, na, nb, nell, recalc_b;
@@ -925,16 +692,31 @@
     BU_CK_LIST_HEAD(vhead);
     RT_CK_DB_INTERNAL(ip);
     xip = (struct rt_ehy_internal *)ip->idb_ptr;
+    RT_EHY_CK_MAGIC(xip);
 
-    if (!ehy_is_valid(xip)) {
-	return -2;
-    }
+    /*
+     * make sure ehy description is valid
+     */
 
+    /* compute |A| |H| */
+    mag_a = MAGSQ(xip->ehy_Au);	/* should already be unit vector */
     mag_h = MAGNITUDE(xip->ehy_H);
+    c = xip->ehy_c;
     r1 = xip->ehy_r1;
     r2 = xip->ehy_r2;
-    c = xip->ehy_c;
+    /* Check for |H| > 0, |A| == 1, r1 > 0, r2 > 0, c > 0 */
+    if (NEAR_ZERO(mag_h, RT_LEN_TOL)
+	|| !NEAR_EQUAL(mag_a, 1.0, RT_LEN_TOL)
+	|| r1 <= 0.0 || r2 <= 0.0 || c <= 0.) {
+	return -2;		/* BAD */
+    }
 
+    /* Check for A.H == 0 */
+    f = VDOT(xip->ehy_Au, xip->ehy_H) / mag_h;
+    if (! NEAR_ZERO(f, RT_DOT_TOL)) {
+	return -2;		/* BAD */
+    }
+
     /* make unit vectors in A, H, and BxH directions */
     VMOVE(Hu, xip->ehy_H);
     VUNITIZE(Hu);
@@ -948,13 +730,32 @@
     VREVERSE(&R[8], Hu);
     bn_mat_trn(invR, R);			/* inv of rot mat is trn */
 
-    dtol = primitive_get_absolute_tolerance(ttol, 2.0 * xip->ehy_r2);
+    /*
+     * Establish tolerances
+     */
+    if (ttol->rel <= 0.0 || ttol->rel >= 1.0)
+	dtol = 0.0;		/* none */
+    else
+	/* Convert rel to absolute by scaling by smallest side */
+	dtol = ttol->rel * 2 * r2;
+    if (ttol->abs <= 0.0) {
+	if (dtol <= 0.0) {
+	    /* No tolerance given, use a default */
+	    dtol = 2 * 0.10 * r2;	/* 10% */
+	}
+	/* Use absolute-ized relative tolerance */
+    } else {
+	/* Absolute tolerance was given, pick smaller */
+	if (ttol->rel <= 0.0 || dtol > ttol->abs)
+	    dtol = ttol->abs;
+    }
 
-    /* stay below ntol to ensure normal tolerance */
-    ntol = M_PI;
-    if (ttol->norm > 0.0) {
+    /* To ensure normal tolerance, remain below this angle */
+    if (ttol->norm > 0.0)
 	ntol = ttol->norm;
-    }
+    else
+	/* tolerate everything */
+	ntol = bn_pi;
 
     /*
      * build ehy from 2 hyperbolas
@@ -1158,11 +959,7 @@
 int
 rt_ehy_tess(struct nmgregion **r, struct model *m, struct rt_db_internal *ip, const struct rt_tess_tol *ttol, const struct bn_tol *tol)
 {
-#if 0
-    /* unused compile error */
-    fastf_t mag_a;
-#endif
-    fastf_t c, dtol, mag_h, ntol, r1, r2, cprime;
+    fastf_t c, dtol, f, mag_a, mag_h, ntol, r1, r2, cprime;
     fastf_t **ellipses, theta_prev, theta_new;
     int *pts_dbl, face, i, j, nseg;
     int jj, na, nb, nell, recalc_b;
@@ -1186,21 +983,32 @@
 
     RT_CK_DB_INTERNAL(ip);
     xip = (struct rt_ehy_internal *)ip->idb_ptr;
+    RT_EHY_CK_MAGIC(xip);
 
-    if (!ehy_is_valid(xip)) {
-	return 1;
-    }
+    /*
+     * make sure ehy description is valid
+     */
 
-#if 0
-    /* unused compile error */
-    mag_a = MAGSQ(xip->ehy_Au); /* a is unit vector, so |A|^2 == |A| */
-#endif
+    /* compute |A| |H| */
+    mag_a = MAGSQ(xip->ehy_Au);	/* should already be unit vector */
     mag_h = MAGNITUDE(xip->ehy_H);
     c = xip->ehy_c;
     cprime = c / mag_h;
     r1 = xip->ehy_r1;
     r2 = xip->ehy_r2;
+    /* Check for |H| > 0, |A| == 1, r1 > 0, r2 > 0, c > 0 */
+    if (NEAR_ZERO(mag_h, RT_LEN_TOL)
+	|| !NEAR_EQUAL(mag_a, 1.0, RT_LEN_TOL)
+	|| r1 <= 0.0 || r2 <= 0.0 || c <= 0.) {
+	return 1;		/* BAD */
+    }
 
+    /* Check for A.H == 0 */
+    f = VDOT(xip->ehy_Au, xip->ehy_H) / mag_h;
+    if (! NEAR_ZERO(f, RT_DOT_TOL)) {
+	return 1;		/* BAD */
+    }
+
     /* make unit vectors in A, H, and BxH directions */
     VMOVE(Hu, xip->ehy_H);
     VUNITIZE(Hu);
@@ -1224,13 +1032,32 @@
     bn_mat_mul(SoR, S, R);
     bn_mat_mul(invRoS, invR, S);
 
-    dtol = primitive_get_absolute_tolerance(ttol, 2.0 * xip->ehy_r2);
+    /*
+     * Establish tolerances
+     */
+    if (ttol->rel <= 0.0 || ttol->rel >= 1.0)
+	dtol = 0.0;		/* none */
+    else
+	/* Convert rel to absolute by scaling by smallest side */
+	dtol = ttol->rel * 2 * r2;
+    if (ttol->abs <= 0.0) {
+	if (dtol <= 0.0) {
+	    /* No tolerance given, use a default */
+	    dtol = 2 * 0.10 * r2;	/* 10% */
+	}
+	/* Use absolute-ized relative tolerance */
+    } else {
+	/* Absolute tolerance was given, pick smaller */
+	if (ttol->rel <= 0.0 || dtol > ttol->abs)
+	    dtol = ttol->abs;
+    }
 
-    /* stay below ntol to ensure normal tolerance */
-    ntol = M_PI;
-    if (ttol->norm > 0.0) {
+    /* To ensure normal tolerance, remain below this angle */
+    if (ttol->norm > 0.0)
 	ntol = ttol->norm;
-    }
+    else
+	/* tolerate everything */
+	ntol = bn_pi;
 
     /*
      * build ehy from 2 hyperbolas
@@ -1932,43 +1759,7 @@
     return 0;			/* OK */
 }
 
-static int
-ehy_is_valid(struct rt_ehy_internal *ehy)
-{
-    fastf_t mag_h, cos_angle_ah;
-    vect_t a, h;
 
-    RT_EHY_CK_MAGIC(ehy);
-
-    if (!(ehy->ehy_r1 > 0.0 && ehy->ehy_r2 > 0.0 && ehy->ehy_c > 0.0)) {
-	return 0;
-    }
-
-    VMOVE(h, ehy->ehy_H);
-    VMOVE(a, ehy->ehy_Au);
-
-    /* Check that A is a unit vector. If it is, then it should be true that
-     * |A| == |A|^2 == 1.0.
-     */
-    if (!NEAR_EQUAL(MAGSQ(a), 1.0, RT_LEN_TOL)) {
-	return 0;
-    }
-
-    /* check that |H| > 0.0 */
-    mag_h = MAGNITUDE(h);
-    if (NEAR_ZERO(mag_h, RT_LEN_TOL)) {
-	return 0;
-    }
-
-    /* check that A and H are orthogonal */
-    cos_angle_ah = VDOT(a, h) / mag_h;
-    if (!NEAR_ZERO(cos_angle_ah, RT_DOT_TOL)) {
-	return 0;
-    }
-
-    return 1;
-}
-
 /** @} */
 /*
  * Local Variables:
Index: src/librt/primitives/ehy/ehy_brep.cpp
===================================================================
--- src/librt/primitives/ehy/ehy_brep.cpp	(revision 53222)
+++ src/librt/primitives/ehy/ehy_brep.cpp	(working copy)
@@ -112,7 +112,7 @@
     (*b)->SetTrimIsoFlags(bface);
     delete ellcurve1;
 
-    //  Now, the hard part.  Need an elliptical hyperbolic NURBS surface
+    //  Now, the hard part.  Need an elliptical hyperboloic NURBS surface
     //  First step is to create a nurbs curve.
 
     double intercept_calc = (eip->ehy_c)*(eip->ehy_c)/(MAGNITUDE(eip->ehy_H) + eip->ehy_c);
Index: src/librt/primitives/eto/eto.c
===================================================================
--- src/librt/primitives/eto/eto.c	(revision 53222)
+++ src/librt/primitives/eto/eto.c	(working copy)
@@ -41,7 +41,6 @@
 
 #include "../../librt_private.h"
 
-static int eto_is_valid(struct rt_eto_internal *eto);
 
 /*
  * The ETO has the following input fields:
@@ -62,7 +61,7 @@
  *
  * Through a series of Transformations, this set will be transformed
  * into a set of points on an eto centered at the origin which lies on
- * the X-Y plane (i.e., N is on the Z axis).
+ * the X-Y plane (ie, N is on the Z axis).
  *
  * { (x', y', z') | (x', y', z') is an eto at origin }
  *
@@ -109,13 +108,13 @@
  * Wx**2 = Dx**2 * t**2 +  2 * Dx * Px +  Px**2
  *
  * The real roots of the equation in 't' are the intersect points
- * along the parametric line.
+ * along the parameteric line.
  *
  * NORMALS.  Given the point W on the eto, what is the vector normal
  * to the tangent plane at that point?
  *
- * Map W onto the eto, i.e.: W' = R(W - V).  In this case, we find W'
- * by solving the parametric line given k.
+ * Map W onto the eto, ie: W' = R(W - V).  In this case, we find W'
+ * by solving the parameteric line given k.
  *
  * The gradient of the eto at W' is in fact the
  * normal vector.
@@ -232,9 +231,7 @@
     if (rtip) RT_CK_RTI(rtip);
 
     tip = (struct rt_eto_internal *)ip->idb_ptr;
-    if (!eto_is_valid(tip)) {
-	return 1;
-    }
+    RT_ETO_CK_MAGIC(tip);
 
     /* Solid is OK, compute constant terms now */
     BU_GET(eto, struct eto_specific);
@@ -243,6 +240,11 @@
     eto->eto_r = tip->eto_r;
     eto->eto_rd = tip->eto_rd;
     eto->eto_rc = MAGNITUDE(tip->eto_C);
+    if (NEAR_ZERO(eto->eto_r, 0.0001) || NEAR_ZERO(eto->eto_rd, 0.0001)
+	|| NEAR_ZERO(eto->eto_rc, 0.0001)) {
+	bu_log("eto(%s): r, rd, or rc zero length\n", stp->st_name);
+	return 1;
+    }
 
     VMOVE(eto->eto_V, tip->eto_V);
     VMOVE(eto->eto_N, tip->eto_N);
@@ -748,7 +750,7 @@
  *
  * Approximate one fourth (1st quadrant) of an ellipse with line
  * segments.  The initial single segment is broken at the point
- * farthest from the ellipse if that point is not already within the
+ * farthest from the ellipse if that point is not aleady within the
  * distance and normal error tolerances.  The two resulting segments
  * are passed recursively to this routine until each segment is within
  * tolerance.
@@ -879,17 +881,18 @@
     fastf_t radian, radian_step;
     vect_t ellipse_A, ellipse_B, contour_A, contour_B, I, J;
     vect_t center, cross_AN, eto_V, eto_N, eto_A, eto_B;
-    fastf_t mag_A, mag_B, mag_N, mag_ai, mag_aj, mag_bi, mag_bj;
+    fastf_t mag_N, mag_ai, mag_aj, mag_bi, mag_bj;
+    /* fastf_t  mag_B, mag_A; */
     int i, samples, num_cross_sections, points_per_cross_section;
 
     BU_CK_LIST_HEAD(info->vhead);
     RT_CK_DB_INTERNAL(ip);
 
     eto = (struct rt_eto_internal *)ip->idb_ptr;
-    if (!eto_is_valid(eto)) {
+   /* if (!eto_is_valid(eto)) {
 	return 1;
     }
-
+*/
     samples = sqrt(primitive_diagonal_samples(ip, info));
 
     if (samples < 8) {
@@ -916,12 +919,12 @@
     VCROSS(eto_A, eto_N, cross_AN);
     VUNITIZE(eto_A);
     VSCALE(eto_A, eto_A, eto->eto_r);
-    mag_A = MAGNITUDE(eto_A);
+    /*mag_A = MAGNITUDE(eto_A);*/
 
     VCROSS(eto_B, eto_N, eto_A);
     VUNITIZE(eto_B);
     VSCALE(eto_B, eto_B, eto->eto_r);
-    mag_B = MAGNITUDE(eto_B);
+    /*mag_B = MAGNITUDE(eto_B);*/
 
     /* We want to be able to plot any of the ellipses that result from
      * intersecting the eto with a plane containing N. The center point of any
@@ -1015,21 +1018,46 @@
 
     BU_CK_LIST_HEAD(vhead);
     RT_CK_DB_INTERNAL(ip);
-
     tip = (struct rt_eto_internal *)ip->idb_ptr;
-    if (!eto_is_valid(tip)) {
-	return 1;
-    }
+    RT_ETO_CK_MAGIC(tip);
 
     a = MAGNITUDE(tip->eto_C);
     b = tip->eto_rd;
 
-    if (tip->eto_r < b) {
-	dtol = primitive_get_absolute_tolerance(ttol, 2.0 * tip->eto_r);
+    if (NEAR_ZERO(tip->eto_r, 0.0001) || NEAR_ZERO(b, 0.0001)
+	|| NEAR_ZERO(a, 0.0001)) {
+	bu_log("eto_plot: r, rd, or rc zero length\n");
+	return 1;
+    }
+
+    /* Establish tolerances */
+    if (ttol->rel <= 0.0 || ttol->rel >= 1.0) {
+	dtol = 0.0;		/* none */
     } else {
-	dtol = primitive_get_absolute_tolerance(ttol, 2.0 * b);
+	/*
+	 * Convert relative to absolute by scaling smallest of radius
+	 * and semi-minor axis
+	 */
+	if (tip->eto_r < b)
+	    dtol = ttol->rel * 2 * tip->eto_r;
+	else
+	    dtol = ttol->rel * 2 * b;
     }
-
+    if (ttol->abs <= 0.0) {
+	if (dtol <= 0.0) {
+	    /* No tolerance given, use a default */
+	    if (tip->eto_r < b)
+		dtol = 2 * 0.10 * tip->eto_r;	/* 10% */
+	    else
+		dtol = 2 * 0.10 * b;	/* 10% */
+	} else {
+	    /* Use absolute-ized relative tolerance */
+	}
+    } else {
+	/* Absolute tolerance was given, pick smaller */
+	if (ttol->rel <= 0.0 || dtol > ttol->abs)
+	    dtol = ttol->abs;
+    }
     /* To ensure normal tolerance, remain below this angle */
     if (ttol->norm > 0.0)
 	ntol = ttol->norm;
@@ -1145,12 +1173,34 @@
 	goto failure;
     }
 
-    if (tip->eto_r < b) {
-	dtol = primitive_get_absolute_tolerance(ttol, 2.0 * tip->eto_r);
+    /* Establish tolerances */
+    if (ttol->rel <= 0.0 || ttol->rel >= 1.0) {
+	dtol = 0.0;		/* none */
     } else {
-	dtol = primitive_get_absolute_tolerance(ttol, 2.0 * b);
+	/*
+	 * Convert relative to absolute by scaling smallest of
+	 * radius and semi-minor axis
+	 */
+	if (tip->eto_r < b)
+	    dtol = ttol->rel * 2 * tip->eto_r;
+	else
+	    dtol = ttol->rel * 2 * b;
     }
-
+    if (ttol->abs <= 0.0) {
+	if (dtol <= 0.0) {
+	    /* No tolerance given, use a default */
+	    if (tip->eto_r < b)
+		dtol = 2 * 0.10 * tip->eto_r;	/* 10% */
+	    else
+		dtol = 2 * 0.10 * b;	/* 10% */
+	} else {
+	    /* Use absolute-ized relative tolerance */
+	}
+    } else {
+	/* Absolute tolerance was given, pick smaller */
+	if (ttol->rel <= 0.0 || dtol > ttol->abs)
+	    dtol = ttol->abs;
+    }
     /* To ensure normal tolerance, remain below this angle */
     if (ttol->norm > 0.0)
 	ntol = ttol->norm;
@@ -1373,11 +1423,8 @@
 
     RT_CK_DB_INTERNAL(ip);
     if (ip->idb_type != ID_ETO) return -1;
-
     tip = (struct rt_eto_internal *)ip->idb_ptr;
-    if (!eto_is_valid(tip)) {
-	return -1;
-    }
+    RT_ETO_CK_MAGIC(tip);
 
     BU_CK_EXTERNAL(ep);
     ep->ext_nbytes = sizeof(union record);
@@ -1387,6 +1434,19 @@
     eto->s.s_id = ID_SOLID;
     eto->s.s_type = ETO;
 
+    if (MAGNITUDE(tip->eto_C) < RT_LEN_TOL
+	|| MAGNITUDE(tip->eto_N) < RT_LEN_TOL
+	|| tip->eto_r < RT_LEN_TOL
+	|| tip->eto_rd < RT_LEN_TOL) {
+	bu_log("rt_eto_export4: not all dimensions positive!\n");
+	return -1;
+    }
+
+    if (tip->eto_rd > MAGNITUDE(tip->eto_C)) {
+	bu_log("rt_eto_export4: semi-minor axis cannot be longer than semi-major axis!\n");
+	return -1;
+    }
+
     /* Warning:  type conversion */
     VSCALE(&eto->s.s_values[0*3], tip->eto_V, local2mm);
     VSCALE(&eto->s.s_values[1*3], tip->eto_N, local2mm);
@@ -1435,7 +1495,8 @@
     tip->eto_r  = vec[3*3] / mat[15];
     tip->eto_rd = vec[3*3+1] / mat[15];
 
-    if (!eto_is_valid(tip)) {
+    if (tip->eto_r <= SMALL || tip->eto_rd <= SMALL) {
+	bu_log("rt_eto_import4:  zero length R or Rd vector\n");
 	return -1;
     }
 
@@ -1458,16 +1519,26 @@
 
     RT_CK_DB_INTERNAL(ip);
     if (ip->idb_type != ID_ETO) return -1;
-
     tip = (struct rt_eto_internal *)ip->idb_ptr;
-    if (!eto_is_valid(tip)) {
-	return -1;
-    }
+    RT_ETO_CK_MAGIC(tip);
 
     BU_CK_EXTERNAL(ep);
     ep->ext_nbytes = SIZEOF_NETWORK_DOUBLE * 11;
     ep->ext_buf = (genptr_t)bu_malloc(ep->ext_nbytes, "eto external");
 
+    if (MAGNITUDE(tip->eto_C) < RT_LEN_TOL
+	|| MAGNITUDE(tip->eto_N) < RT_LEN_TOL
+	|| tip->eto_r < RT_LEN_TOL
+	|| tip->eto_rd < RT_LEN_TOL) {
+	bu_log("rt_eto_export4: not all dimensions positive!\n");
+	return -1;
+    }
+
+    if (tip->eto_rd > MAGNITUDE(tip->eto_C)) {
+	bu_log("rt_eto_export4: semi-minor axis cannot be longer than semi-major axis!\n");
+	return -1;
+    }
+
     /* scale 'em into local buffer */
     VSCALE(&vec[0*3], tip->eto_V, local2mm);
     VSCALE(&vec[1*3], tip->eto_N, local2mm);
@@ -1608,28 +1679,7 @@
     *area = 2.0 * M_PI * tip->eto_r * circum;
 }
 
-static int
-eto_is_valid(struct rt_eto_internal *eto)
-{
-    RT_ETO_CK_MAGIC(eto);
 
-    /* check all vector magnitudes are positive */
-    if (MAGNITUDE(eto->eto_N) < RT_LEN_TOL
-	|| MAGNITUDE(eto->eto_C) < RT_LEN_TOL
-	|| eto->eto_r < RT_LEN_TOL
-	|| eto->eto_rd < RT_LEN_TOL)
-    {
-	return 0;
-    }
-
-    /* require major axis to be longer than minor axis */
-    if (eto->eto_rd > MAGNITUDE(eto->eto_C)) {
-	return 0;
-    }
-
-    return 1;
-}
-
 /** @} */
 /*
  * Local Variables:
Index: src/librt/primitives/brep/brep_debug.cpp
===================================================================
--- src/librt/primitives/brep/brep_debug.cpp	(revision 53222)
+++ src/librt/primitives/brep/brep_debug.cpp	(working copy)
@@ -45,6 +45,7 @@
 #include "rtgeom.h"
 #include "wdb.h"
 
+#define fastf_t double
 
 #ifdef __cplusplus
 extern "C" {
@@ -93,7 +94,7 @@
     RT_ADD_VLIST(vhead, valp[d], BN_VLIST_LINE_DRAW);
 
 #define BB_PLOT_VLIST(min, max) {		\
-	fastf_t pt[8][3];			\
+	double pt[8][3];			\
 	VSET(pt[0], max[X], min[Y], min[Z]);	\
 	VSET(pt[1], max[X], max[Y], min[Z]);	\
 	VSET(pt[2], max[X], max[Y], max[Z]);	\
@@ -110,8 +111,7 @@
 
 void
 plotsurfaceleafs(SurfaceTree* surf) {
-    vect_t min;
-    vect_t max;
+    double min[3], max[3];
     std::list<BBNode*> leaves;
     surf->getLeaves(leaves);
 
@@ -155,7 +155,7 @@
 plotsurfaceleafs(SurfaceTree* surf, struct bn_vlblock *vbp, bool dim3d)
 {
     register struct bu_list *vhead;
-    fastf_t min[3], max[3];
+    double min[3], max[3];
     std::list<BBNode*> leaves;
     surf->getLeaves(leaves);
 
@@ -196,8 +196,7 @@
 plottrimleafs(SurfaceTree* st, struct bn_vlblock *vbp, bool dim3d)
 {
     register struct bu_list *vhead;
-    vect_t min;
-    vect_t max;
+    double min[3], max[3];
     std::list<BRNode*> leaves;
     st->ctree->getLeaves(leaves);
 
@@ -238,14 +237,13 @@
 void
 plotleaf3d(BBNode* bb)
 {
-    vect_t min;
-    vect_t max;
-    fastf_t u, v;
+    double min[3], max[3];
+    double u, v;
     ON_2dPoint uv[2];
     int trim1_status;
     int trim2_status;
-    fastf_t closesttrim1;
-    fastf_t closesttrim2;
+    double closesttrim1;
+    double closesttrim2;
 
     if (bb->m_trimmed) {
 	COLOR_PLOT(255, 0, 0);
@@ -298,8 +296,7 @@
 void
 plotleafuv(BBNode* bb)
 {
-    vect_t min;
-    vect_t max;
+    double min[3], max[3];
 
     if (bb->m_trimmed) {
 	COLOR_PLOT(255, 0, 0);
@@ -326,8 +323,8 @@
 {
     register struct bu_list *vhead;
     const ON_Surface* surf = face.SurfaceOf();
-    fastf_t umin, umax;
-    fastf_t pt1[3], pt2[3];
+    double umin, umax;
+    double pt1[3], pt2[3];
     ON_2dPoint from, to;
 
     ON_TextLog tl(stderr);
@@ -369,8 +366,8 @@
 {
     register struct bu_list *vhead;
     const ON_Surface* surf = face.SurfaceOf();
-    fastf_t umin, umax;
-    fastf_t pt1[3], pt2[3];
+    double umin, umax;
+    double pt1[3], pt2[3];
     ON_2dPoint from, to;
 
     ON_TextLog tl(stderr);
@@ -410,9 +407,9 @@
 {
     register struct bu_list *vhead;
     const ON_Surface* surf = face.SurfaceOf();
-    fastf_t umin, umax, urange;
-    fastf_t vmin, vmax, vrange;
-    fastf_t pt1[3], pt2[3];
+    double umin, umax, urange;
+    double vmin, vmax, vrange;
+    double pt1[3], pt2[3];
     ON_2dPoint from, to;
 
     ON_TextLog tl(stderr);
@@ -460,8 +457,8 @@
     register struct bu_list *vhead;
     ON_BrepFace *face= trim.Face();
     const ON_Surface* surf = face->SurfaceOf();
-    fastf_t umin, umax;
-    fastf_t pt1[3], pt2[3];
+    double umin, umax;
+    double pt1[3], pt2[3];
     ON_2dPoint from, to;
 
     ON_TextLog tl(stderr);
@@ -497,8 +494,8 @@
 {
     register struct bu_list *vhead;
     const ON_Surface* surf = face.SurfaceOf();
-    fastf_t umin, umax;
-    fastf_t pt1[3], pt2[3];
+    double umin, umax;
+    double pt1[3], pt2[3];
     ON_2dPoint from, to;
 
     ON_TextLog tl(stderr);
@@ -515,13 +512,13 @@
 	    //trimCurve->Dump(tl);
 
 	    int knotcnt = trimCurve->SpanCount();
-	    fastf_t *knots = new fastf_t[knotcnt + 1];
+	    double *knots = new double[knotcnt + 1];
 
 	    trimCurve->GetSpanVector(knots);
 	    for (int k = 1; k <= knotcnt; k++) {
-		fastf_t dist = knots[k] - knots[k-1];
-		fastf_t step = dist/plotres;
-		for (fastf_t t=knots[k-1]+step; t<=knots[k]; t=t+step) {
+		double dist = knots[k] - knots[k-1];
+		double step = dist/plotres;
+		for (double t=knots[k-1]+step; t<=knots[k]; t=t+step) {
 		    ON_3dPoint p = trimCurve->PointAt(t);
 		    p = surf->PointAt(p.x, p.y);
 		    ON_3dPoint prev = trimCurve->PointAt(t-step*0.1);
@@ -557,7 +554,7 @@
 plotsurface(ON_Surface &surf, struct bn_vlblock *vbp, int isocurveres, int gridres, const int red = 255, const int green = 218, const int blue = 185)
 {
     register struct bu_list *vhead;
-    fastf_t pt1[3], pt2[3];
+    double pt1[3], pt2[3];
     ON_2dPoint from, to;
 
     vhead = rt_vlblock_find(vbp, red, green, blue);
@@ -594,7 +591,7 @@
 plotsurfacenormals(ON_Surface &surf, struct bn_vlblock *vbp, int gridres)
 {
     register struct bu_list *vhead;
-    fastf_t pt1[3], pt2[3];
+    double pt1[3], pt2[3];
     ON_2dPoint from, to;
 
     vhead = rt_vlblock_find(vbp, GREEN);
@@ -622,14 +619,14 @@
 plotsurfaceknots(ON_Surface &surf, struct bn_vlblock *vbp)
 {
     register struct bu_list *vhead;
-    fastf_t pt1[3], pt2[3];
+    double pt1[3], pt2[3];
     ON_2dPoint from, to;
     int spanu_cnt = surf.SpanCount(0);
     int spanv_cnt = surf.SpanCount(1);
-    fastf_t *spanu = NULL;
-    fastf_t *spanv = NULL;
-    spanu = new fastf_t[spanu_cnt+1];
-    spanv = new fastf_t[spanv_cnt+1];
+    double *spanu = NULL;
+    double *spanv = NULL;
+    spanu = new double[spanu_cnt+1];
+    spanv = new double[spanv_cnt+1];
     surf.GetSpanVector(0, spanu);
     surf.GetSpanVector(1, spanv);
 
@@ -658,7 +655,7 @@
 plotcurve(ON_Curve &curve, struct bn_vlblock *vbp, int plotres, const int red = 255, const int green = 255, const int blue = 0)
 {
     register struct bu_list *vhead;
-    fastf_t pt1[3], pt2[3];
+    double pt1[3], pt2[3];
     ON_2dPoint from, to;
 
     vhead = rt_vlblock_find(vbp, red, green, blue);
@@ -673,7 +670,7 @@
 	*/
 
 	int knotcnt = curve.SpanCount();
-	fastf_t *knots = new fastf_t[knotcnt + 1];
+	double *knots = new double[knotcnt + 1];
 
 	curve.GetSpanVector(knots);
 	for (int i = 1; i <= knotcnt; i++) {
@@ -855,8 +852,8 @@
 	    int knotlength1 = nsrf->m_order[1] + nsrf->m_cv_count[1] - 2;
 	    int order0 = nsrf->m_order[0];
 	    int order1 = nsrf->m_order[1];
-	    fastf_t *knot0 = nsrf->m_knot[0];
-	    fastf_t *knot1 = nsrf->m_knot[1];
+	    double *knot0 = nsrf->m_knot[0];
+	    double *knot1 = nsrf->m_knot[1];
 	    int cnt = 0;
 	    bu_vls_printf(vls, "bezier patches:\n");
 	    for (int i = 0; i < knotlength0; ++i) {
@@ -1145,7 +1142,7 @@
 	c2->GetNurbForm(*nc2, 0.0);
 	int knotlength = nc2->m_order + nc2->m_cv_count - 2;
 	int order = nc2->m_order;
-	fastf_t *knot = nc2->m_knot;
+	double *knot = nc2->m_knot;
 	dump.Print("trim[%2d]: domain(%g, %g)\n", ti, nc2->Domain()[0], nc2->Domain()[1]);
 	int cnt = 0;
 	dump.Print("NURBS converts to Bezier\n");
@@ -1441,7 +1438,7 @@
 		ucount = ns->m_cv_count[0];
 		vcount = ns->m_cv_count[1];
 		ON_3dPoint cp;
-		fastf_t pt1[3], pt2[3];
+		double pt1[3], pt2[3];
 		register struct bu_list *vhead;
 		surf->Dump(tl);
 		vhead = rt_vlblock_find(vbp, PEACH);
@@ -1478,7 +1475,7 @@
 	    ucount = ns->m_cv_count[0];
 	    vcount = ns->m_cv_count[1];
 	    ON_3dPoint cp;
-	    fastf_t pt1[3], pt2[3];
+	    double pt1[3], pt2[3];
 	    register struct bu_list *vhead;
 	    vhead = rt_vlblock_find(vbp, PEACH);
 	    for (int i = 0; i < ucount; ++i) {
@@ -1521,10 +1518,10 @@
 plotFace(SurfaceTree* st, struct bn_vlblock *vbp, int UNUSED(isocurveres), int gridres)
 {
     register struct bu_list *vhead;
-    fastf_t pt1[3], pt2[3];
+    double pt1[3], pt2[3];
     ON_2dPoint from, to;
     std::list<BRNode*> m_trims_above_or_right;
-    std::list<fastf_t> trim_hits;
+    std::list<double> trim_hits;
 
     vhead = rt_vlblock_find(vbp, PEACH);
 
@@ -1568,9 +1565,9 @@
 	if ((hit_cnt > 1) && ((hit_cnt % 2) == 0)) {
 	    //bu_log("U - %f\n", pt.x);
 	    while (!trim_hits.empty()) {
-		fastf_t tfrom = trim_hits.front();
+		double tfrom = trim_hits.front();
 		trim_hits.pop_front();
-		fastf_t tto = trim_hits.front();
+		double tto = trim_hits.front();
 		trim_hits.pop_front();
 		//bu_log("\tfrom - %f, to - %f\n", tfrom, tto);
 		fastf_t deltay = (tto-tfrom)/50.0;
@@ -1623,9 +1620,9 @@
 	if ((hit_cnt > 1) && ((hit_cnt % 2) == 0)) {
 	    //bu_log("V - %f\n", pt.y);
 	    while (!trim_hits.empty()) {
-		fastf_t tfrom = trim_hits.front();
+		double tfrom = trim_hits.front();
 		trim_hits.pop_front();
-		fastf_t tto = trim_hits.front();
+		double tto = trim_hits.front();
 		trim_hits.pop_front();
 		//bu_log("\tfrom - %f, to - %f\n", tfrom, tto);
 		fastf_t deltax = (tto-tfrom)/50.0;
@@ -1655,15 +1652,15 @@
 drawisoUCheckForTrim(SurfaceTree* st, struct bn_vlblock *vbp, fastf_t from, fastf_t to, fastf_t v, int UNUSED(curveres))
 {
     register struct bu_list *vhead;
-    fastf_t pt1[3], pt2[3];
+    double pt1[3], pt2[3];
     std::list<BRNode*> m_trims_right;
-    std::list<fastf_t> trim_hits;
+    std::list<double> trim_hits;
 
     vhead = rt_vlblock_find(vbp, YELLOW);
 
     const ON_Surface *surf = st->getSurface();
     CurveTree *ctree = st->ctree;
-    fastf_t umin, umax;
+    double umin, umax;
     surf->GetDomain(0, &umin, &umax);
 
     m_trims_right.clear();
@@ -1706,7 +1703,7 @@
   if ((hit_cnt % 2) != 0) {
   //bu_log("V - %f\n", pt.y);
   if (!trim_hits.empty()) {
-  fastf_t end = trim_hits.front();
+  double end = trim_hits.front();
   trim_hits.pop_front();
   //bu_log("\tfrom - %f, to - %f\n", from, to);
   fastf_t deltax = (end - from) / 50.0;
@@ -1741,12 +1738,12 @@
   }
 */
 	while (!trim_hits.empty()) {
-	    fastf_t start = trim_hits.front();
+	    double start = trim_hits.front();
 	    if (start < from) {
 		start = from;
 	    }
 	    trim_hits.pop_front();
-	    fastf_t end = trim_hits.front();
+	    double end = trim_hits.front();
 	    if (end > to) {
 		end = to;
 	    }
@@ -1783,15 +1780,15 @@
 drawisoVCheckForTrim(SurfaceTree* st, struct bn_vlblock *vbp, fastf_t from, fastf_t to, fastf_t u, int UNUSED(curveres))
 {
     register struct bu_list *vhead;
-    fastf_t pt1[3], pt2[3];
+    double pt1[3], pt2[3];
     std::list<BRNode*> m_trims_above;
-    std::list<fastf_t> trim_hits;
+    std::list<double> trim_hits;
 
     vhead = rt_vlblock_find(vbp, YELLOW);
 
     const ON_Surface *surf = st->getSurface();
     CurveTree *ctree = st->ctree;
-    fastf_t vmin, vmax;
+    double vmin, vmax;
     surf->GetDomain(1, &vmin, &vmax);
 
     m_trims_above.clear();
@@ -1835,7 +1832,7 @@
   if ((hit_cnt % 2) != 0) { //odd starting inside
   //bu_log("V - %f\n", pt.y);
   if (!trim_hits.empty()) {
-  fastf_t end = trim_hits.front();
+  double end = trim_hits.front();
   trim_hits.pop_front();
   //bu_log("\tfrom - %f, to - %f\n", from, to);
   fastf_t deltay = (end - from) / 50.0;
@@ -1871,12 +1868,12 @@
   }
 */
 	while (!trim_hits.empty()) {
-	    fastf_t start = trim_hits.front();
+	    double start = trim_hits.front();
 	    trim_hits.pop_front();
 	    if (start < from) {
 		start = from;
 	    }
-	    fastf_t end = trim_hits.front();
+	    double end = trim_hits.front();
 	    trim_hits.pop_front();
 	    if (end > to) {
 		end = to;
@@ -1911,7 +1908,7 @@
 drawisoU(SurfaceTree* st, struct bn_vlblock *vbp, fastf_t from, fastf_t to, fastf_t v, int curveres)
 {
     register struct bu_list *vhead;
-    fastf_t pt1[3], pt2[3];
+    double pt1[3], pt2[3];
     fastf_t deltau = (to - from) / curveres;
     const ON_Surface *surf = st->getSurface();
 
@@ -1937,7 +1934,7 @@
 drawisoV(SurfaceTree* st, struct bn_vlblock *vbp, fastf_t from, fastf_t to, fastf_t u, int curveres)
 {
     register struct bu_list *vhead;
-    fastf_t pt1[3], pt2[3];
+    double pt1[3], pt2[3];
     fastf_t deltav = (to - from) / curveres;
     const ON_Surface *surf = st->getSurface();
 
Index: src/librt/primitives/brep/brep.cpp
===================================================================
--- src/librt/primitives/brep/brep.cpp	(revision 53222)
+++ src/librt/primitives/brep/brep.cpp	(working copy)
@@ -49,6 +49,7 @@
 
 #include "brep_debug.h"
 
+#include "nurbs.h"
 
 #define BN_VMATH_PREFIX_INDICES 1
 #define ROOT_TOL 1.E-7
@@ -348,16 +349,12 @@
 int
 rt_brep_bbox(struct rt_db_internal *ip, point_t *min, point_t *max) {
     struct rt_brep_internal* bi;
-    ON_3dPoint dmin, dmax;
 
     RT_CK_DB_INTERNAL(ip);
     bi = (struct rt_brep_internal*)ip->idb_ptr;
     RT_BREP_CK_MAGIC(bi);
 
-    bi->brep->GetBBox(dmin, dmax);
-    VMOVE(*min, dmin);
-    VMOVE(*max, dmax);
-
+    bi->brep->GetBBox(*min, *max);
     return 0;
 }
 
@@ -650,25 +647,17 @@
 int
 utah_newton_solver_test(const BBNode* sbv, const ON_Surface* surf, const ON_Ray& r, ON_2dPoint* ouv, double* t, ON_3dVector* N, bool& converged, ON_2dPoint* suv, const int count, const int iu, const int iv)
 {
-    int i = 0;
+    int i;
     int intersects = 0;
-    double j11 = 0.0;
-    double j12 = 0.0;
-    double j21 = 0.0;
-    double j22 = 0.0;
-    double f = 0.0;
-    double g = 0.0;
-    double rootdist = 0.0;
-    double oldrootdist = 0.0;
-    double J = 0.0;
-    double invdetJ = 0.0;
-    double du = 0.0;
-    double dv = 0.0;
-    double cdu = 0.0;
-    double cdv = 0.0;
+    double j11, j12, j21, j22;
+    double f, g;
+    double rootdist, oldrootdist;
+    double J, invdetJ;
+    double du, dv;
+    double cdu, cdv;
 
     ON_3dVector p1, p2;
-    double p1d = 0.0, p2d = 0.0;
+    double p1d = 0, p2d = 0;
     int errantcount = 0;
     utah_ray_planes(r, p1, p1d, p2, p2d);
 
@@ -1058,25 +1047,22 @@
 
     if (converged) {
 	for (int i = 0; i < numhits; i++) {
-	    double closesttrim;
+	    fastf_t closesttrim;
 	    BRNode* trimBR = NULL;
-	    int trim_status = sbv->isTrimmed(ouv[i], &trimBR, closesttrim);
+	    int trim_status = ((BBNode*) sbv)->isTrimmed(ouv[i], &trimBR, closesttrim);
 	    if (trim_status != 1) {
 		ON_3dPoint _pt;
 		ON_3dVector _norm(N[i]);
-		vect_t vpt;
-		vect_t vnorm;
 		_pt = ray.m_origin + (ray.m_dir * t[i]);
-		VMOVE(vpt, _pt);
 		if (face->m_bRev) {
 		    //bu_log("Reversing normal for Face:%d\n", face->m_face_index);
 		    _norm.Reverse();
 		}
-		VMOVE(vnorm, _norm);
 		hit_count += 1;
 		uv[0] = ouv[i].x;
 		uv[1] = ouv[i].y;
-		brep_hit bh(*face, t[i], ray, vpt, vnorm, uv);
+		brep_hit bh(*face, t[i], ray, (const fastf_t*) _pt,
+			    (const fastf_t*) _norm, uv);
 		bh.trimmed = false;
 		if (trimBR != NULL) {
 		    bh.m_adj_face_index = trimBR->m_adj_face_index;
@@ -1090,7 +1076,7 @@
 		    bh.closeToEdge = false;
 		    bh.hit = brep_hit::CLEAN_HIT;
 		}
-		if (VDOT(ray.m_dir, vnorm) < 0.0)
+		if (VDOT(ray.m_dir, _norm) < 0.0)
 		    bh.direction = brep_hit::ENTERING;
 		else
 		    bh.direction = brep_hit::LEAVING;
@@ -1100,19 +1086,16 @@
 	    } else if (fabs(closesttrim) < BREP_EDGE_MISS_TOLERANCE) {
 		ON_3dPoint _pt;
 		ON_3dVector _norm(N[i]);
-		vect_t vpt;
-		vect_t vnorm;
 		_pt = ray.m_origin + (ray.m_dir * t[i]);
-		VMOVE(vpt, _pt);
 		if (face->m_bRev) {
 		    //bu_log("Reversing normal for Face:%d\n", face->m_face_index);
 		    _norm.Reverse();
 		}
-		VMOVE(vnorm, _norm);
 		hit_count += 1;
 		uv[0] = ouv[i].x;
 		uv[1] = ouv[i].y;
-		brep_hit bh(*face, t[i], ray, vpt, vnorm, uv);
+		brep_hit bh(*face, t[i], ray, (const fastf_t*) _pt,
+			    (const fastf_t*) _norm, uv);
 		bh.trimmed = true;
 		bh.closeToEdge = true;
 		if (trimBR != NULL) {
@@ -1121,7 +1104,7 @@
 		    bh.m_adj_face_index = -99;
 		}
 		bh.hit = brep_hit::NEAR_MISS;
-		if (VDOT(ray.m_dir, vnorm) < 0.0)
+		if (VDOT(ray.m_dir, _norm) < 0.0)
 		    bh.direction = brep_hit::ENTERING;
 		else
 		    bh.direction = brep_hit::LEAVING;
@@ -1145,13 +1128,13 @@
     ON_2dPoint ouv(uv[0], uv[1]);
     int found = BREP_INTERSECT_ROOT_DIVERGED;
     bool converged = false;
-    double closesttrim;
+    fastf_t closesttrim;
 
     utah_newton_solver(surf, ray, ouv, t, N, converged);
     /*
      * DDR.  The utah people are using this t_min which represents the
      * last point hit along the ray to ensure we are looking at points
-     * further down the ray.  I haven't implemented this I'm not sure
+     * futher down the ray.  I haven't implemented this I'm not sure
      * we need it
      *
      * if (converged && (t > 1.e-2) && (t < t_min) && (!utah_isTrimmed(ouv, face))) hit = true;
@@ -1191,14 +1174,10 @@
     if (hit) {
 	ON_3dPoint _pt;
 	ON_3dVector _norm(N);
-	vect_t vpt;
-	vect_t vnorm;
 	_pt = ray.m_origin + (ray.m_dir*t);
-	VMOVE(vpt, _pt);
 	if (face->m_bRev) _norm.Reverse();
-	VMOVE(vnorm, _norm);
 	hit_count += 1;
-	hits.push_back(brep_hit(*face, ray, vpt, vnorm, uv));
+	hits.push_back(brep_hit(*face, ray, (const fastf_t*)_pt, (const fastf_t*)_norm, uv));
 	hits.back().sbv = sbv;
 	found = BREP_INTERSECT_FOUND;
     }
@@ -1220,7 +1199,7 @@
     ON_3dVector su;
     ON_3dVector sv;
     plane_ray pr;
-    double closesttrim;
+    fastf_t closesttrim;
 
     brep_get_plane_ray(ray, pr);
 
@@ -1248,13 +1227,9 @@
     if ((found > 0) &&  (trim_status != 1)) {
 	ON_3dPoint _pt;
 	ON_3dVector _norm;
-	vect_t vpt;
-	vect_t vnorm;
 	surf->EvNormal(uv[0], uv[1], _pt, _norm);
-	VMOVE(vpt, _pt);
 	if (face->m_bRev) _norm.Reverse();
-	VMOVE(vnorm, _norm);
-	hits.push_back(brep_hit(*face, ray, vpt, vnorm, uv));
+	hits.push_back(brep_hit(*face, ray, (const fastf_t*)_pt, (const fastf_t*)_norm, uv));
 	hits.back().sbv = sbv;
 
 	if (!sbv->m_u.Includes(uv[0]) || !sbv->m_v.Includes(uv[1])) {
@@ -3219,10 +3194,10 @@
 		IntersectPoint tmp_pt;
 		tmp_pt.m_pt = intersect_pt[k];
 		tmp_pt.m_seg = CVCount_sum + CV[k].first;
-		tmp_pt.m_t = (int)parameter[k].first;
+		tmp_pt.m_t = parameter[k].first;
 		tmp_pt.m_type = j;
 		tmp_pt.m_seg_for_rank = CV[k].second;
-		tmp_pt.m_t_for_rank = (int)parameter[k].second;
+		tmp_pt.m_t_for_rank = parameter[k].second;
 		intersect.Append(tmp_pt);
 	    }
 	    if (intersect_pt.Count())
@@ -3464,7 +3439,7 @@
 	    delete curve_pt;
 	} else if (loop[k]->CVCount() == 2) {
 	    // A closed curve with two control points
-	    // TODO: Sometimes we need a singular trim.
+	    // TODO: Sometimes we need a sigular trim.
 	    ON_3dPointArray ptarray(101);
 	    for (int l = 0; l <= 100; l++) {
 		ON_3dPoint pt2d;
Index: src/librt/primitives/sph/sph.c
===================================================================
--- src/librt/primitives/sph/sph.c	(revision 53222)
+++ src/librt/primitives/sph/sph.c	(working copy)
@@ -218,7 +218,7 @@
 	(struct sph_specific *)stp->st_specific;
     register struct seg *segp;
 
-    vect_t ov;		/* ray origin to center (V - P) */
+    vect_t ov;		/* ray orgin to center (V - P) */
     fastf_t magsq_ov;	/* length squared of ov */
     fastf_t b;		/* second term of quadratic eqn */
     fastf_t root;		/* root of radical */
@@ -273,7 +273,7 @@
     register struct sph_specific *sph;
     register int i;
 
-    vect_t ov;		/* ray origin to center (V - P) */
+    vect_t ov;		/* ray orgin to center (V - P) */
     fastf_t magsq_ov;	/* length squared of ov */
     fastf_t b;		/* second term of quadratic eqn */
     fastf_t root;		/* root of radical */
Index: src/librt/primitives/cline/cline.c
===================================================================
--- src/librt/primitives/cline/cline.c	(revision 53222)
+++ src/librt/primitives/cline/cline.c	(working copy)
@@ -245,7 +245,7 @@
 	    dist[1] = dist[2];
 	}
 
-	/* volume mode */
+	/* vloume mode */
 
 	RT_GET_SEG(segp, ap->a_resource);
 	segp->seg_stp = stp;
Index: src/librt/primitives/superell/superell_brep.cpp
===================================================================
--- src/librt/primitives/superell/superell_brep.cpp	(revision 53222)
+++ src/librt/primitives/superell/superell_brep.cpp	(working copy)
@@ -86,7 +86,7 @@
     // When both e and n <= 2, this can generate an ideal b-rep for superell, otherwise cannot.
     if (sip->e <= 2 && sip->n <= 2) {
 	for (int i = 0; i < surf->CVCount(0); i++) {
-	    fastf_t tmp_weight = 0.0;
+	    fastf_t tmp_weight;
 	    switch (i) {
 	    case 0:
 	    case 4:
@@ -105,7 +105,7 @@
 		bu_log("Should not reach here!\n");
 	    }
 	    for (int j = 0; j < surf->CVCount(1); j++) {
-		fastf_t new_weight = 0.0;
+		fastf_t new_weight;
 		switch (j) {
 		case 0:
 		case 2:
Index: src/librt/primitives/superell/superell.c
===================================================================
--- src/librt/primitives/superell/superell.c	(revision 53222)
+++ src/librt/primitives/superell/superell.c	(working copy)
@@ -23,8 +23,8 @@
  *
  * Intersect a ray with a Superquadratic Ellipsoid.
  *
- * NOTICE: this primitive is incomplete and should be considered
- * experimental.  This primitive will exhibit several
+ * NOTICE: this primitive is incomplete and should beconsidered
+ * experimental.  this primitive will exhibit several
  * instabilities in the existing root solver method.
  *
  */
@@ -120,7 +120,7 @@
  * NORMALS.  Given the point W on the superellipsoid, what is the
  * vector normal to the tangent plane at that point?
  *
- * Map W onto the unit sphere, i.e.:  W' = S(R(W - V)).
+ * Map W onto the unit sphere, ie:  W' = S(R(W - V)).
  *
  * Plane on unit sphere at W' has a normal vector of the same value(!).
  * N' = W'
@@ -164,7 +164,7 @@
     double superell_invmsBu; /* 1.0 / |Bu|^2 */
     double superell_invmsCu; /* 1.0 / |Cu|^2 */
     vect_t superell_invsq;
-    mat_t superell_SoR; /* matrix for local coordinate system, Scale(Rotate(V))*/
+    mat_t superell_SoR; /* matrix for local cordinate system, Scale(Rotate(V))*/
     mat_t superell_invRSSR; /* invR(Scale(Scale(Rot(V)))) */
     mat_t superell_invR; /* transposed rotation matrix */
 };
@@ -434,7 +434,7 @@
     MAT4X3VEC(newShotDir, superell->superell_SoR, rp->r_dir);
     VUNITIZE(newShotDir);
 
-    /* normalize distance from the superell.  substitutes a corrected ray
+    /* normalize distance from the superell.  substitues a corrected ray
      * point, which contains a translation along the ray direction to the
      * closest approach to vertex of the superell.  Translating the ray
      * along the direction of the ray to the closest point near the
Index: src/librt/primitives/arb8/arb8.c
===================================================================
--- src/librt/primitives/arb8/arb8.c	(revision 53222)
+++ src/librt/primitives/arb8/arb8.c	(working copy)
@@ -316,7 +316,7 @@
  * R T _ A R B _ C E N T R O I D
  *
  * Find the center point for the arb whose values are in the s array,
- * with the given number of vertices.  Return the point in center_pt.
+ * with the given number of verticies.  Return the point in center_pt.
  */
 void
 rt_arb_centroid(point_t center_pt, const struct rt_arb_internal *arb, int npoints)
@@ -389,7 +389,7 @@
 	    /* Pts are given clockwise, so reverse terms of cross prod. */
 	    /* peqn = (C-A)x(B-A), which points inwards */
 	    VCROSS(afp->peqn, P_A, ofp->arb_U);
-	    /* Check for co-linear, i.e., |(B-A)x(C-A)| ~= 0 */
+	    /* Check for co-linear, ie, |(B-A)x(C-A)| ~= 0 */
 	    f = MAGNITUDE(afp->peqn);
 	    if (NEAR_ZERO(f, RT_SLOPPY_DOT_TOL)) {
 		return -1;			/* BAD */
@@ -428,7 +428,7 @@
 	     * points inwards, so we need to fix it here.
 	     * Build a vector from the centroid to vertex A.
 	     * If the surface normal points in the same direction,
-	     * then the vertices were given in CCW order;
+	     * then the vertcies were given in CCW order;
 	     * otherwise, vertices were given in CW order, and
 	     * the normal needs to be flipped.
 	     */
@@ -889,7 +889,7 @@
 
     if (ap) RT_CK_APPLICATION(ap);
 
-    /* Initialize return values */
+    /* Intialize return values */
     for (i = 0; i < n; i++) {
 	segp[i].seg_stp = stp[i];	/* Assume hit, if 0 then miss */
 	segp[i].seg_in.hit_dist = -INFINITY;    /* used as in */
@@ -1042,7 +1042,7 @@
 	rt_db_free_internal(&intern);
 
 	if (ret != 0 || arbp->arb_opt == (struct oface *)0) {
-	    bu_log("rt_arb_uv(%s) dynamic setup failure st_specific=x%x, optp=x%x\n",
+	    bu_log("rt_arb_uv(%s) dyanmic setup failure st_specific=x%x, optp=x%x\n",
 		   stp->st_name,
 		   stp->st_specific, arbp->arb_opt);
 	    return;
@@ -1330,7 +1330,7 @@
     char buf[256] = {0};
     int i = 0;
     int arb_type = -1;
-    struct bn_tol tmp_tol;	/* temporary tolerance */
+    struct bn_tol tmp_tol;	/* temporay tolerance */
 
     if (!str || !ip) return 0;
     RT_CK_DB_INTERNAL(ip);
Index: src/librt/primitives/bspline/nurb_trim_util.c
===================================================================
--- src/librt/primitives/bspline/nurb_trim_util.c	(revision 53222)
+++ src/librt/primitives/bspline/nurb_trim_util.c	(working copy)
@@ -37,11 +37,11 @@
 #include "nurb.h"
 
 /**
- * Check to see if the curve control polygon wanders outside the
- * parametric range given.  This is useful if a trimming curve
+ * Check to see if the curve conmtrol polygon wonders outside the
+ * parametric range given.  This is usefull if a trimming curve
  * control polygon is outside but the evaluated curve is not. We will
- * want to refine the curve so that it lies within the range;
- * otherwise it breaks the surface evaluation.
+ * want to refine the curve so that is lies within the range;
+ * otherwise it breaks the surface evaluation
  */
 int
 rt_nurb_crv_in_range(struct edge_g_cnurb *crv, fastf_t u_min, fastf_t u_max, fastf_t v_min, fastf_t v_max)
Index: src/librt/primitives/bspline/nurb_trim.c
===================================================================
--- src/librt/primitives/bspline/nurb_trim.c	(revision 53222)
+++ src/librt/primitives/bspline/nurb_trim.c	(working copy)
@@ -74,7 +74,7 @@
  * It then uses a table look up to determine the whether its CASE{A,
  * B, C}, One difference from the paper is the fact that if any of the
  * points lie on the axis of the u, v quadrant system then the axis is
- * only in either Quadrant 1 or Quadrant 2 and not q3 or q4. This
+ * only in either Quadrant 1 or Quadrant 2 and not q3 or q4. THis
  * handles the case of endpoint problems correctly.
  */
 int
@@ -228,15 +228,15 @@
 /**
  * Process Case C curves;
  *
- * A check is placed here to determine if the u, v is on the curve.
+ * A check is placed here to determin if the u, v is on the curve.
  * Determine how many times the curve will cross the u, v axis. If the
  * curve crosses an odd number of times than the point is IN, else the
- * point is OUT. Since a Case C curve need processing a call to clip
- * the curve so that it becomes either Case B or Case A is required
- * to determine the number of crossings accurately. Thus we need to keep
+ * point is OUT. Since a case C curve need processin a call to clip
+ * hte curve so that it becomes either Case B, or Case A is required
+ * to determine the number of crossing acurately. Thus we need to keep
  * the original curve and expect the calling routine to free the
  * storage. Additional curves are generated in this routine, each of
- * these new curves are processed, and then are deleted before exiting
+ * these new curves are proccesed, and then are deleted before exiting
  * this procedure.
  */
 int
@@ -249,7 +249,7 @@
     int trim_flag = 0;
     int caset;
 
-    /* determine if the u, v values are on the curve */
+    /* determine if the the u, v values are on the curve */
 
     if (rt_nurb_uv_dist(trim, u, v)  == TRIM_ON) return TRIM_IN;
 
@@ -297,10 +297,10 @@
 
 /**
  * This routine will be called several times, once for each portion of
- * the trimming curve. It returns whether a line extended from the
+ * the trimming curve. It returns wheter a line extended from the the
  * <u, v> point will cross the trimming curve an even or odd number of
  * times. Or the <u, v> point could be on the curve in which case
- * TRIM_ON will be returned. The algorithm uses the approach taken Tom
+ * TRIM_ON will be returned. THe algorithm uses the approach taken Tom
  * Sederburge and uses bezier clipping to produce caseA and caseB
  * curves. If the original trimming curve is a CASE C curve then
  * further processing is required.
@@ -369,15 +369,15 @@
 
 
 /**
- * We try to clip a curve so that it can be either Case A or Case C.
- * Sometimes one of the curves is still Case C though, but it is much
- * smaller than the original, and further clipping will either show that
+ * We try and clip a curve so that it can be either Case A, or Case C.
+ * Sometimes one of the curves is still case C though, but it is much
+ * small than the original, and further clipping will either show that
  * it is on the curve or provide all Case B or Case A curves.  We try
- * to pick the best axis to clip against, but this may not always
+ * and pick the best axis to clip against, but this may not always
  * work. One extra step that was included, that is not in the paper
  * for curves but is for surfaces, is the fact that sometimes the
  * curve is not clipped enough, if the maximum clip is less than .2
- * then we subdivide the curve in three equal parts, at .3 and .6 .
+ * than we sub divide the curve in three equal parts, at .3 and .6,
  * Subdivision is done using the Oslo Algorithm, rather than the other
  * methods which were prossed.
  */
@@ -466,7 +466,7 @@
     if (!zero_changed)
 	return;
 
-    /* Clip is not large enough, split in thirds and try again */
+    /* Clip is not large enough, split in thiords and try again */
 
     if (umax - umin < .2) {
 	umin = .3; umax = .6;
Index: src/librt/primitives/bspline/nurb_norm.c
===================================================================
--- src/librt/primitives/bspline/nurb_norm.c	(revision 53222)
+++ src/librt/primitives/bspline/nurb_norm.c	(working copy)
@@ -21,7 +21,7 @@
 /** @{ */
 /** @file primitives/bspline/nurb_norm.c
  *
- * Calculate and return the normal of a surface given the U, V
+ * Calulate and return the normal of a surface given the U, V
  * parametric values.
  *
  */
Index: src/librt/primitives/bspline/nurb_tess.c
===================================================================
--- src/librt/primitives/bspline/nurb_tess.c	(revision 53222)
+++ src/librt/primitives/bspline/nurb_tess.c	(working copy)
@@ -41,11 +41,11 @@
 /**
  * Algorithm -
  *
- * See paper in Computer Aided Design (CAD) Volume 27, Number 1,
- * January 1995 TESSELATING TRIMMED NURBS SURFACES, Leslie A Piegl
+ * See paper in Computer Aided Design (CAD) Volumne 27, Number 1,
+ * January 1995 TESSELATING TRIMMMED NURBS SURFACES, Leslie A Piegl
  * and Arnaud Richard.
  *
- * There is a slight deviation from the paper; since libnurb
+ * There is a slight deviation from the paper, Since libnurb
  * (rt_nurb_s_diff) differentiation correctly handles rational
  * surfaces, no special processing for rational is needed.
  *
Index: src/librt/primitives/bspline/nurb_plot.c
===================================================================
--- src/librt/primitives/bspline/nurb_plot.c	(revision 53222)
+++ src/librt/primitives/bspline/nurb_plot.c	(working copy)
@@ -21,7 +21,7 @@
 /** @{ */
 /** @file primitives/bspline/nurb_plot.c
  *
- * Utilities for spline debugging.
+ * Utilities for spline debuging.
  *
  */
 /** @} */
Index: src/librt/primitives/bspline/nurb_poly.c
===================================================================
--- src/librt/primitives/bspline/nurb_poly.c	(revision 53222)
+++ src/librt/primitives/bspline/nurb_poly.c	(working copy)
@@ -22,7 +22,7 @@
 /** @file primitives/bspline/nurb_poly.c
  *
  * Returns two polygons from a NURB surface.
- * Assumes that the surface is flat.
+ * Asumes that the surface is flat.
  *
  */
 /** @} */
Index: src/librt/primitives/bspline/nurb_eval.c
===================================================================
--- src/librt/primitives/bspline/nurb_eval.c	(revision 53222)
+++ src/librt/primitives/bspline/nurb_eval.c	(working copy)
@@ -43,7 +43,7 @@
  * Algorithm -
  *
  * The algorithm uses the traditional COX-deBoor approach found in the
- * book "Practical Guide to Splines" Carl de Boor, pg 147 to evaluate a
+ * book "Pratical Guide to Splines" Carl de Boor, pg 147 to evaluate a
  * parametric value on a curve. This is expanded to the surface.
  */
 void
Index: src/librt/primitives/bspline/nurb_solve.c
===================================================================
--- src/librt/primitives/bspline/nurb_solve.c	(revision 53222)
+++ src/librt/primitives/bspline/nurb_solve.c	(working copy)
@@ -24,7 +24,7 @@
  * Decompose a matrix into its LU decomposition using pivoting.
  *
  * These Procedures take a set of matrices of the form Ax = b and
- * allows one to solve the system by various means. The
+ * alows one to solve the system by various means. The
  * rt_nurb_doolittle routine takes the system and creates a lu
  * decomposition using pivoting to get the system in a desired
  * form. Forward and backward substitution are then used to solve the
@@ -61,7 +61,7 @@
 
 
     /* dimension of the matrix */
-    /* Number of coordinates for mat_2 and solution */
+    /* Number of coordsinates for mat_2 and solution */
 {
     register int i, k;
     fastf_t *y;
@@ -77,7 +77,7 @@
     s = (fastf_t *) bu_malloc(sizeof (fastf_t) * dim,
 			      "rt_nurb_solve: s");/* Create temp array */
 
-    rt_nurb_doolittle (mat_1, mat_2, dim, coords);/* Create LU decomposition */
+    rt_nurb_doolittle (mat_1, mat_2, dim, coords);/* Create LU decomosition */
 
     for (k =0; k < coords; k++) {
 	fastf_t * ptr;
@@ -110,7 +110,7 @@
 
 
 /**
- * Create LU decomposition.
+ * Create LU decomosition.
  * Modifies both mat_1 and mat_2 values.
  */
 void
@@ -134,7 +134,7 @@
     s = (fastf_t *) bu_malloc(sizeof (fastf_t) * row * row,
 			      "rt_nurb_doolittle:s");	/* vector to check */
     ds = (fastf_t *) bu_malloc(sizeof (fastf_t) * row,
-			       "rt_nurb_doolittle:ds");	/* if rows need to be swapped */
+			       "rt_nurb_doolittle:ds");	/* if rows need to be swaped */
 
     for (i = 0; i < row; i++) {
 	/* calculate the scaling factors */
@@ -158,7 +158,7 @@
 
 	for (i = k; i < row; i ++) {
 	    /* check to see if rows need */
-	    /* to be swapped */
+	    /* to be swaped */
 	    ds[i] = d[i] * s[ i * row + k];
 	    if (ds[max_pivot] < ds[i])
 		max_pivot = i;
@@ -205,7 +205,7 @@
 
 
 void
-rt_nurb_forw_solve(const fastf_t *lu, const fastf_t *b, fastf_t *y, int n)		/* spl_solve lower triangular matrix */
+rt_nurb_forw_solve(const fastf_t *lu, const fastf_t *b, fastf_t *y, int n)		/* spl_solve lower trianglular matrix */
 
 
 {
Index: src/librt/primitives/bspline/nurb_ray.c
===================================================================
--- src/librt/primitives/bspline/nurb_ray.c	(revision 53222)
+++ src/librt/primitives/bspline/nurb_ray.c	(working copy)
@@ -133,7 +133,7 @@
     struct internal_convex_hull ch[20]; /* max order is 10 */
     register fastf_t * mp1;
     fastf_t * p1, *p2, *p3, *p4;	/* corner points of the mesh */
-    fastf_t v1[2], v2[2], v3[2];	/* vectors from corners */
+    fastf_t v1[2], v2[2], v3[2];	/* vectors from corneres */
     struct internal_line l1;
     fastf_t norm;
     fastf_t value;
Index: src/librt/primitives/bspline/bspline_mirror.c
===================================================================
--- src/librt/primitives/bspline/bspline_mirror.c	(revision 53222)
+++ src/librt/primitives/bspline/bspline_mirror.c	(working copy)
@@ -93,7 +93,7 @@
 	int m;
 	int l;
 
-	/* swap knot vectors between u and v */
+	/* swap knot vetcors between u and v */
 	ptr = nurb->srfs[i]->u.knots;
 	tmp = nurb->srfs[i]->u.k_size;
 
@@ -127,7 +127,7 @@
 	}
 
 	/* copy mirrored control points into new mesh
-	 * while swapping u and v */
+	 * while swaping u and v */
 	m = 0;
 	for (j=0; j<orig_size[0]; j++) {
 	    for (l=0; l<orig_size[1]; l++) {
Index: src/librt/primitives/bspline/nurb_interp.c
===================================================================
--- src/librt/primitives/bspline/nurb_interp.c	(revision 53222)
+++ src/librt/primitives/bspline/nurb_interp.c	(working copy)
@@ -21,7 +21,7 @@
 /** @{ */
 /** @file primitives/bspline/nurb_interp.c
  *
- * Interpolation routines for fitting NURB curves and and surfaces to
+ * Interpolatopn routines for fitting NURB curves and and surfaces to
  * existing data.
  *
  */
@@ -102,7 +102,7 @@
     crv->pt_type = RT_NURB_MAKE_PT_TYPE(3, RT_NURB_PT_XYZ, 0);
 
     /* First set up Curve data structs */
-    /* For now we will assume that all parameterizations are uniform */
+    /* For now we will assume that all paramerizations are uniform */
 
     rt_nurb_kvknot(&crv->k, order, 0.0, 1.0, (n - order), (struct resource *)NULL);
 
@@ -175,7 +175,7 @@
     srf->pt_type = RT_NURB_MAKE_PT_TYPE(3, RT_NURB_PT_XYZ, RT_NURB_PT_NONRAT);
 
     /* the U knot vector replates to the points in a row therefore you
-     * want to determine how many cols there are similar for the V knot
+     * want to determin how many cols there are similar for the V knot
      * vector
      */
 
Index: src/librt/primitives/bspline/bspline.cpp
===================================================================
--- src/librt/primitives/bspline/bspline.cpp	(revision 53222)
+++ src/librt/primitives/bspline/bspline.cpp	(working copy)
@@ -62,7 +62,7 @@
 #endif
 
 struct nurb_specific {
-    struct nurb_specific *next;	/* next surface in the solid */
+    struct nurb_specific *next;	/* next surface in the the solid */
     struct face_g_snurb *srf;	/* Original surface description */
     struct bu_list bez_hd;	/* List of Bezier face_g_snurbs */
 };
@@ -626,7 +626,7 @@
 	int coords;
 	fastf_t bound;
 	point_t tmp_pt;
-	fastf_t dtol;
+	fastf_t rel;
 	struct knot_vector tkv1,
 	    tkv2;
 	fastf_t tess;
@@ -639,14 +639,33 @@
 
 	VSUB2(tmp_pt, n->min_pt, n->max_pt);
 	bound =         MAGNITUDE(tmp_pt)/ 2.0;
+	/*
+	 * Establish tolerances
+	 */
+	if (ttol->rel <= 0.0 || ttol->rel >= 1.0) {
+	    rel = 0.0;              /* none */
+	} else {
+	    /* Convert rel to absolute by scaling by diameter */
+	    rel = ttol->rel * 2 * bound;
+	}
+	if (ttol->abs <= 0.0) {
+	    if (rel <= 0.0) {
+		/* No tolerance given, use a default */
+		rel = 2 * 0.10 * bound;        /* 10% */
+	    } else {
+		/* Use absolute-ized relative tolerance */
+	    }
+	} else {
+	    /* Absolute tolerance was given, pick smaller */
+	    if (ttol->rel <= 0.0 || rel > ttol->abs)
+		rel = ttol->abs;
+	}
 
-	dtol = primitive_get_absolute_tolerance(ttol, 2.0 * bound);
-
 	if (n->order[0] < 3 || n->order[1] < 3) {
 	    /* cannot use rt_nurb_par_edge() in this case */
 	    tess = 0.25; /* hack for now */
 	} else
-	    tess = (fastf_t) rt_nurb_par_edge(n, dtol);
+	    tess = (fastf_t) rt_nurb_par_edge(n, rel);
 
 	num_knots = (int)floor(1.0/((M_SQRT1_2 / 2.0) * tess));
 
@@ -934,7 +953,7 @@
 
     /* Figure out how many recs to buffer by
      * walking through the surfaces and
-     * calculating the number of granules
+     * calculating the number of granuels
      * needed for storage and add it to the total
      */
     total_grans = 1;	/* First gran for BSOLID record */
Index: src/librt/primitives/bspline/nurb_bound.c
===================================================================
--- src/librt/primitives/bspline/nurb_bound.c	(revision 53222)
+++ src/librt/primitives/bspline/nurb_bound.c	(working copy)
@@ -50,7 +50,7 @@
 int
 rt_nurb_s_bound(struct face_g_snurb *srf, fastf_t *bmin, fastf_t *bmax)
 {
-    register fastf_t *p_ptr;	/* Mesh pointer */
+    register fastf_t *p_ptr;	/* Mesh pointr */
     register int coords;		/* Elements per vector */
     int i;
     int rat;
@@ -91,7 +91,7 @@
 int
 rt_nurb_c_bound(struct edge_g_cnurb *crv, fastf_t *bmin, fastf_t *bmax)
 {
-    register fastf_t *p_ptr;	/* Mesh pointer */
+    register fastf_t *p_ptr;	/* Mesh pointr */
     register int coords;		/* Elements per vector */
     int i;
     int rat;
@@ -132,13 +132,13 @@
  * rt_nurb_s_check(srf)
  *
  * Checks the NURB surface control points to make sure no one point is
- * near INFINITY, which probably means that the surface mesh is bad.
+ * near INIFITY, which probably means that the surface mesh is bad.
  */
 
 int
 rt_nurb_s_check(register struct face_g_snurb *srf)
 {
-    register fastf_t *mp;	/* Mesh pointer */
+    register fastf_t *mp;	/* Mesh pointr */
     register int i;
 
     mp = srf->ctl_points;
@@ -160,13 +160,13 @@
  * rt_nurb_c_check(srf)
  *
  * Checks the NURB curve control points to make sure no one point is
- * near INFINITY, which probably means that the surface mesh is bad.
+ * near INIFITY, which probably means that the surface mesh is bad.
  */
 
 int
 rt_nurb_c_check(register struct edge_g_cnurb *crv)
 {
-    register fastf_t *mp;	/* Mesh pointer */
+    register fastf_t *mp;	/* Mesh pointr */
     register int i;
 
     mp = crv->ctl_points;
Index: src/librt/primitives/hf/hf.c
===================================================================
--- src/librt/primitives/hf/hf.c	(revision 53222)
+++ src/librt/primitives/hf/hf.c	(working copy)
@@ -328,7 +328,7 @@
      */
 
     /*
-     * Start finding the location of the opposite vertex to V
+     * Start finding the location of the oposite vertex to V
      */
     VJOIN2(hf->hf_VO, hip->v, hip->xlen, hip->x, hip->ylen, hip->y);
 
@@ -653,7 +653,7 @@
     }
     /*
      * This is the two hit situation which can cause interesting
-     * problems.  There are basically five different cases that must be
+     * problems.  Three are basicly five different cases that must be
      * dealt with and each one requires that the ray be classified
      *
      * 1) The ray has hit two different planes at two different
@@ -834,8 +834,8 @@
      */
     for (j=-1; j>-7; j--) {
 	fastf_t dn;	/* Direction dot Normal */
-	fastf_t dxbdn;	/* distance between d and b * dn */
-	fastf_t s;	/* actual distance in mm */
+	fastf_t dxbdn;	/* distence beteen d and b * dn */
+	fastf_t s;	/* actual distence in mm */
 	int allIndex;
 
 	switch (j) {
@@ -957,7 +957,7 @@
     axis_plane_isect(oplane, out, rp, hf, xWidth, yWidth, &hp, &nhits);
 
     /*
-     * Gee, we've gotten much closer, we know that we hit the
+     * Gee, we've gotten much closer, we know that we hit the the
      * solid. Now it's time to see which cell we hit.  The Key here is
      * to use a fast DDA to check ONLY the cells we are interested in.
      * The basic idea and some of the pseudo code comes from:
Index: src/librt/primitives/rec/rec.c
===================================================================
--- src/librt/primitives/rec/rec.c	(revision 53222)
+++ src/librt/primitives/rec/rec.c	(working copy)
@@ -21,7 +21,7 @@
 /** @{ */
 /** @file primitives/rec/rec.c
  *
- * Intersect a ray with a Right Elliptical Cylinder.  This is a special
+ * Intersect a ray with a Right Eliptical Cylinder.  This is a special
  * (but common) case of the TGC, which is handled separately.
  *
  * Algorithm -
@@ -77,7 +77,7 @@
  * c = ((Px'**2 + Py'**2) - r**2) / (Dx'**2 + Dy'**2)
  * r = 1.0
  *
- * The quadratic formula yields k (which is constant):
+ * The qudratic formula yields k (which is constant):
  *
  * k = [ -b +/- sqrt(b**2 - 4 * c ] / 2.0
  *
@@ -100,10 +100,10 @@
  * NORMALS.  Given the point W on the surface of the cylinder, what is
  * the vector normal to the tangent plane at that point?
  *
- * Map W onto the unit cylinder, i.e.:  W' = S(R(W - V)).
+ * Map W onto the unit cylinder, ie:  W' = S(R(W - V)).
  *
  * Plane on unit cylinder at W' has a normal vector N' of the same
- * value as W' in x and y, with z set to zero, i.e., (Wx', Wy', 0)
+ * value as W' in x and y, with z set to zero, ie, (Wx', Wy', 0)
  *
  * The plane transforms back to the tangent plane at W, and this new
  * plane (on the original cylinder) has a normal vector of N, viz:
@@ -459,7 +459,7 @@
     if (ZERO(dprime[X]) && ZERO(dprime[Y]))
 	goto check_plates;
 
-    /* Find roots of the equation, using formula for quadratic w/ a=1 */
+    /* Find roots of the equation, using forumla for quadratic w/ a=1 */
     {
 	fastf_t b;		/* coeff of polynomial */
 	fastf_t root;		/* root of radical */
@@ -627,7 +627,7 @@
 
     if (ap) RT_CK_APPLICATION(ap);
 
-    /* for each ray/right_elliptical_cylinder pair */
+    /* for each ray/right_eliptical_cylinder pair */
     for (i = 0; i < n; i++) {
 	if (stp[i] == 0) continue; /* stp[i] == 0 signals skip ray */
 
@@ -642,7 +642,7 @@
 	if (ZERO(dprime[X]) && ZERO(dprime[Y]))
 	    goto check_plates;
 
-	/* Find roots of eqn, using formula for quadratic w/ a=1 */
+	/* Find roots of eqn, using forumla for quadratic w/ a=1 */
 	b = 2 * (dprime[X]*pprime[X] + dprime[Y]*pprime[Y]) *
 	    (dx2dy2 = 1 / (dprime[X]*dprime[X] + dprime[Y]*dprime[Y]));
 	if ((root = b*b - 4 * dx2dy2 *
Index: src/librt/primitives/tgc/tgc.c
===================================================================
--- src/librt/primitives/tgc/tgc.c	(revision 53222)
+++ src/librt/primitives/tgc/tgc.c	(working copy)
@@ -1282,7 +1282,7 @@
 	    }
 	} else {
 
-	    /* If all conic intersections lie outside the plane, then
+	    /* If all conic interections lie outside the plane, then
 	     * check to see whether there are two planar intersections
 	     * inside the governing ellipses.
 	     *
@@ -1803,69 +1803,7 @@
     ip->idb_ptr = GENPTR_NULL;
 }
 
-struct ellipse {
-    point_t center;
-    vect_t axis_a;
-    vect_t axis_b;
-};
 
-static void
-draw_lines_between_ellipses(struct bu_list *vhead, struct ellipse ellipse1, struct ellipse ellipse2, int num_lines)
-{
-    int i;
-    point_t ellipse1_point, ellipse2_point;
-    fastf_t radian_step = 2.0 * M_PI / num_lines;
-
-    for (i = 0; i < num_lines; ++i) {
-	ellipse_point_at_radian(ellipse1_point, ellipse1.center,
-		ellipse1.axis_a, ellipse1.axis_b, i * radian_step);
-	ellipse_point_at_radian(ellipse2_point, ellipse2.center,
-		ellipse2.axis_a, ellipse2.axis_b, i * radian_step);
-
-	RT_ADD_VLIST(vhead, ellipse1_point, BN_VLIST_LINE_MOVE);
-	RT_ADD_VLIST(vhead, ellipse2_point, BN_VLIST_LINE_DRAW);
-    }
-}
-
-int
-rt_tgc_adaptive_plot(struct rt_db_internal *ip, const struct rt_view_info *info)
-{
-    int samples;
-    struct rt_tgc_internal *tip;
-    struct ellipse ellipse1, ellipse2;
-
-    BU_CK_LIST_HEAD(info->vhead);
-    RT_CK_DB_INTERNAL(ip);
-    tip = (struct rt_tgc_internal *)ip->idb_ptr;
-    RT_TGC_CK_MAGIC(tip);
-
-    samples = sqrt(primitive_diagonal_samples(ip, info));
-    if (samples % 2 != 0) {
-	++samples;
-    }
-    if (samples < 6) {
-	samples = 6;
-    }
-
-    VMOVE(ellipse1.center, tip->v);
-    VMOVE(ellipse1.axis_a, tip->a);
-    VMOVE(ellipse1.axis_b, tip->b);
-    plot_ellipse(info->vhead, ellipse1.center, ellipse1.axis_a, ellipse1.axis_b,
-		 samples);
-
-    VADD2(ellipse2.center, tip->v, tip->h);
-    VMOVE(ellipse2.axis_a, tip->c);
-    VMOVE(ellipse2.axis_b, tip->d);
-    plot_ellipse(info->vhead, ellipse2.center, ellipse2.axis_a, ellipse2.axis_b,
-		 samples);
-
-    samples /= 2;
-
-    draw_lines_between_ellipses(info->vhead, ellipse1, ellipse2, samples);
-
-    return 0;
-}
-
 /**
  * R T _ T G C _ P L O T
  */
@@ -2174,7 +2112,7 @@
     /* and for complete ellipse */
     nsegs *= 4;
 
-    /* get number and placement of intermediate ellipses */
+    /* get nunber and placement of intermediate ellipses */
     {
 	fastf_t ratios[4], max_ratio;
 	fastf_t new_ratio = 0;
@@ -3005,8 +2943,8 @@
 }
 
 
-/* Create a cylinder with a top surface and a bottom surface
- * defined by the ellipsoids at the top and bottom of the
+/* Create a cylinder with a top surface and a bottom surfce
+ * defined by the ellipsods at the top and bottom of the
  * cylinder, the top_mat, and bot_mat are applied to a unit circle
  * for the top row of the surface and the bot row of the surface
  * respectively.
Index: src/librt/primitives/sketch/sketch_tess.cpp
===================================================================
--- src/librt/primitives/sketch/sketch_tess.cpp	(revision 53222)
+++ src/librt/primitives/sketch/sketch_tess.cpp	(working copy)
@@ -90,7 +90,7 @@
 
 
 /* NOTE: MINSTEP and MAXSTEP were determined by experimentation. If MINSTEP is
- * much smaller (i.e. 0.00001), approx_bezier() slows significantly on curves with
+ * much smaller (ie. 0.00001), approx_bezier() slows significantly on curves with
  * high curvature over a large part of its domain. MAXSTEP represents a step
  * size of 1/10th the domain of a Bezier curve, and MINSTEP represents 1/10000th.
  */
@@ -145,8 +145,8 @@
 HIDDEN void
 approx_bezier(const ON_BezierCurve& bezier, const ON_Arc& biarc, const struct bn_tol *tol, std::vector<ON_Arc>& approx)
 {
-    fastf_t t = 0.0, step = 0.0;
-    fastf_t crv = 0.0, err = 0.0, max_t = 0.0, max_err = 0.0;
+    fastf_t t, step;
+    fastf_t crv, err, max_t, max_err = 0.0;
     ON_3dPoint test;
     ON_3dVector d1, d2;
 
Index: src/librt/primitives/sketch/sketch.c
===================================================================
--- src/librt/primitives/sketch/sketch.c	(revision 53222)
+++ src/librt/primitives/sketch/sketch.c	(working copy)
@@ -1163,8 +1163,8 @@
 		nbytes += 8 + (bseg->degree + 1) * 4;
 		break;
 	    default:
-		bu_log("rt_sketch_export4: unsupported segment type (x%x)\n", *lng);
-		bu_bomb("rt_sketch_export4: unsupported segment type\n");
+		bu_log("rt_sketch_export4: unsupported segement type (x%x)\n", *lng);
+		bu_bomb("rt_sketch_export4: unsupported segement type\n");
 	}
     }
 
@@ -1209,7 +1209,7 @@
 	uint32_t *lng;
 	fastf_t tmp_fastf;
 
-	/* write segment type ID, and segment parameters */
+	/* write segment type ID, and segement parameters */
 	lng = (uint32_t *)sketch_ip->curve.segment[seg_no];
 	switch (*lng) {
 	    case CURVE_LSEG_MAGIC:
@@ -1516,8 +1516,8 @@
 		ep->ext_nbytes += (bseg->degree + 1) * SIZEOF_NETWORK_LONG;
 		break;
 	    default:
-		bu_log("rt_sketch_export5: unsupported segment type (x%x)\n", *lng);
-		bu_bomb("rt_sketch_export5: unsupported segment type\n");
+		bu_log("rt_sketch_export5: unsupported segement type (x%x)\n", *lng);
+		bu_bomb("rt_sketch_export5: unsupported segement type\n");
 	}
     }
     ep->ext_buf = (genptr_t)bu_malloc(ep->ext_nbytes, "sketch external");
@@ -1557,7 +1557,7 @@
 	uint32_t *lng;
 	fastf_t tmp_fastf;
 
-	/* write segment type ID, and segment parameters */
+	/* write segment type ID, and segement parameters */
 	lng = (uint32_t *)sketch_ip->curve.segment[seg_no];
 	switch (*lng) {
 	    case CURVE_LSEG_MAGIC:
@@ -2423,7 +2423,7 @@
 
 	    if ((ret=get_tcl_curve(brlcad_interp, crv, tmp)) != TCL_OK)
 		return ret;
-	} else if (*argv[0] == 'V' && isdigit((int)*(argv[0]+1))) {
+	} else if (*argv[0] == 'V' && isdigit(*(argv[0]+1))) {
 	    /* changing a specific vertex */
 	    long vert_no;
 	    fastf_t *new_vert;
Index: src/librt/primitives/sketch/sketch_brep.cpp
===================================================================
--- src/librt/primitives/sketch/sketch_brep.cpp	(revision 53222)
+++ src/librt/primitives/sketch/sketch_brep.cpp	(working copy)
@@ -19,7 +19,7 @@
  */
 /** @file sketch_brep.cpp
  *
- * Convert a sketch to b-rep form (does not create a solid brep)
+ * Convert a sketch to b-rep form (does not creat a solid brep)
  *
  */
 
Index: src/librt/primitives/nmg/nmg_ck.c
===================================================================
--- src/librt/primitives/nmg/nmg_ck.c	(revision 53222)
+++ src/librt/primitives/nmg/nmg_ck.c	(working copy)
@@ -345,7 +345,7 @@
 	    case OT_SAME	: break;
 	    case OT_OPPOSITE: break;
 	    case OT_UNSPEC	: break;
-	    default		: bu_bomb("nmg_veu() unknown loopuse orientation\n");
+	    default		: bu_bomb("nmg_veu() unknown loopuse orintation\n");
 		break;
 	}
 
@@ -431,7 +431,7 @@
 	    case OT_BOOLPLACE:	break;
 	    default:
 		bu_log("lu=x%x, orientation=%d\n", lu, lu->orientation);
-		bu_bomb("nmg_vlu() unknown loopuse orientation\n");
+		bu_bomb("nmg_vlu() unknown loopuse orintation\n");
 		break;
 	}
 	if (lu->lumate_p->orientation != lu->orientation)
@@ -546,7 +546,7 @@
 		bu_bomb("nmg_vfu() faceuse of \"OPPOSITE\" orientation has mate that is not \"SAME\" orientation\n");
 		break;
 	    case OT_UNSPEC	: break;
-	    default		: bu_bomb("nmg_vfu() unknown faceuse orientation\n"); break;
+	    default		: bu_bomb("nmg_vfu() unknown faceuse orintation\n"); break;
 	}
 
 	NMG_CK_FACE(fu->f_p);
@@ -753,7 +753,7 @@
     }
 
     if (*eu->eumate_p->up.magic_p != *eu->up.magic_p) {
-	bu_strlcat(errstr, "nmg_ck_eu() eumate has different kind of parent\n", len);
+	bu_strlcat(errstr, "nmg_ck_eu() eumate has differnt kind of parent\n", len);
 	bu_bomb(errstr);
     }
     if (*eu->up.magic_p == NMG_SHELL_MAGIC) {
@@ -1039,7 +1039,7 @@
 /** N M G _ C K _ E G _ V E R T S
  *
  * Check if vertices from edgeuses using this edge geometry
- * actually lie on the edge geometry.
+ * actually lie on the edge geomatry.
  *
  * "eg" must be LSEG
  * returns number of vertices not on edge line
@@ -1196,7 +1196,7 @@
  * N M G _ C K _ L U E U
  *
  * check all the edgeuses of a loopuse to make sure these children
- * know who their parent really is.
+ * know who thier parent really is.
  */
 void
 nmg_ck_lueu(const struct loopuse *cklu, const char *s)
Index: src/librt/primitives/nmg/nmg_visit.c
===================================================================
--- src/librt/primitives/nmg/nmg_visit.c	(revision 53222)
+++ src/librt/primitives/nmg/nmg_visit.c	(working copy)
@@ -25,7 +25,7 @@
  * visit all the data structures "below" a given structure.
  *
  * The caller provides a pointer to the structure to start at,
- * a table of "handlers" for each kind of structure,
+ * a table of "handlers" for each kind of strucuture,
  * and a generic pointer for private state which will be sent along
  * to the user's handlers.
  * For non-leaf structures, there are two handlers, one called
Index: src/librt/primitives/nmg/nmg_tri.c
===================================================================
--- src/librt/primitives/nmg/nmg_tri.c	(revision 53222)
+++ src/librt/primitives/nmg/nmg_tri.c	(working copy)
@@ -461,7 +461,7 @@
 					"2D coordinate list");
 
     /* we use the 0 index entry in the table as the head of the sorted
-     * list of vertices.  This is safe since the 0 index is always for
+     * list of verticies.  This is safe since the 0 index is always for
      * the model structure
      */
 
@@ -1216,7 +1216,7 @@
 	NMG_CK_VERTEX_G(vu->v_p->vg_p);
 
 	if (vu->v_p != v)
-	    bu_bomb("vertexuse does not acknowledge parents\n");
+	    bu_bomb("vertexuse does not acknoledge parents\n");
 
 	if (nmg_find_fu_of_vu(vu) != fu ||
 	    *vu->up.magic_p == NMG_LOOPUSE_MAGIC) {
@@ -2380,8 +2380,8 @@
 
 	loop_count++;
 	if (loop_count > vert_count_sq) {
-	    bu_log("Cut_unimonotone is in an infinite loop!!!\n");
-	    bu_bomb("Cut_unimonotone is in an infinite loop");
+	    bu_log("Cut_unimontone is in an infinite loop!!!\n");
+	    bu_bomb("Cut_unimontone is in an infinite loop");
 	}
 
 	prev = PT2D_PREV(tbl2d, current);
@@ -2542,10 +2542,6 @@
 
     for (BU_LIST_FOR(lu, loopuse, &fu->lu_hd)) {
 
-	/* skip loops which do not contain edges */
-	if (BU_LIST_FIRST_MAGIC(&lu->down_hd) != NMG_EDGEUSE_MAGIC) {
-	    continue;
-	}
 	non_consec_edgeuse_vert_count = 0;
 	edgeuse_vert_count = 0;
 	prev_v_p = (struct vertex *)NULL;
@@ -2819,7 +2815,7 @@
 	    /* skip testing eu1 and eu2 */
 	    if (eu->vu_p == vu1 || eu->vu_p == vu1b || eu->vu_p == vu2 || eu->vu_p == vu2b) {
 		continue;
-	    }
+	    } 
 
 	    NMG_CK_EDGEUSE(eu);
 
@@ -4730,7 +4726,7 @@
 	for (BU_LIST_FOR(eu, edgeuse, &lu->down_hd))
 	    if (++vert_count > 3) {
 		if (rt_g.NMG_debug & DEBUG_TRI)
-		    bu_log("loop has more than 3 vertices\n");
+		    bu_log("loop has more than 3 verticies\n");
 		goto triangulate;
 	    }
     }
@@ -4806,7 +4802,7 @@
 	sprintf(db_name, "uni%d.g", iter);
 	nmg_stash_model_to_file(db_name,
 				nmg_find_model(&fu->s_p->l.magic),
-				"triangles and unimonotones");
+				"trangles and unimonotones");
     }
 
     for (BU_LIST_FOR(lu, loopuse, &fu->lu_hd))
@@ -4826,7 +4822,7 @@
 	sprintf(db_name, "uni_split%d.g", iter++);
 	nmg_stash_model_to_file(db_name,
 				nmg_find_model(&fu->s_p->l.magic),
-				"split triangles and unimonotones");
+				"split trangles and unimonotones");
     }
 
     /* now we're left with a face that has some triangle loops and some
Index: src/librt/primitives/nmg/nmg_fcut.c
===================================================================
--- src/librt/primitives/nmg/nmg_fcut.c	(revision 53222)
+++ src/librt/primitives/nmg/nmg_fcut.c	(working copy)
@@ -1943,8 +1943,7 @@
     NMG_CK_FACEUSE(fu2);
     if (eg) NMG_CK_EDGE_G_LSEG(eg);
 
-    memset((char *)rs, 0, sizeof(rs));
-
+    memset((char *)rs, 0, sizeof(*rs));
     rs->magic = NMG_RAYSTATE_MAGIC;
     rs->tol = tol;
     rs->vu = (struct vertexuse **)b->buffer;
Index: src/librt/primitives/nmg/nmg_fuse.c
===================================================================
--- src/librt/primitives/nmg/nmg_fuse.c	(revision 53222)
+++ src/librt/primitives/nmg/nmg_fuse.c	(working copy)
@@ -130,7 +130,7 @@
 /**
  * N M G _ R E G I O N _ V _ U N I Q U E
  *
- * Ensure that all the vertices in r1 are still geometrically unique.
+ * Ensure that all the vertices in r1 are still geometricaly unique.
  * This will be true after nmg_region_both_vfuse() has been called,
  * and should remain true throughout the intersection process.
  */
@@ -313,57 +313,30 @@
 /**
  * N M G _ V E R T E X _ F U S E
  *
- * Fuse together any vertices that are geometrically identical, within
- * distance tolerance. This function may be passed a pointer to an NMG
- * object or a pointer to a bu_ptbl structure containing a list of
- * pointers to NMG vertex structures. If a bu_ptbl structure was passed
- * into this function, the calling function must free this structure.
+ * Fuse together any vertices that are geometrically
+ * identical, within the tolerance.
  */
 int
 nmg_vertex_fuse(const uint32_t *magic_p, const struct bn_tol *tol)
 {
-    struct bu_ptbl *t1;
-    struct bu_ptbl tmp;
-    size_t t1_len;
+    struct bu_ptbl t1;
     int total = 0;
-    const uint32_t *tmp_magic_p;
 
     BN_CK_TOL(tol);
 
-    if (!magic_p) {
-	bu_bomb("nmg_vertex_fuse(): passed null pointer");
-    }
+    nmg_vertex_tabulate(&t1, magic_p);
 
-    if (*magic_p == BU_PTBL_MAGIC) {
-	t1 = (struct bu_ptbl *)magic_p;
-	t1_len = BU_PTBL_LEN(t1);
-	if (t1_len) {
-	    tmp_magic_p = (const uint32_t *)BU_PTBL_GET((struct bu_ptbl *)magic_p, 0);
-	    if (*tmp_magic_p != NMG_VERTEX_MAGIC) {
-		bu_bomb("nmg_vertex_fuse(): passed bu_ptbl structure not containing vertex");
-	    }
-	}
-    } else {
-	t1 = &tmp;
-	nmg_vertex_tabulate(t1, magic_p);
-	t1_len = BU_PTBL_LEN(t1);
-    }
-
     /* if there are no vertex, do nothing */
-    if (!t1_len) {
+    if (!BU_PTBL_END(&t1)) {
 	return 0;
     }
 
-    total = nmg_ptbl_vfuse(t1, tol);
+    total = nmg_ptbl_vfuse(&t1, tol);
 
-    /* if bu_ptbl was passed into this function don't free it here */
-    if (*magic_p != BU_PTBL_MAGIC) {
-	bu_ptbl_free(t1);
-    }
+    bu_ptbl_free(&t1);
 
     if (rt_g.NMG_debug & DEBUG_BASIC && total > 0)
 	bu_log("nmg_vertex_fuse() %d\n", total);
-
     return total;
 }
 
@@ -514,7 +487,7 @@
 	/* get average vertex coordinates */
 	VSCALE(vsum, vsum, one_over_vertex_count);
 
-	/* get distance from plane to origin */
+	/* get distance from plane to orgin */
 	pl[H] = VDOT(pl, vsum);
 
     } else {
@@ -549,7 +522,7 @@
 	    /* get average vertex coordinates */
 	    VSCALE(vsum, vsum, one_over_vertex_count);
 
-	    /* get distance from plane to origin */
+	    /* get distance from plane to orgin */
 	    pl[H] = VDOT(pl, vsum);
 
 	} else {
@@ -665,7 +638,7 @@
     if (pt_new->t < pt0->t || pt_new->t > pt1->t) {
 	bu_log("nmg_split_trim: split parameter (%g) is not between ends (%g and %g)\n",
 	       t, pt0->t, pt1->t);
-	bu_bomb("nmg_split_trim: split parameters not between ends\n");
+	bu_bomb("nmg_split_trim: split parameteris not between ends\n");
     }
 
     nmg_eval_trim_curve(cnrb, snrb, pt_new->t, pt_new->xyz);
@@ -1242,7 +1215,7 @@
     size_t *sort_idx_xyp;
 
     /* arrays containing special case flags for each edge in the xy, xz and yz planes */
-    /* 0 = no special case, 1 = infinite ratio, 2 = zero ratio, 3 = point in plane (no ratio) */
+    /* 0 = no special case, 1 = infinit ratio, 2 = zero ratio, 3 = point in plane (no ratio) */
     char *edge_sc, *edge_sc_xyp, *edge_sc_xzp, *edge_sc_yzp;
 
     /* Make a list of all the edge geometry structs in the model */
@@ -1628,10 +1601,10 @@
 	return 0;
     }
 
-    /* if the bounding box of each faceuse is not within distance
-     * tolerance of each other, then skip fusing
+    /* verify the bounding box of each faceuse overlaps the other
+     * faceuse bounding box
      */
-    if (V3RPP_DISJOINT_TOL(f1->min_pt, f1->max_pt, f2->min_pt, f2->max_pt, tol->dist)) {
+    if (!V3RPP_OVERLAP_TOL(f1->min_pt, f1->max_pt, f2->min_pt, f2->max_pt, tol->dist)) {
 	return 0;
     }
 
@@ -1760,20 +1733,19 @@
     int count=0;
     const char *magic_type;
 
-    if (UNLIKELY(rt_g.NMG_debug & DEBUG_BOOL)) {
+    if (rt_g.NMG_debug & DEBUG_BOOL)
 	bu_log("nmg_break_all_es_on_v(magic=x%x, v=x%x)\n", magic_p, v);
-    }
 
     magic_type = bu_identify_magic(*magic_p);
-    if (UNLIKELY(BU_STR_EQUAL(magic_type, "NULL") ||
-	BU_STR_EQUAL(magic_type, "Unknown_Magic"))) {
+    if (BU_STR_EQUAL(magic_type, "NULL") ||
+	BU_STR_EQUAL(magic_type, "Unknown_Magic")) {
 	bu_log("Bad magic pointer passed to nmg_break_all_es_on_v (%s)\n", magic_type);
 	bu_bomb("Bad magic pointer passed to nmg_break_all_es_on_v()\n");
     }
 
     nmg_edgeuse_tabulate(&eus, magic_p);
 
-    for (i = 0; i < BU_PTBL_END(&eus); i++) {
+    for (i=0; i<BU_PTBL_END(&eus); i++) {
 	struct edgeuse *eu;
 	struct vertex *va;
 	struct vertex *vb;
@@ -1782,35 +1754,29 @@
 
 	eu = (struct edgeuse *)BU_PTBL_GET(&eus, i);
 
-	if (eu->g.magic_p && *eu->g.magic_p == NMG_EDGE_G_CNURB_MAGIC) {
+	if (eu->g.magic_p && *eu->g.magic_p == NMG_EDGE_G_CNURB_MAGIC)
 	    continue;
-	}
 	va = eu->vu_p->v_p;
 	vb = eu->eumate_p->vu_p->v_p;
 
-	if (va == v || bn_pt3_pt3_equal(va->vg_p->coord, v->vg_p->coord, tol)) {
-	    continue;
-	}
-	if (vb == v || bn_pt3_pt3_equal(vb->vg_p->coord, v->vg_p->coord, tol)) {
-	    continue;
-	}
-	if (UNLIKELY(va == vb || bn_pt3_pt3_equal(va->vg_p->coord, vb->vg_p->coord, tol))) {
-	    bu_bomb("nmg_break_all_es_on_v(): found zero length edgeuse");
-	}
+	if (va == v) continue;
+	if (vb == v) continue;
 
 	code = bn_isect_pt_lseg(&dist, va->vg_p->coord, vb->vg_p->coord,
 				v->vg_p->coord, tol);
 
 	if (code < 1) continue;	/* missed */
 
-	if (UNLIKELY(code == 1 || code == 2)) {
-	    bu_bomb("nmg_break_all_es_on_v(): internal error");
+	if (code == 1 || code == 2) {
+	    bu_log("nmg_break_all_es_on_v() code=%d, why wasn't this vertex fused?\n", code);
+	    bu_log("\teu=x%x, v=x%x\n", eu, v);
+	    continue;
 	}
 	/* Break edge on vertex, but don't fuse yet. */
 
-	if (UNLIKELY(rt_g.NMG_debug & DEBUG_BOOL)) {
+	if (rt_g.NMG_debug & DEBUG_BOOL)
 	    bu_log("\tnmg_break_all_es_on_v: breaking eu x%x on v x%x\n", eu, v);
-	}
+
 	(void)nmg_ebreak(v, eu);
 	count++;
     }
@@ -2362,7 +2328,7 @@
 	    break;
     }
 
-    /* Move list head so that it is in between min and max entries. */
+    /* Move list head so that it is inbetween min and max entries. */
     if (BU_LIST_PNEXT_CIRC(nmg_radial, rmax) == rmin) {
 	/* Maximum entry is followed by minimum.  Ascending --> CCW */
 	BU_LIST_DEQUEUE(hd);
@@ -2603,7 +2569,7 @@
  * all but one edgeuse are marked as "outies",
  * and the remaining one is marked as a non-crack.
  * The "outie" edgeuses are marked off in pairs,
- * in the loopuse's edgeuse order.
+ * in the loopuses's edgeuse order.
  */
 void
 nmg_radial_mark_cracks(struct bu_list *hd, const struct edge *e1, const struct edge *e2, const struct bn_tol *tol)
Index: src/librt/primitives/nmg/nmg_class.c
===================================================================
--- src/librt/primitives/nmg/nmg_class.c	(revision 53222)
+++ src/librt/primitives/nmg/nmg_class.c	(working copy)
@@ -145,9 +145,9 @@
     if (eu_rinf == eu) {
 	bu_bomb("joint_hitmiss2: radial eu is me?\n");
     }
-    /* If eu_rinf == eu->eumate_p, that's OK, this is a dangling face,
+    /* If eu_rinf == eu->eumate_p, thats OK, this is a dangling face,
      * or a face that has not been fully hooked up yet.
-     * It's OK as long as the orientations both match.
+     * It's OK as long the the orientations both match.
      */
     if (eu->up.lu_p->orientation == eu_rinf->up.lu_p->orientation) {
 	if (eu->up.lu_p->orientation == OT_SAME) {
@@ -200,7 +200,7 @@
  * is closer to this edgeuse than the previous neighbor(s) as given
  * in the "closest" structure.
  * If it is, record how close the point is, and whether it is IN, ON, or OUT.
- * The neighbor's "p" element will indicate the edgeuse or vertexuse closest.
+ * The neighor's "p" element will indicate the edgeuse or vertexuse closest.
  *
  * This routine should print everything indented two tab stops.
  *
@@ -620,7 +620,7 @@
  * the number of times it crosses a face.
  *
  * The flag "in_or_out_only" specifies that the point is known to not
- * be on the shell, therefore only returns of NMG_CLASS_AinB or
+ * be on the shell, therfore only returns of NMG_CLASS_AinB or
  * NMG_CLASS_AoutB are acceptable.
  *
  * The point is "A", and the face is "B".
@@ -826,7 +826,7 @@
 	goto out;
     }
 
-    /* we use topology to determine if the vertex is "ON" the
+    /* we use topology to determing if the vertex is "ON" the
      * other shell.
      */
     for (BU_LIST_FOR(vup, vertexuse, &vu->v_p->vu_hd)) {
@@ -967,11 +967,11 @@
     VMOVE(e_max_pt, eu->vu_p->v_p->vg_p->coord);
     VMAX(e_max_pt, eu->eumate_p->vu_p->v_p->vg_p->coord);
 
-    /* if the edge and shell bounding boxes are disjoint by at least
-     * distance tolerance then the edge is outside the shell. also
-     * both vertices of the edge are outside the shell.
+    /* if the edge and shell bounding boxes do not overlap
+     * then the edge is outside the shell. also both vertices
+     * of the edge are outside the shell.
      */
-    if (V3RPP_DISJOINT_TOL(e_min_pt, e_max_pt, s->sa_p->min_pt, s->sa_p->max_pt, tol->dist)) {
+    if (!V3RPP_OVERLAP_TOL(e_min_pt, e_max_pt, s->sa_p->min_pt, s->sa_p->max_pt, tol->dist)) {
 	NMG_INDEX_SET(classlist[NMG_CLASS_AoutB], eu->e_p);
 	NMG_INDEX_SET(classlist[NMG_CLASS_AoutB], eu->vu_p->v_p);
 	NMG_INDEX_SET(classlist[NMG_CLASS_AoutB], eu->eumate_p->vu_p->v_p);
@@ -1191,7 +1191,7 @@
     if (eu2->vu_p->v_p != eu1->vu_p->v_p) {
 	eu2 = eu2->eumate_p;
 	if (eu2->vu_p->v_p != eu1->vu_p->v_p)
-	    bu_bomb("nmg_2lu_identical() radial edgeuse doesn't share vertices\n");
+	    bu_bomb("nmg_2lu_identical() radial edgeuse doesn't share verticies\n");
     }
 
     lu1 = eu1->up.lu_p;
Index: src/librt/primitives/nmg/nmg_rt_segs.c
===================================================================
--- src/librt/primitives/nmg/nmg_rt_segs.c	(revision 53222)
+++ src/librt/primitives/nmg/nmg_rt_segs.c	(working copy)
@@ -69,7 +69,7 @@
 {
     struct seg *seg_p;
 
-    bu_log("Segment List (%d segments) (%s):\n", seg_count, s);
+    bu_log("Segment List (%d segnemts) (%s):\n", seg_count, s);
     /* print debugging data before returning */
     bu_log("Seghead:\n0x%08x magic: 0x%08x forw:0x%08x back:0x%08x\n\n",
 	   seghead,
@@ -682,7 +682,7 @@
     return ret_val;
 }
 
-HIDDEN int
+static inline int
 state5and6(struct seg *seghead, struct seg **seg_p, int *seg_count, struct hitmiss *a_hit, struct soltab *stp, struct application *ap, struct bn_tol *tol, int ret_val_7)
 {
     int ret_val = -1;
Index: src/librt/primitives/nmg/nmg_mk.c
===================================================================
--- src/librt/primitives/nmg/nmg_mk.c	(revision 53222)
+++ src/librt/primitives/nmg/nmg_mk.c	(working copy)
@@ -166,7 +166,7 @@
  *		case of the cube, there are 4 edgeuses per edge).
  * 48 vertexuse structures.
  *		Each vertexuse structure references one vertex structure
- *		and is in turn enrolled as a member of the linked list
+ *		and is in turn enroled as a member of the linked list
  *		headed by that vertex structure.
  *		Each vertexuse is cited by exactly one edgeuse.
  *		Also, "up" references the parent object (edgeuse, here).
@@ -239,7 +239,7 @@
  * N.B.:
  *
  * "maxindex" is a misnomer.  It is the value of the NEXT index
- * assigned.  This allows "ptab"s to be allocated easily using maxindex
+ * assigned.  This allows "ptab"s to be allocated easly using maxindex
  * and the index value of the structures to be the actual index into
  * the "ptab".
  */
@@ -585,7 +585,7 @@
  * or
  * lu = BU_LIST_FIRST(loopuse, &s->lu_hd);
  *
- * N.B.  This function is made more complex than warranted by using
+ * N.B.  This function is made more complex than warrented by using
  * the "hack" of stealing a vertexuse structure from the shell if at
  * all possible.  A future enhancement to this function would be to
  * remove the vertexuse steal and have the caller pass in the vertex
@@ -767,7 +767,7 @@
     if (v1) {
 	eu1->vu_p = nmg_mvu(v1, &eu1->l.magic, m);
     } else if (s->vu_p) {
-	/* This clause of the if statement dies when no vertex stealing */
+	/* This clause of the if statment dies when no vertex stealing */
 	/* steal the vertex from the shell */
 	vu = s->vu_p;
 	s->vu_p = (struct vertexuse *)NULL;
@@ -780,7 +780,7 @@
     if (v2) {
 	eu2->vu_p = nmg_mvu(v2, &eu2->l.magic, m);
     } else if (s->vu_p) {
-	/* This clause of the if statement dies when no vertex stealing */
+	/* This clause of the if statment dies when no vertex stealing */
 	/* steal the vertex from the shell */
 	vu = s->vu_p;
 	s->vu_p = (struct vertexuse *)NULL;
@@ -790,7 +790,7 @@
 	eu2->vu_p = nmg_mvvu(&eu2->l.magic, m);
     }
 
-    /* This if statement dies when no vertex stealing */
+    /* This if statment dies when no vertex stealing */
     if (s->vu_p) {
 	/* Ensure shell no longer has any stored vertexuse */
 	(void)nmg_kvu(s->vu_p);
@@ -1029,7 +1029,7 @@
 	BU_LIST_DEQUEUE(&p2->l);
 
 	/* Insert the next new edgeuse(s) at tail of the loop's list
-	 * (i.e., insert just before the head).
+	 * (ie, insert just before the head).
 	 * head, ....., p2, p1, (tail)
 	 */
 	BU_LIST_INSERT(&lu1->down_hd, &p1->l);
@@ -1038,7 +1038,7 @@
 	p1->up.lu_p = lu1;
 	p2->up.lu_p = lu2;
 
-	/* If p2's vertex does not match next one coming, quit */
+	/* If p2's vertex does not match next one comming, quit */
 	if (BU_LIST_IS_EMPTY(&s->eu_hd)) break;
 	p1 = BU_LIST_FIRST(edgeuse, &s->eu_hd);
 	NMG_CK_EDGEUSE(p1);
@@ -1104,7 +1104,7 @@
  *
  * Kill vertexuse, and null out parent's vu_p.
  *
- * This routine is not intended for general use by applications,
+ * This routine is not intented for general use by applications,
  * because it requires cooperation on the part of the caller to
  * properly dispose of or fix the now *quite* illegal parent.
  * (Illegal because the parent's vu_p is NULL).  It exists primarily
@@ -2384,7 +2384,7 @@
     /* dequeue this face from fg's face list */
     BU_LIST_DEQUEUE(&f->l);
 
-    /* get a new geometry structure */
+    /* get a new geometry sructure */
     m = nmg_find_model(&fu->l.magic);
     GET_FACE_G_PLANE(f->g.plane_p, m);
     f->flip = 0;
@@ -2515,9 +2515,9 @@
     }
 
     /* Note, calculating the bounding box for face_g_snurbs
-     * from the extents of the loop does not work
+     * from the extents of the the loop does not work
      * since the loops are most likely in parametric space
-     * thus we need to calculate the bounding box for the
+     * thus we need to calcualte the bounding box for the
      * face_g_snurb here instead.  There may be a more efficient
      * way, and one may need some time to take a good look at
      * this
@@ -2742,7 +2742,7 @@
 /**
  * n m g _ d e m o t e _ e u
  *
- * Demote a wire edge into a pair of self-loop vertices
+ * Demote a wire edge into a pair of self-loop verticies
  *
  *
  * Returns -
@@ -2875,7 +2875,7 @@
 	    eudst->vu_p->v_p == eusrc_mate->vu_p->v_p) ||
 	   (eudst->vu_p->v_p == eusrc->vu_p->v_p &&
 	    eudst_mate->vu_p->v_p == eusrc_mate->vu_p->v_p))) {
-	/* edgeuses do NOT share vertices. */
+	/* edgeuses do NOT share verticies. */
 	bu_log("eusrc (v=0x%p) (%g %g %g)\n", eusrc->vu_p->v_p, V3ARGS(eusrc->vu_p->v_p->vg_p->coord));
 	bu_log("eusrc_mate (v=0x%p) (%g %g %g)\n", eusrc_mate->vu_p->v_p, V3ARGS(eusrc_mate->vu_p->v_p->vg_p->coord));
 	bu_log("eudst (v=0x%p) (%g %g %g)\n", eudst->vu_p->v_p, V3ARGS(eudst->vu_p->v_p->vg_p->coord));
Index: src/librt/primitives/nmg/nmg_junk.c
===================================================================
--- src/librt/primitives/nmg/nmg_junk.c	(revision 53222)
+++ src/librt/primitives/nmg/nmg_junk.c	(working copy)
@@ -56,11 +56,11 @@
  * The first line consists of two integer numbers: the number of
  * points (vertices) in the file, followed by the number of polygons
  * in the file.  This line is followed by lines for each of the
- * vertices.  Each vertex is listed on its own line, as the 3tuple "X
- * Y Z".  After the list of vertices comes the list of polygons.
+ * verticies.  Each vertex is listed on its own line, as the 3tuple "X
+ * Y Z".  After the list of verticies comes the list of polygons.
  * each polygon is represented by a line containing 1) the number of
- * vertices in the polygon, followed by 2) the indices of the
- * vertices that make up the polygon.
+ * verticies in the polygon, followed by 2) the indicies of the
+ * verticies that make up the polygon.
  *
  * Implicitly returns r->s_p which is a new shell containing all the
  * faces from the polygon file.
Index: src/librt/primitives/nmg/nmg_rt_isect.c
===================================================================
--- src/librt/primitives/nmg/nmg_rt_isect.c	(revision 53222)
+++ src/librt/primitives/nmg/nmg_rt_isect.c	(working copy)
@@ -355,7 +355,7 @@
     vect_t pca_to_pole_vect;
     vect_t VtoPole_prj;
     point_t pcaA, pcaB;
-    fastf_t distA, distB;
+    double distA, distB;
     int code, status;
 
     VSETALL(pca_to_pole_vect, 0);
@@ -1087,7 +1087,7 @@
 
 /**
  * As the name implies, this routine is called when the ray and an
- * edge are colinear.  It handles marking the vertices as hit,
+ * edge are colinear.  It handles marking the verticies as hit,
  * remembering that this is a seg_in/seg_out pair, and builds the hit
  * on the edge.
  */
@@ -1180,7 +1180,7 @@
     VMOVE(r_dir_unit, rd->rp->r_dir);
     VUNITIZE(r_dir_unit);
 
-    if (UNLIKELY(rt_g.NMG_debug & DEBUG_RT_ISECT)) {
+    if (rt_g.NMG_debug & DEBUG_RT_ISECT) {
 	eu_p = BU_LIST_PNEXT_CIRC(edgeuse, eu);
 	bu_log("edge_hit_ray_state(%g %g %g -> %g %g %g _vs_ %g %g %g)\n",
 	       eu->vu_p->v_p->vg_p->coord[0],
@@ -1208,7 +1208,7 @@
 		fu = fu->fumate_p;
 		fu_eu = eu_p->eumate_p;
 	    }
-	    if (UNLIKELY(fu->orientation != OT_SAME)) {
+	    if (fu->orientation != OT_SAME) {
 		bu_log("%s[%d]: I can't seem to find an OT_SAME faceuse\nThis must be a `dangling' face.  I'll skip it\n", __FILE__, __LINE__);
 		continue;
 	    }
@@ -1216,20 +1216,20 @@
 	    if (fu->s_p != s)
 		continue;
 
-	    if (UNLIKELY(nmg_find_eu_leftvec(edge_left, eu_p))) {
+	    if (nmg_find_eu_leftvec(edge_left, eu_p)) {
 		bu_log("edgeuse not part of faceuse");
 		continue;
 	    }
 
-	    if (UNLIKELY(!(NMG_3MANIFOLD &
-		   NMG_MANIFOLDS(rd->manifolds, fu->f_p)))) {
+	    if (! (NMG_3MANIFOLD &
+		   NMG_MANIFOLDS(rd->manifolds, fu->f_p))) {
 		bu_log("This is not a 3-Manifold face.  I'll skip it\n");
 		continue;
 	    }
 
 	    cos_angle = VDOT(edge_left, r_dir_unit);
 
-	    if (UNLIKELY(rt_g.NMG_debug & DEBUG_RT_ISECT)) {
+	    if (rt_g.NMG_debug & DEBUG_RT_ISECT) {
 		bu_log("left_vect:(%g %g %g) cos_angle:%g\n",
 		       edge_left[0], edge_left[1],
 		       edge_left[2], cos_angle);
@@ -1239,14 +1239,14 @@
 		inb_cos_angle = cos_angle;
 		inb_fu = fu;
 		inb_eu = fu_eu;
-		if (UNLIKELY(rt_g.NMG_debug & DEBUG_RT_ISECT))
+		if (rt_g.NMG_debug & DEBUG_RT_ISECT)
 		    bu_log("New inb cos_angle %g\n", inb_cos_angle);
 	    }
 	    if (cos_angle > outb_cos_angle) {
 		outb_cos_angle = cos_angle;
 		outb_fu = fu;
 		outb_eu = fu_eu;
-		if (UNLIKELY(rt_g.NMG_debug & DEBUG_RT_ISECT))
+		if (rt_g.NMG_debug & DEBUG_RT_ISECT)
 		    bu_log("New outb cos_angle %g\n", outb_cos_angle);
 	    }
 	}
@@ -1267,12 +1267,12 @@
     /* Compute the ray state on the inbound side */
     NMG_GET_FU_NORMAL(norm, inb_fu);
     VMOVE(myhit->inbound_norm, norm);
-    if (UNLIKELY(MAGSQ(norm) < VDIVIDE_TOL))
+    if (MAGSQ(norm) < VDIVIDE_TOL)
 	bu_bomb("edge_hit_ray_state() null normal!\n");
 
     cos_angle = VDOT(norm, r_dir_unit);
 
-    if (UNLIKELY(rt_g.NMG_debug & DEBUG_RT_ISECT)) {
+    if (rt_g.NMG_debug & DEBUG_RT_ISECT) {
 	VPRINT("\ninb face normal", norm);
 	bu_log("cos_angle wrt ray direction: %g\n", cos_angle);
     }
@@ -1290,7 +1290,7 @@
     VMOVE(myhit->outbound_norm, norm);
     cos_angle = VDOT(norm, r_dir_unit);
 
-    if (UNLIKELY(rt_g.NMG_debug & DEBUG_RT_ISECT)) {
+    if (rt_g.NMG_debug & DEBUG_RT_ISECT) {
 	VPRINT("\noutb face normal", norm);
 	bu_log("cos_angle wrt ray direction: %g\n", cos_angle);
     }
@@ -1303,7 +1303,7 @@
 	myhit->in_out |= NMG_RAY_STATE_INSIDE;
 
 
-    if (UNLIKELY(rt_g.NMG_debug & DEBUG_RT_ISECT)) {
+    if (rt_g.NMG_debug & DEBUG_RT_ISECT) {
 	bu_log("myhit->in_out: 0x%02x/", myhit->in_out);
 	switch (myhit->in_out) {
 	    case HMG_HIT_IN_IN:
@@ -1426,7 +1426,7 @@
     int status;
     struct hitmiss *myhit;
     int vhit1, vhit2;
-    fastf_t dist_along_ray;
+    double dist_along_ray;
     vect_t r_dir_unit;
 
     VMOVE(r_dir_unit, rd->rp->r_dir);
@@ -1462,7 +1462,7 @@
 		/* we hit the vertex */
 		BU_LIST_MAGIC_SET(&myhit->l, NMG_RT_HIT_SUB_MAGIC);
 	    } else {
-		/* both verticies were missed, so edge is missed */
+		/* both vertecies were missed, so edge is missed */
 		BU_LIST_MAGIC_SET(&myhit->l, NMG_RT_MISS_MAGIC);
 	    }
 	    BU_LIST_INSERT(&rd->rd_miss, &myhit->l);
@@ -2082,14 +2082,14 @@
     VMOVE(plane_pt, rd->plane_pt);
     dist = rd->ray_dist_to_plane;
 
-    if (UNLIKELY(fabs(DIST_PT_PLANE(plane_pt, norm)) > rd->tol->dist)) {
+    if (DIST_PT_PLANE(plane_pt, norm) > rd->tol->dist) {
 	bu_log("%s:%d plane_pt (%g %g %g) @ dist (%g)out of tolerance\n",
 	       __FILE__, __LINE__, V3ARGS(plane_pt), dist);
 	bu_bomb("isect_ray_planar_face() dist out of tol\n");
     }
 
-    if (UNLIKELY(rt_g.NMG_debug & DEBUG_RT_ISECT)) {
-	fastf_t new_dist;
+    if (rt_g.NMG_debug & DEBUG_RT_ISECT) {
+	double new_dist;
 	bu_log("\tray (%16.10e %16.10e %16.10e) (-> %16.10e %16.10e %16.10e)\n",
 	       rd->rp->r_pt[0],
 	       rd->rp->r_pt[1],
@@ -2178,12 +2178,12 @@
 
 	    break;
 	default	:
-	    bu_log("%s[line:%d] BIZARRE ray/plane intercept point classification\n",
+	    bu_log("%s[line:%d] BIZZARE ray/plane intercept point classification\n",
 		   __FILE__, __LINE__);
 	    bu_bomb("isect_ray_planar_face() Bizz\n");
     }
 
-    /* intersect the ray with the edges/vertices of the face */
+    /* intersect the ray with the edges/verticies of the face */
     for (BU_LIST_FOR(lu_p, loopuse, &fu_p->lu_hd))
 	isect_ray_loopuse(rd, lu_p);
 }
@@ -2378,7 +2378,7 @@
     NMG_CK_HITMISS_LISTS(rd);
 
     /* Caller has assured us that the ray intersects the nmg model,
-     * check ray for intersection with rpp's of nmgregion's
+     * check ray for intersecion with rpp's of nmgregion's
      */
     for (BU_LIST_FOR(r_p, nmgregion, &rd->rd_m->r_hd)) {
 	NMG_CK_REGION(r_p);
@@ -2799,7 +2799,7 @@
     bu_free((char *)rd.hitmiss, "free nmg geom hit list");
 
     if (!rd.rd_m->manifolds) {
-	/* If there is no manifolds list attached to the model
+	/* If there is no manfolds list attached to the model
 	 * structure then the list was created here (within
 	 * nmg_class_ray_vs_shell) and should be freed here.
 	 * If there is a manifold list attached to the model
Index: src/librt/primitives/nmg/nmg_tri_mc.c
===================================================================
--- src/librt/primitives/nmg/nmg_tri_mc.c	(revision 53222)
+++ src/librt/primitives/nmg/nmg_tri_mc.c	(working copy)
@@ -559,7 +559,7 @@
 	    for(i=0;i<4;i++)
 		if(primp[i]->in>0 && primp[i]->hit[Z] < b) b = primp[i]->hit[Z];
 	    b = bin(b, step);
-	} else { /* if we know we're intersecting the surface, walk slow. */
+	} else { /* iff we know we're intersecting the surface, walk slow. */
 	    if(NEAR_ZERO(last_b+VOODOO, tol->dist))
 		bu_log("teh fux? lastb = %g\n", last_b);
 	    b = last_b + step;
Index: src/librt/primitives/nmg/nmg_pt_fu.c
===================================================================
--- src/librt/primitives/nmg/nmg_pt_fu.c	(revision 53222)
+++ src/librt/primitives/nmg/nmg_pt_fu.c	(working copy)
@@ -46,8 +46,8 @@
  */
 struct ve_dist {
     struct bu_list l;
-    uint32_t *magic_p;	/* pointer to edge/vertex structure */
-    fastf_t dist;	/* distance squared from point to edge */
+    uint32_t *magic_p;/* pointer to edge/vertex structure */
+    double dist;	/* distance squared from point to edge */
     struct vertex *v1;
     struct vertex *v2;
     int status;	/* return code from bn_dist_pt3_lseg3 */
@@ -249,13 +249,13 @@
 static int
 Quadrant(fastf_t x, fastf_t y)
 {
-    if (x > -SMALL_FASTF) {
-	if (y > -SMALL_FASTF)
+    if (x >= 0.0) {
+	if (y >= 0.0)
 	    return 1;
 	else
 	    return 4;
     } else {
-	if (y > -SMALL_FASTF)
+	if (y >= 0.0)
 	    return 2;
 	else
 	    return 3;
@@ -331,10 +331,10 @@
 
     eu = eu_in;
 
-    if (UNLIKELY(rt_g.NMG_debug & DEBUG_PT_FU))
+    if (rt_g.NMG_debug & DEBUG_PT_FU)
 	bu_log("nmg_class_pt_euvu((%g %g %g), eu=x%x)\n", V3ARGS(pt), eu);
 
-    if (UNLIKELY(*eu->up.magic_p != NMG_LOOPUSE_MAGIC)) {
+    if (*eu->up.magic_p != NMG_LOOPUSE_MAGIC) {
 	bu_log("nmg_class_pt_euvu() called with eu (x%x) that isn't part of a loop\n", eu);
 	bu_bomb("nmg_class_pt_euvu() called with eu that isn't part of a loop");
     }
@@ -355,7 +355,7 @@
 	struct edgeuse *eu_test;
 	int done=0;
 
-	if (UNLIKELY(rt_g.NMG_debug & DEBUG_PT_FU))
+	if (rt_g.NMG_debug & DEBUG_PT_FU)
 	    bu_log("nmg_class_pt_euvu: eu x%x is a crack\n", eu);
 
 	/* find next eu from this vertex that is not a crack */
@@ -379,7 +379,7 @@
 	else
 	    eu = eu_test;
 
-	if (UNLIKELY(rt_g.NMG_debug & DEBUG_PT_FU))
+	if (rt_g.NMG_debug & DEBUG_PT_FU)
 	    bu_log("\tUsing eu x%x instead\n", eu);
     }
 
@@ -387,7 +387,7 @@
 	struct edgeuse *eu_test;
 	int done=0;
 
-	if (UNLIKELY(rt_g.NMG_debug & DEBUG_PT_FU))
+	if (rt_g.NMG_debug & DEBUG_PT_FU)
 	    bu_log("nmg_class_pt_euvu: prev_eu (x%x) is a crack\n", prev_eu);
 
 	/* find previous eu ending at this vertex that is not a crack */
@@ -411,20 +411,20 @@
 	else
 	    prev_eu = eu_test;
 
-	if (UNLIKELY(rt_g.NMG_debug & DEBUG_PT_FU))
+	if (rt_g.NMG_debug & DEBUG_PT_FU)
 	    bu_log("\tUsing prev_eu x%x instead\n", prev_eu);
     }
 
     /* left is the Y-axis of our XY-coordinate system */
-    if (UNLIKELY(nmg_find_eu_leftvec(left, eu))) {
+    if (nmg_find_eu_leftvec(left,  eu)) {
 	bu_log("nmg_class_pt_euvu: nmg_find_eu_leftvec() for eu=x%x failed!\n", eu);
 	bu_bomb("nmg_class_pt_euvu: nmg_find_eu_leftvec() failed!");
     }
 
-    if (UNLIKELY(rt_g.NMG_debug & DEBUG_PT_FU))
+    if (rt_g.NMG_debug & DEBUG_PT_FU)
 	bu_log("\tprev_eu = x%x, left = (%g %g %g)\n", prev_eu, V3ARGS(left));
 
-    /* v0 is the origin of the XY-coordinate system */
+    /* v0 is the origin of the XY-coordinat system */
     v0 = eu->vu_p->v_p;
     NMG_CK_VERTEX(v0);
 
@@ -436,7 +436,7 @@
     v2 = prev_eu->vu_p->v_p;
     NMG_CK_VERTEX(v2);
 
-    if (UNLIKELY(rt_g.NMG_debug & DEBUG_PT_FU))
+    if (rt_g.NMG_debug & DEBUG_PT_FU)
 	bu_log("\tv0=x%x, v1=x%x, v2=x%x\n", v0, v1, v2);
 
     /* eu_dir is our X-direction */
@@ -445,7 +445,7 @@
     /* other_eudir is direction along the previous EU (from origin) */
     VSUB2(other_eudir, v2->vg_p->coord, v0->vg_p->coord);
 
-    if (UNLIKELY(rt_g.NMG_debug & DEBUG_PT_FU))
+    if (rt_g.NMG_debug & DEBUG_PT_FU)
 	bu_log("\teu_dir=(%g %g %g), other_eudir=(%x %x %x)\n", V3ARGS(eu_dir), V3ARGS(other_eudir));
 
     /* get X and Y components for other_eu */
@@ -455,13 +455,13 @@
     /* which quadrant does this XY point lie in */
     quado = Quadrant(xo, yo);
 
-    if (UNLIKELY(rt_g.NMG_debug & DEBUG_PT_FU))
-	bu_log("\txo=%g, yo=%g, quadrant=%d\n", xo, yo, quado);
+    if (rt_g.NMG_debug & DEBUG_PT_FU)
+	bu_log("\txo=%g, yo=%g, qudarant=%d\n", xo, yo, quado);
 
     /* get direction to PT from origin */
     VSUB2(pt_dir, pt, v0->vg_p->coord);
 
-    if (UNLIKELY(rt_g.NMG_debug & DEBUG_PT_FU))
+    if (rt_g.NMG_debug & DEBUG_PT_FU)
 	bu_log("\tpt_dir=(%g %g %g)\n", V3ARGS(pt_dir));
 
     /* get X and Y components for PT */
@@ -471,8 +471,8 @@
     /* which quadrant does this XY point lie in */
     quadpt = Quadrant(xpt, ypt);
 
-    if (UNLIKELY(rt_g.NMG_debug & DEBUG_PT_FU))
-	bu_log("\txpt=%g, ypt=%g, quadrant=%d\n", xpt, ypt, quadpt);
+    if (rt_g.NMG_debug & DEBUG_PT_FU)
+	bu_log("\txpt=%g, ypt=%g, qudarant=%d\n", xpt, ypt, quadpt);
 
     /* do a quadrant comparison first (cheap!!!) */
     if (quadpt < quado)
@@ -481,7 +481,7 @@
     if (quadpt > quado)
 	return NMG_CLASS_AoutB;
 
-    /* both are in the same quadrant, need to normalize the coordinates */
+    /* both are in the same quadrant, need to normalize the corrdinates */
     len = sqrt(xo*xo + yo*yo);
     xo = xo/len;
     yo = yo/len;
@@ -490,7 +490,7 @@
     xpt = xpt/len;
     ypt = ypt/len;
 
-    if (UNLIKELY(rt_g.NMG_debug & DEBUG_PT_FU))
+    if (rt_g.NMG_debug & DEBUG_PT_FU)
 	bu_log("\tNormalized xo, yo=(%g %g), xpt, ypt=(%g %g)\n", xo, yo, xpt, ypt);
 
     switch (quadpt) {
@@ -523,7 +523,7 @@
 	    bu_bomb("This can't happen (illegal quadrant)\n");
 	    break;
     }
-    if (UNLIKELY(rt_g.NMG_debug & DEBUG_PT_FU))
+    if (rt_g.NMG_debug & DEBUG_PT_FU)
 	bu_log("returning %s\n", nmg_class_name(class));
 
     return class;
@@ -718,7 +718,7 @@
     struct edge_info *ei;
     struct edge_info *ei_p;
     struct edge_info *tmp;
-    fastf_t dist;
+    double dist;
 
     BU_CK_LIST_HEAD(&edge_list->l);
     BU_CK_LIST_HEAD(near1);
@@ -738,7 +738,7 @@
 	    if (ei_p->ved_p->magic_p == ei->ved_p->magic_p &&
 		ei_p->eu_p->eumate_p->vu_p->v_p == ei->eu_p->vu_p->v_p &&
 		ei_p->eu_p->vu_p->v_p == ei->eu_p->eumate_p->vu_p->v_p) {
-		if (UNLIKELY(rt_g.NMG_debug & DEBUG_PT_FU)) {
+		if (rt_g.NMG_debug & DEBUG_PT_FU) {
 		    bu_log("tossing edgeuse pair:\n");
 		    bu_log("(%g %g %g) -> (%g %g %g)\n",
 			   V3ARGS(ei->eu_p->vu_p->v_p->vg_p->coord),
@@ -783,7 +783,7 @@
 	}
     }
 
-    if (UNLIKELY(rt_g.NMG_debug & DEBUG_PT_FU)) {
+    if (rt_g.NMG_debug & DEBUG_PT_FU) {
 	bu_log("dist %g near list\n", dist);
 	for (BU_LIST_FOR(ei, edge_info, near1)) {
 	    bu_log("\t(%g %g %g) -> (%g %g %g)\n",
@@ -886,7 +886,7 @@
     struct bu_list near1;
     int lu_class = NMG_CLASS_Unknown;
 
-    if (UNLIKELY(rt_g.NMG_debug & DEBUG_PT_FU)) {
+    if (rt_g.NMG_debug & DEBUG_PT_FU) {
 	bu_log("compute_loop_class()\n");
 	for (BU_LIST_FOR(ei, edge_info, &edge_list->l)) {
 	    bu_log("dist:%g class:%s status:%d\n\tv1(%g %g %g) v2(%g %g %g)\n",
@@ -917,7 +917,7 @@
 	} else
 	    bu_bomb("bad lu orientation\n");
 
-	if (UNLIKELY(rt_g.NMG_debug & DEBUG_PT_FU)) {
+	if (rt_g.NMG_debug & DEBUG_PT_FU) {
 	    bu_log("list was empty, so class is %s\n",
 		   nmg_class_name(lu_class));
 	}
@@ -934,7 +934,7 @@
 	    case 1: /* pt is on ei->ved_p->v1 */
 	    case 2: /* pt is on ei->ved_p->v2 */
 		lu_class = NMG_CLASS_AonBshared;
-		if (UNLIKELY(rt_g.NMG_debug & DEBUG_PT_FU))
+		if (rt_g.NMG_debug & DEBUG_PT_FU)
 		    pl_pt_lu(fpi, lu, ei);
 		done = 1;
 		break;
@@ -942,11 +942,11 @@
 	    case 4: /* pt pca is v2 */
 	    case 5: /* pt pca between v1 and v2 */
 		lu_class = ei->class;
-		if (UNLIKELY(rt_g.NMG_debug & DEBUG_PT_FU)) {
+		if (rt_g.NMG_debug & DEBUG_PT_FU) {
 		    bu_log("found status 5 edge, loop class is %s\n",
 			   nmg_class_name(lu_class));
 		}
-		if (UNLIKELY(rt_g.NMG_debug & DEBUG_PT_FU))
+		if (rt_g.NMG_debug & DEBUG_PT_FU)
 		    pl_pt_lu(fpi, lu, ei);
 		done = 1;
 		break;
@@ -969,7 +969,7 @@
 	bu_free((char *)ei, "edge_info struct");
     }
 
-    if (UNLIKELY(rt_g.NMG_debug & DEBUG_PT_FU)) {
+    if (rt_g.NMG_debug & DEBUG_PT_FU) {
 	bu_log("compute_loop_class() returns %s\n",
 	       nmg_class_name(lu_class));
     }
@@ -1255,7 +1255,7 @@
 	 * is anything but OUTSIDE
 	 */
 	if (rt_g.NMG_debug & DEBUG_PT_FU)
-	    bu_log("nmg_class_pt_fu_except((%g %g %g) outside face RPP\n",
+	    bu_log("nmg_class_pt_fu_except((%g %g %g) ouside face RPP\n",
 		   V3ARGS(pt));
 
 	return NMG_CLASS_AoutB;
Index: src/librt/primitives/nmg/nmg_mod.c
===================================================================
--- src/librt/primitives/nmg/nmg_mod.c	(revision 53222)
+++ src/librt/primitives/nmg/nmg_mod.c	(working copy)
@@ -1,4 +1,3 @@
-
 /*                       N M G _ M O D . C
  * BRL-CAD
  *
@@ -87,7 +86,7 @@
  * the same plane equation (to within the given tolerance), and
  * combine them into a single face.
  *
- * Note that this may result in some of the vertices being very
+ * Note that this may result in some of the verticies being very
  * slightly off the plane equation, but the geometry routines need to
  * be prepared for this in any case.  If the "simplify" flag is set,
  * pairs of loops in the face that touch will be combined into a
@@ -143,10 +142,8 @@
 		register fastf_t dist;
 		/* If plane equations are different, done */
 
-		/* if the face bounding boxes are at least distance
-		 * distance tolerance apart, skip them.
-		 */
-		if (V3RPP_DISJOINT_TOL(f1->min_pt, f1->max_pt, f2->min_pt, f2->max_pt, tol->dist)) {
+		/* test if the bounding boxes of the faceuse overlap */
+		if (!V3RPP_OVERLAP_TOL(f1->min_pt, f1->max_pt, f2->min_pt, f2->max_pt, tol->dist)) {
 		    continue;
 		}
 
@@ -552,7 +549,7 @@
 		class = nmg_classify_lu_lu(lu, lu1, tol);
 
 		if (class == NMG_CLASS_AonBshared) {
-		    nmg_klu(lu1); /* lu1 is redundant */
+		    nmg_klu(lu1); /* lu1 is redudndant */
 		}
 
 		lu1 = next_lu;
@@ -953,15 +950,15 @@
  *
  * The new face will consist of a single loop made from n edges
  * between the n vertices.  Before an edge is created between a pair
- * of vertices, we check to see if there is already an edge with
+ * of verticies, we check to see if there is already an edge with
  * exactly one edgeuse+mate (in this shell) that runs between the two
- * vertices.  If such an edge can be found, the newly created
+ * verticies.  If such an edge can be found, the newly created
  * edgeuses will just use the existing edge.  This means that no
  * special call to nmg_gluefaces() is needed later.
  *
  * If a pointer in verts is a pointer to a null vertex pointer, a new
- * vertex is created.  In this way, new vertices can be created
- * conveniently within a user's list of known vertices
+ * vertex is created.  In this way, new verticies can be created
+ * conveniently within a user's list of known verticies
  *
  * verts		pointers to struct vertex	    vertex structs
  *
@@ -1055,7 +1052,7 @@
 	if (rt_g.NMG_debug & DEBUG_CMFACE)
 	    bu_log("nmg_cmface() euold: %8x\n", euold);
 
-	/* look for pre-existing edge between these vertices */
+	/* look for pre-existing edge between these verticies */
 	if (*verts[i]) {
 	    /* look for an existing edge to share */
 	    eur = nmg_findeu(*verts[(i+1)%n], *verts[i], s, euold, 1);
@@ -1603,7 +1600,7 @@
  *
  * Note that this routine can't be used incrementally, because after
  * an odd number (like one) of faceuses have been "fixed", there is an
- * inherent parity error, which will cause wrong decisions to be
+ * inherrent parity error, which will cause wrong decisions to be
  * made.  Therefore, *all* faces have to be moved from one shell to
  * another before the radial parity can be "fixed".  Even then, this
  * isn't going to work right unless we are given a list of all the
@@ -1739,14 +1736,14 @@
     NMG_CK_FACEUSE(fumate);
 
     if (fu->s_p != src) {
-	bu_log("nmg_mv_fu_between_shells(dest=x%x, src=x%x, fu=x%x), fu->s_p=x%x isn't src shell\n",
+	bu_log("nmg_mv_fu_between_shells(dest=x%x, src=x%x, fu=x%x), fu->s_p=x%x isnt src shell\n",
 	       dest, src, fu, fu->s_p);
-	bu_bomb("fu->s_p isn't source shell\n");
+	bu_bomb("fu->s_p isnt source shell\n");
     }
     if (fumate->s_p != src) {
 	bu_log("nmg_mv_fu_between_shells(dest=x%x, src=x%x, fu=x%x), fumate->s_p=x%x isn't src shell\n",
 	       dest, src, fu, fumate->s_p);
-	bu_bomb("fumate->s_p isn't source shell\n");
+	bu_bomb("fumate->s_p isnt source shell\n");
     }
 
     /* Remove fu from src shell */
@@ -1853,7 +1850,7 @@
  * Construct a duplicate of a face into the shell 's'.  The vertex
  * geometry is copied from the source face into topologically distinct
  * (new) vertex and vertex_g structs.  They will start out being
- * geometrically coincident, but it is anticipated that the caller will
+ * geometricly coincident, but it is anticipated that the caller will
  * modify the geometry, e.g. as in an extrude operation.
  *
  * It is the caller's responsibility to re-bound the new face after
@@ -1969,14 +1966,14 @@
  * N M G _ J L
  *
  * Join two loops together which share a common edge, such that both
- * occurrences of the common edge are deleted.  This routine always
+ * occurances of the common edge are deleted.  This routine always
  * leaves "lu" intact, and kills the loop radial to "eu" (after
  * stealing all its edges).
  *
  * Either both loops must be of the same orientation, or then first
  * loop must be OT_SAME, and the second loop must be OT_OPPOSITE.
  * Joining OT_SAME & OT_OPPOSITE always gives an OT_SAME result.
- * Above statement is not true!!!! I have added nmg_lu_reorient() -JRA
+ * Above statment is not true!!!! I have added nmg_lu_reorient() -JRA
  * Since "lu" must survive, it must be the OT_SAME one.
  */
 void
@@ -2070,7 +2067,7 @@
  *
  * This routine can be used to join two exterior loops which do not
  * overlap, and it can also be used to join an exterior loop with a
- * loop of opposite orientation that lies entirely within it.  This
+ * loop of oposite orientation that lies entirely within it.  This
  * restriction is important, but not checked for.
  *
  * If the two vertexuses reference distinct vertices, then two new
@@ -2291,7 +2288,7 @@
  * Returns the new loopuse pointer.  The new loopuse will contain
  * "vu2" and the edgeuse associated with "vu2" as the FIRST edgeuse on
  * the list of edgeuses.  The edgeuse for the new edge (connecting the
- * vertices indicated by vu1 and vu2) will be the LAST edgeuse on the
+ * verticies indicated by vu1 and vu2) will be the LAST edgeuse on the
  * new loopuse's list of edgeuses.
  *
  * It is the caller's responsibility to re-bound the loops.
@@ -2346,7 +2343,7 @@
     NMG_CK_LOOPUSE(oldlu);
 
     if (eu2->up.lu_p != oldlu) {
-	bu_bomb("nmg_cut_loop() vertices not descendants of same loop\n");
+	bu_bomb("nmg_cut_loop() vertices not decendants of same loop\n");
     }
 
     if (vu1->v_p == vu2->v_p) {
@@ -2471,7 +2468,7 @@
  * N M G _ S P L I T _ L U _ A T _ V U
  *
  * In a loop which has at least two distinct uses of a vertex, split
- * off the edges from "split_vu" to the second occurrence of the vertex
+ * off the edges from "split_vu" to the second occurance of the vertex
  * into a new loop.  It is the caller's responsibility to re-bound the
  * loops.
  *
@@ -2575,7 +2572,7 @@
  *
  * Returns -
  * vu if this vertex appears elsewhere in the loopuse.
- * NULL if this is the only occurrence of this vertex in the loopuse.
+ * NULL if this is the only occurance of this vertex in the loopuse.
  *
  * XXX move to nmg_info.c
  */
@@ -2852,7 +2849,7 @@
  * N M G _ G E T _ T O U C H I N G _ J A U N T S
  *
  * Create a table of EU's. Each EU will be the first EU in a touching
- * jaunt (edgeuses from vert A->B->A) where vertex B appears elsewhere
+ * jaunt (edgeuses from vert A->B->A) where vertex B appears elswhere
  * in the loopuse lu.
  *
  * returns:
@@ -2966,7 +2963,7 @@
 	for (j=0; j<BU_PTBL_END(jaunt_tbl); j++) {
 	    struct edgeuse *jaunt_eu;
 
-	    /* Don't worry about this jaunt */
+	    /* Don't worru about this jaunt */
 	    if (j == jaunt_no)
 		continue;
 
@@ -3833,7 +3830,7 @@
  *
  * Make a new edge, and a vertex.  If v is non-null it is taken as a
  * pointer to an existing vertex to use as the start of the new edge.
- * If v is null, then a new vertex is created for the beginning of the
+ * If v is null, then a new vertex is created for the begining of the
  * new edge.
  *
  * In either case, the new edge will exist as the "next" edgeuse after
@@ -3989,7 +3986,7 @@
 	eu1 = nmg_me((struct vertex *)NULL, (struct vertex *)NULL, s);
 	eu2 = eu1->eumate_p;
 	/* Make both ends of edge use same vertex.
-	 * The second vertex is freed automatically.
+	 * The second vertex is freed automaticly.
 	 */
 	nmg_movevu(eu2->vu_p, eu1->vu_p->v_p);
     }
@@ -4095,7 +4092,7 @@
  *
  * Makes a new edge, and a vertex.  If v is non-null it is taken as a
  * pointer to an existing vertex to use as the start of the new edge.
- * If v is null, then a new vertex is created for the beginning of the
+ * If v is null, then a new vertex is created for the begining of the
  * new edge.
  *
  * In either case, the new edgeuse will exist as the "next" edgeuse
@@ -4137,7 +4134,7 @@
  *			     /             /
  *		    <-------.   <---------.
  *
- * Note: to replicate the behavior of this routine in BRL-CAD Release
+ * Note: to replicate the behavior of this routine in BRL-CAD Relase
  * 4.0, call with share_geom=0.
  */
 struct edgeuse *
@@ -4200,7 +4197,7 @@
 
 	/* Are the two edgeuses going in same or opposite directions?
 	 * Join the newly created temporary edge (teuX, teuY) with the
-	 * new permanent edge (neu1, neu2).  On first pass, just take
+	 * new permanant edge (neu1, neu2).  On first pass, just take
 	 * note of the new edge & edgeuses.
 	 */
 	NMG_CK_VERTEX(teuX->vu_p->v_p);
@@ -4254,7 +4251,7 @@
  * sets of edgeuses share the original edgeuse geometry.  If the
  * original edge had no edge geometry, then none is created here.
  *
- * This is a simple compatibility interface to nmg_esplit().  The
+ * This is a simple compatability interface to nmg_esplit().  The
  * return is the return of nmg_esplit().
  */
 struct edgeuse *
@@ -4811,7 +4808,7 @@
 /**
  * N M G _ E I N S
  *
- * Insert a new (zero length) edge at the beginning of (i.e., before) an
+ * Insert a new (zero length) edge at the begining of (ie, before) an
  * existing edgeuse.  Perhaps this is what nmg_esplit and nmg_eusplit
  * should have been like?
  *
@@ -4901,14 +4898,14 @@
     NMG_CK_EDGEUSE(eumate);
 
     if (eu->up.s_p != src) {
-	bu_log("nmg_mv_eu_between_shells(dest=x%x, src=x%x, eu=x%x), eu->up.s_p=x%x isn't src shell\n",
+	bu_log("nmg_mv_eu_between_shells(dest=x%x, src=x%x, eu=x%x), eu->up.s_p=x%x isnt src shell\n",
 	       dest, src, eu, eu->up.s_p);
-	bu_bomb("eu->up.s_p isn't source shell\n");
+	bu_bomb("eu->up.s_p isnt source shell\n");
     }
     if (eumate->up.s_p != src) {
 	bu_log("nmg_mv_eu_between_shells(dest=x%x, src=x%x, eu=x%x), eumate->up.s_p=x%x isn't src shell\n",
 	       dest, src, eu, eumate->up.s_p);
-	bu_bomb("eumate->up.s_p isn't source shell\n");
+	bu_bomb("eumate->up.s_p isnt source shell\n");
     }
 
     /* Remove eu from src shell */
Index: src/librt/primitives/nmg/nmg_extrude.c
===================================================================
--- src/librt/primitives/nmg/nmg_extrude.c	(revision 53222)
+++ src/librt/primitives/nmg/nmg_extrude.c	(working copy)
@@ -346,7 +346,7 @@
 
 	/* skip this checking until we get by the first edgeuse */
 	if (edges) {
-	    /* Are we back to the beginning? */
+	    /* Are we back to the begining? */
 	    if (eu->vu_p->v_p == start_eu->vu_p->v_p) {
 		/* done with this loop */
 		done = 1;
@@ -422,7 +422,7 @@
  * the other loopuse.  this is continued until the original edgeuse is
  * encountered.
  *
- * If overlapping loops are found, new loopuses are created and the
+ * If overlapping loops are found, new loopsuses are created and the
  * original loopuses are killed
  */
 void
@@ -814,7 +814,7 @@
  *
  * Clean up after nmg_extrude_shell.  intersects each face with every
  * other face in the shell and makes new face boundaries at the
- * intersections.  decomposes the result into separate shells.  where
+ * intersections.  decomposes the result into seperate shells.  where
  * faces have intersected, new shells will be created.  These shells
  * are detected and killed
  */
@@ -1234,7 +1234,7 @@
     old_r = s->r_p;
     NMG_CK_REGION(old_r);
 
-    /* decompose this shell and extrude each piece separately */
+    /* decompose this shell and extrude each piece seperately */
     new_r = nmg_mrsv(m);
     s_tmp = BU_LIST_FIRST(shell, &new_r->s_hd);
     (void)nmg_mv_shell_to_region(s, new_r);
Index: src/librt/primitives/nmg/nmg.c
===================================================================
--- src/librt/primitives/nmg/nmg.c	(revision 53222)
+++ src/librt/primitives/nmg/nmg.c	(working copy)
@@ -669,7 +669,7 @@
 #define NMG_KIND_DOUBLE_ARRAY      25
 
 /* number of kinds.  This number must have some extra space, for
- * upwards compatibility.
+ * upwards compatability.
  */
 #define NMG_N_KINDS                26
 
@@ -986,7 +986,7 @@
 		bu_log("reindex(p=x%x), p->index=%d, ret=%d, kind=%d\n", p, idx, ret, ecnt[idx].kind);
 		bu_bomb("reindex() This index not found in ecnt[]\n");
 	    }
-	    /* ret == 0 on suppressed loop_g ptrs, etc */
+	    /* ret == 0 on supressed loop_g ptrs, etc */
 	    if (ret < 0 || ret > ecnt[0].byte_offset) {
 		bu_log("reindex(p=x%x) %s, p->index=%d, ret=%d, maxindex=%d\n",
 		       p,
@@ -1712,7 +1712,7 @@
 	    d = &((struct disk_vertexuse_a_cnurb *)ip)[iindex];
 	    NMG_CK_VERTEXUSE_A_CNURB(vua);
 	    NMG_CK_DISKMAGIC(d->magic, DISK_VERTEXUSE_A_CNURB_MAGIC);
-	    /* These parameters are invariant w.r.t. 'mat' */
+	    /* These parameters are invarient w.r.t. 'mat' */
 	    ntohd((unsigned char *)vua->param, d->param, 3);
 	}
 	    return 0;
@@ -2024,7 +2024,7 @@
 
     /*
      * Check for proper version.
-     * In the future, this will be the backwards-compatibility hook.
+     * In the future, this will be the backwards-compatability hook.
      */
     if (rp->nmg.N_version != DISK_MODEL_VERSION) {
 	bu_log("rt_nmg_import4:  expected NMG '.g' format version %d, got version %d, aborting.\n",
Index: src/librt/primitives/nmg/nmg_inter.c
===================================================================
--- src/librt/primitives/nmg/nmg_inter.c	(revision 53222)
+++ src/librt/primitives/nmg/nmg_inter.c	(working copy)
@@ -161,7 +161,7 @@
     /* need a self loop */
     lu = nmg_mlv(&fu->l.magic, v, OT_BOOLPLACE);
     if (rt_g.NMG_debug & DEBUG_POLYSECT)
-	bu_log("nmg_make_dualvu is making a self_loop (lu=x%x, vu=x%x) for v=x%x\n", lu, BU_LIST_FIRST(vertexuse, &lu->down_hd), v);
+	bu_log("nmg_make_dualvu is makeing a self_loop (lu=x%x, vu=x%x) for v=x%x\n", lu, BU_LIST_FIRST(vertexuse, &lu->down_hd), v);
     nmg_loop_g(lu->l_p, tol);
     return BU_LIST_FIRST(vertexuse, &lu->down_hd);
 }
@@ -184,7 +184,7 @@
  *
  * While it is true that in most cases the calling routine will know
  * which shell the vu came from, it's cheap to re-determine it here.
- * This "all in one" packaging, which handles both lists automatically
+ * This "all in one" packaging, which handles both lists automaticly
  * is *vastly* superior to the previous version, which pushed 10-20
  * lines of bookkeeping up into *every* place an intersection vu was
  * created.
@@ -515,7 +515,7 @@
  * (3d) point_t for each "index" item, and subscripts the resulting
  * array by the vertices index number.
  * Since additional vertices can be created as the intersection process
- * operates, 2*maxindex items are originally allocated, as a (generous)
+ * operates, 2*maxindex items are originall allocated, as a (generous)
  * upper bound on the amount of intersecting that might happen.
  *
  * In the array, the third double of each projected vertex is set to -1 when
@@ -578,7 +578,7 @@
 
 	/*
 	 * Rotate so that f1's N vector points up +Z.
-	 * This places all 2D calculations in the XY plane.
+	 * This places all 2D calcuations in the XY plane.
 	 * Translate so that f1's centroid becomes the 2D origin.
 	 * Reasoning:  no vertex should be favored by putting it at
 	 * the origin.  The "desirable" floating point space in the
@@ -1607,7 +1607,7 @@
 	/* Intersection is in middle of eu1, which lies on the
 	 * line of intersection being computed, but is outside
 	 * the endpoints of eu2.  There is no point in breaking
-	 * eu1 here -- it does not connect up with anything.
+	 * eu1 here -- it does not connnect up with anything.
 	 */
 	ret = ISECT_NONE;
 	goto topo;
@@ -1796,7 +1796,7 @@
     }
 
     /*
-     * We now know that the edge does not lie +in+ the other face,
+     * We now know that the the edge does not lie +in+ the other face,
      * so it will intersect the face in at most one point.
      * Before looking at the results of the geometric calculation,
      * check the topology.  If the topology says that starting vertex
@@ -1845,7 +1845,7 @@
      * of the other face.  Check to see if the distance to
      * intersection is between limits of the endpoints of
      * this edge(use).
-     * The edge exists over values of 0 <= dist <= 1, i.e.,
+     * The edge exists over values of 0 <= dist <= 1, ie,
      * over values of 0 <= dist_to_plane <= edge_len.
      * The tolerance, an absolute distance, can only be compared
      * to other absolute distances like dist_to_plane & edge_len.
@@ -2363,45 +2363,54 @@
 static void
 nmg_coplanar_face_vertex_fuse(struct faceuse *fu1, struct faceuse *fu2, struct bn_tol *tol)
 {
-    struct bu_ptbl verts;
-    struct faceuse *faces[4];
-    struct loopuse *lu;
-    struct edgeuse *eu;
-    struct vertexuse *vu;
-    int i;
+    struct bu_ptbl fu1_verts;
+    struct bu_ptbl fu2_verts;
+    int i, j;
+    vect_t norm;
 
-    bu_ptbl_init(&verts, 128, "&verts");
+    NMG_CK_FACEUSE(fu1);
+    NMG_CK_FACEUSE(fu2);
+    BN_CK_TOL(tol);
 
-    faces[0] = fu1;
-    faces[1] = fu1->fumate_p;
-    faces[2] = fu2;
-    faces[3] = fu2->fumate_p;
+    NMG_GET_FU_NORMAL(norm, fu1);
 
-    for (i = 0 ; i < 4 ; i++) {
-	NMG_CK_FACEUSE(faces[i]);
-	for (BU_LIST_FOR(lu, loopuse, &faces[i]->lu_hd)) {
-	    NMG_CK_LOOPUSE(lu);
-	    if (BU_LIST_FIRST_MAGIC(&lu->down_hd) == NMG_EDGEUSE_MAGIC) {
-		for (BU_LIST_FOR(eu, edgeuse, &lu->down_hd)) {
-		    NMG_CK_EDGEUSE(eu);
-		    NMG_CK_VERTEXUSE(eu->vu_p);
-		    NMG_CK_VERTEX(eu->vu_p->v_p);
-		    (void)bu_ptbl_ins_unique(&verts, (long *)eu->vu_p->v_p);
-		}
-	    } else if (BU_LIST_FIRST_MAGIC(&lu->down_hd) == NMG_VERTEXUSE_MAGIC) {
-		vu = BU_LIST_FIRST(vertexuse, &lu->down_hd);
-		NMG_CK_VERTEXUSE(vu);
-		NMG_CK_VERTEX(vu->v_p);
-		(void)bu_ptbl_ins_unique(&verts, (long *)vu->v_p);
-	    } else {
-		bu_bomb("nmg_coplanar_face_vertex_fuse(): invalid loopuse");
+    nmg_vertex_tabulate(&fu1_verts, &fu1->l.magic);
+    nmg_vertex_tabulate(&fu2_verts, &fu2->l.magic);
+
+    for (i=0; i<BU_PTBL_END(&fu1_verts); i++) {
+	struct vertex *v1;
+
+	v1 = (struct vertex *)BU_PTBL_GET(&fu1_verts, i);
+
+	for (j=0; j<BU_PTBL_END(&fu2_verts); j++) {
+	    struct vertex *v2;
+	    vect_t diff;
+	    vect_t diff_unit;
+	    fastf_t len_sq, inv_len;
+	    fastf_t dot;
+
+	    v2 = (struct vertex *)BU_PTBL_GET(&fu2_verts, j);
+
+	    if (v1 == v2)
+		continue;
+
+	    VSUB2(diff, v1->vg_p->coord, v2->vg_p->coord);
+	    len_sq = MAGSQ(diff);
+	    if (len_sq > 4.0*tol->dist_sq)
+		continue;
+
+	    inv_len = 1.0 / sqrt(len_sq);
+
+	    VSCALE(diff_unit, diff, inv_len);
+
+	    dot = VDOT(norm, diff_unit);
+	    if (BN_VECT_ARE_PARALLEL(dot, tol)) {
+		/* fuse these two vertices */
+		nmg_jv(v2, v1);
+		break;
 	    }
 	}
     }
-
-    (void)nmg_vertex_fuse((const uint32_t *)&verts, tol);
-
-    bu_ptbl_free(&verts);
 }
 
 
@@ -2423,9 +2432,8 @@
     NMG_CK_FACEUSE(fu2);
     NMG_CK_INTER_STRUCT(is);
 
-    if (UNLIKELY(rt_g.NMG_debug & DEBUG_POLYSECT)) {
+    if (rt_g.NMG_debug & DEBUG_POLYSECT)
 	bu_log("nmg_isect_two)face2p_jra: fu1=x%x, fu2=x%x\n", fu1, fu2);
-    }
 
     nmg_coplanar_face_vertex_fuse(fu1, fu2, &is->tol);
 
@@ -2444,6 +2452,7 @@
 	mag2[i] = MAX_FASTF;
     }
 
+
     is->s1 = fu1->s_p;
     is->s2 = fu2->s_p;
     is->fu1 = fu1;
@@ -2515,8 +2524,8 @@
 		    /* true when both q0 and q1 is within p0->p1 */
 		    hit_count = 2;
 		    /* dist[0] and dist[1] are already the correct values */
-		} else if (((dist[0] > SMALL_FASTF) && (dist[0] < omsff) && (dist[1] < -SMALL_FASTF)) ||
-			   ((dist[0] > SMALL_FASTF) && (dist[0] < omsff) && (dist[1] > opsff))) {
+		} else if (((dist[0] > 0) && (dist[0] < 1) && (dist[1] < 0)) ||
+			   ((dist[0] > 0) && (dist[0] < 1) && (dist[1] > 1))) {
 		    /* true when q0 is within p0->p1 */
 		    hit_count = 1;
 		    dist[1] = MAX_FASTF; /* sanity */
@@ -2529,8 +2538,8 @@
 		    dist[0] = dist[1] = MAX_FASTF; /* sanity */
 		    continue;
 
-		} else if ((ZERO(dist[0]) && EQUAL(dist[1], 1.0)) ||
-			   (ZERO(dist[1]) && EQUAL(dist[0], 1.0))) {
+		} else if ((ZERO(dist[0]) && ZERO(dist[1] - 1.0)) ||
+			   (ZERO(dist[1]) && ZERO(dist[0] - 1.0))) {
 		    /* true when eu1 and eu2 shared the same vertices */
 		    /* eu1 is not cut */
 		    hit_count = 0; /* sanity */
@@ -2538,8 +2547,8 @@
 		    continue;
 		} else if (((dist[0] < -SMALL_FASTF) && ZERO(dist[1])) ||
 			   (ZERO(dist[0]) && (dist[1] < -SMALL_FASTF)) ||
-			   (EQUAL(dist[0], 1.0) && (dist[1] > opsff)) ||
-			   (EQUAL(dist[1], 1.0) && (dist[0] > opsff))) {
+			   (ZERO(dist[0] - 1.0) && (dist[1] > opsff)) ||
+			   (ZERO(dist[1] - 1.0) && (dist[0] > opsff))) {
 		    /* true when eu2 shares one of eu1 vertices and the
 		     * other eu2 vertex is outside p0->p1 (i.e. eu1)
 		     */
@@ -2551,7 +2560,7 @@
 			    (dist[1] < omsff)) ||
 			   ((dist[1] > SMALL_FASTF) &&
 			    (dist[1] < omsff) &&
-			    EQUAL(dist[0], 1.0))) {
+			    ZERO(dist[0] - 1.0))) {
 		    /* true when q1 is within p0->p1 and q0 = p0 or q0 = p1 */
 		    hit_count = 1;
 		    dist[0] = dist[1];
@@ -2560,15 +2569,15 @@
 			   (dist[0] < omsff)) ||
 			  ((dist[0] > SMALL_FASTF) &&
 			   (dist[0] < omsff) &&
-			   EQUAL(dist[1], 1.0))) {
+			   ZERO(dist[1] - 1.0))) {
 		    /* true when q0 is within p0->p1 and q1 = p0 or q1 = p1 */
 		    hit_count = 1;
 		    dist[1] = MAX_FASTF; /* sanity */
 		    /* dist[0] is already the correct value */
 		} else if ((ZERO(dist[0]) && (dist[1] > opsff)) ||
 			   (ZERO(dist[1]) && (dist[0] > opsff)) ||
-			   (EQUAL(dist[0], 1.0) && (dist[1] < -SMALL_FASTF)) ||
-			  ((dist[0] < -SMALL_FASTF) && EQUAL(dist[1], 1.0))) {
+			   (ZERO(dist[0] - 1.0) && (dist[1] < -SMALL_FASTF)) ||
+			  ((dist[0] < -SMALL_FASTF) && ZERO(dist[1] - 1.0))) {
 		    /* true when eu2 shares one of the vertices of eu1 and
 		     * the other vertex in eu2 is on the far side of eu1
 		     * outside eu1 (i.e. p0->p1).
@@ -2584,10 +2593,10 @@
 		    bu_bomb("nmg_isect_two_face2p_jra(): unexpected condition\n");
 		}
 	    } else {
-		if (ZERO(dist[0]) || EQUAL(dist[0], 1.0)) {
+		if (ZERO(dist[0]) || ZERO(dist[0] - 1.0)) {
 		    /* eu1 was hit on a vertex, nothing to cut */
 		    continue;
-		} else if (UNLIKELY((dist[0] < -SMALL_FASTF) || (dist[0] > opsff))) {
+		} else if ((dist[0] < -SMALL_FASTF) || (dist[0] > opsff)) {
 		    bu_bomb("nmg_isect_two_face2p_jra(): dist[0] not within 0-1\n");
 		} else {
 		    hit_count = 1;
@@ -2597,39 +2606,41 @@
 	    for (hit_no=0; hit_no < hit_count; hit_no++) {
 		struct edgeuse *new_eu;
 		struct vertex *hitv;
-		struct vertexuse *hit_vu;
+		struct vertexuse *hit_vu = NULL;
 
 		if (dist[hit_no] < -SMALL_FASTF || dist[hit_no] > opsff)
 		    continue;
 
 		hitv = (struct vertex *)NULL;
+
 		if (ZERO(dist[hit_no])) {
-		    hitv = eu1->vu_p->v_p;
+		    hit_vu = eu1->vu_p;
+		    hitv = hit_vu->v_p;
 		    VMOVE(hit_pt, hitv->vg_p->coord);
-		} else if (EQUAL(dist[hit_no], 1.0)) {
-		    hitv = eu1->eumate_p->vu_p->v_p;
+		} else if (ZERO(dist[hit_no] - 1.0)) {
+		    hit_vu = eu1->eumate_p->vu_p;
+		    hitv = hit_vu->v_p;
 		    VMOVE(hit_pt, hitv->vg_p->coord);
-		} else {
+		} else
 		    VJOIN1(hit_pt, vg1a->coord, dist[hit_no], vt1_3d)
-		    if ((hit_vu = nmg_find_pt_in_face(fu2, hit_pt, &is->tol))) {
-			hitv = hit_vu->v_p;
-		    } else if ((hit_vu = nmg_find_pt_in_face(fu1, hit_pt, &is->tol))) {
-			hitv = hit_vu->v_p;
-		    } else {
-			hitv = nmg_find_pt_in_model(nmg_find_model(&fu1->l.magic), hit_pt, &is->tol);
-		    }
-		    if (UNLIKELY(!hitv && (code == 0))) {
-			bu_log("dist[0] = %f dist[1] = %f hit_no = %d\n", dist[0], dist[1], hit_no);
-			bu_bomb("nmg_isect_two_face2p_jra(): Can not find vertexuse");
-		    }
+
+			if (rt_g.NMG_debug & DEBUG_POLYSECT)
+			    bu_log("eus x%x and x%x intersect #%d at (%f %f %f)\n",
+				   eu1, eu2, hit_no, V3ARGS(hit_pt));
+
+		if (!hit_vu)
+		    hit_vu = nmg_find_pt_in_face(fu2, hit_pt, &is->tol);
+
+		if (!hit_vu)
+		    hitv = nmg_find_pt_in_model(nmg_find_model(&fu1->l.magic), hit_pt, &is->tol);
+#if 1
+		if (!hit_vu && (code == 0)) {
+		    bu_log("dist[0] = %f dist[1] = %f hit_no = %d\n", dist[0], dist[1], hit_no);
+		    bu_bomb("nmg_isect_two_face2p_jra(): why can we not find a vertexuse\n");
 		}
-		if (UNLIKELY(rt_g.NMG_debug & DEBUG_POLYSECT)) {
-		    bu_log("eus x%x and x%x intersect #%d at (%f %f %f)\n",
-			   eu1, eu2, hit_no, V3ARGS(hit_pt));
-		}
-		if (UNLIKELY(rt_g.NMG_debug & DEBUG_POLYSECT && hitv)) {
+#endif
+		if (rt_g.NMG_debug & DEBUG_POLYSECT && hitv)
 		    bu_log("Found vertex (x%x) at hit_pt\n", hitv);
-		}
 
 		if (hitv != eu1->vu_p->v_p && hitv != eu1->eumate_p->vu_p->v_p) {
 		    struct edgeuse *next_eu, *prev_eu;
@@ -2638,9 +2649,8 @@
 		    prev_eu = BU_LIST_PPREV_CIRC(edgeuse, &eu1->l);
 
 		    if (hitv != prev_eu->vu_p->v_p && hitv != next_eu->eumate_p->vu_p->v_p) {
-			if (UNLIKELY(rt_g.NMG_debug & DEBUG_POLYSECT)) {
+			if (rt_g.NMG_debug & DEBUG_POLYSECT)
 			    bu_log("Splitting eu1 x%x\n", eu1);
-			}
 			new_eu = nmg_esplit(hitv, eu1, 1);
 			hitv = new_eu->vu_p->v_p;
 			if (!hitv->vg_p)
@@ -2656,7 +2666,7 @@
 		    prev_eu = BU_LIST_PPREV_CIRC(edgeuse, &eu2->l);
 
 		    if (hitv != prev_eu->vu_p->v_p && hitv != next_eu->eumate_p->vu_p->v_p) {
-			if (UNLIKELY(rt_g.NMG_debug & DEBUG_POLYSECT)) {
+			if (rt_g.NMG_debug & DEBUG_POLYSECT) {
 			    vect_t tmp1, tmp2;
 			    VSUB2(tmp1, hit_pt, eu2->vu_p->v_p->vg_p->coord)
 				VSUB2(tmp2, hit_pt, eu2->eumate_p->vu_p->v_p->vg_p->coord)
@@ -2703,9 +2713,8 @@
 				       (char *)NULL, 0, 0, &is->tol);
 
 	if (class == NMG_CLASS_AinB) {
-	    if (UNLIKELY(rt_g.NMG_debug & DEBUG_POLYSECT)) {
+	    if (rt_g.NMG_debug & DEBUG_POLYSECT)
 		bu_log("Making dualvu of vertex x%x in fu2 x%x\n", v, fu2);
-	    }
 	    (void)nmg_make_dualvu(v, fu2, &is->tol);
 	}
     }
@@ -2729,9 +2738,8 @@
 				       (char *)NULL, 0, 0, &is->tol);
 
 	if (class == NMG_CLASS_AinB) {
-	    if (UNLIKELY(rt_g.NMG_debug & DEBUG_POLYSECT)) {
+	    if (rt_g.NMG_debug & DEBUG_POLYSECT)
 		bu_log("Making dualvu of vertex x%x in fu1 x%x\n", v, fu1);
-	    }
 	    (void)nmg_make_dualvu(v, fu1, &is->tol);
 	}
     }
@@ -2766,9 +2774,8 @@
 		!nmg_find_v_in_face(v2, fu2))
 		continue;
 
-	    if (UNLIKELY(rt_g.NMG_debug & DEBUG_POLYSECT)) {
+	    if (rt_g.NMG_debug & DEBUG_POLYSECT)
 		bu_log("Making EU x%x an intersect line for face cutting\n", eu);
-	    }
 
 	    for (BU_LIST_FOR(vu, vertexuse, &v1->vu_hd)) {
 		struct faceuse *fu;
@@ -2789,9 +2796,8 @@
 	    }
 
 	    /* Now do face cutting */
-	    if (UNLIKELY(rt_g.NMG_debug & DEBUG_POLYSECT)) {
+	    if (rt_g.NMG_debug & DEBUG_POLYSECT)
 		bu_log("Calling face cutter for fu2 x%x\n", fu2);
-	    }
 	    nmg_fcut_face_2d(is->l2, is->mag2, fu2, fu1, &is->tol);
 
 	    bu_ptbl_reset(is->l1);
@@ -2822,9 +2828,8 @@
 		!nmg_find_v_in_face(v2, fu1))
 		continue;
 
-	    if (UNLIKELY(rt_g.NMG_debug & DEBUG_POLYSECT)) {
+	    if (rt_g.NMG_debug & DEBUG_POLYSECT)
 		bu_log("Making EU x%x an intersect line for face cutting\n", eu);
-	    }
 
 	    for (BU_LIST_FOR(vu, vertexuse, &v1->vu_hd)) {
 		struct faceuse *fu;
@@ -2845,9 +2850,8 @@
 	    }
 
 	    /* Now do face cutting */
-	    if (UNLIKELY(rt_g.NMG_debug & DEBUG_POLYSECT)) {
+	    if (rt_g.NMG_debug & DEBUG_POLYSECT)
 		bu_log("Calling face cutter for fu1 x%x\n", fu1);
-	    }
 	    nmg_fcut_face_2d(is->l1, is->mag1, fu1, fu2, &is->tol);
 
 	    bu_ptbl_reset(is->l1);
@@ -2924,7 +2928,7 @@
  * XXX and then intersect them with the other face.
  * XXX loopuses can come and go as loops get cutjoin'ed, but at this
  * XXX stage edgeuses are created, but never deleted.
- * XXX This way, the process should converge in 2 iterations, rather than N.
+ * XXX This way, the process should converge in 2 interations, rather than N.
  */
 
     /* For every edge in f1, intersect with f2, incl. cutjoin */
@@ -3211,7 +3215,7 @@
 
 /**
  *
- * Given two pointer tables filled with edgeuses representing two different
+ * Given two pointer tables filled with edgeuses representing two differentt
  * edge geometry lines, see if there is a common vertex of intersection.
  * If so, enlist the intersection.
  *
@@ -3702,7 +3706,7 @@
     VMOVE(e2_max_pt, vg2a->coord);
     VMAX(e2_max_pt, vg2b->coord);
 
-    if (V3RPP_DISJOINT_TOL(e1_min_pt, e1_max_pt, e2_min_pt, e2_max_pt, tol->dist)) {
+    if (!V3RPP_OVERLAP_TOL(e1_min_pt, e1_max_pt, e2_min_pt, e2_max_pt, tol->dist)) {
 	return;
     }
 
@@ -3801,7 +3805,7 @@
     fastf_t *inter_dist;
     int i;
 
-    if (UNLIKELY(rt_g.NMG_debug & DEBUG_POLYSECT))
+    if (rt_g.NMG_debug & DEBUG_POLYSECT)
 	bu_log("nmg_isect_eu_fu: eu=x%x, fu=x%x START\n", eu, fu);
 
     NMG_CK_INTER_STRUCT(is);
@@ -3809,14 +3813,14 @@
     NMG_CK_EDGEUSE(eu);
     BU_CK_PTBL(verts);
 
-    if (UNLIKELY(nmg_find_fu_of_eu(eu) == fu)) {
+    if (nmg_find_fu_of_eu(eu) == fu) {
 	bu_log("nmg_isect_eu_fu() called with eu (x%x) from its own fu (x%x)\n", eu, fu);
 	bu_bomb("nmg_isect_eu_fu() called with eu from its own fu");
     }
 
     m = nmg_find_model(&fu->l.magic);
     NMG_CK_MODEL(m);
-    if (UNLIKELY(nmg_find_model(&eu->l.magic) != m)) {
+    if (nmg_find_model(&eu->l.magic) != m) {
 	bu_log("nmg_isect_eu_fu() called with EU (x%x) from model (x%x)\n", eu, nmg_find_model(&eu->l.magic));
 	bu_log("\tand FU (x%x) from model (x%x)\n", fu, m);
 	bu_bomb("nmg_isect_eu_fu() called with EU and FU from different models");
@@ -3830,8 +3834,8 @@
     VSUB2(dir, vg2->coord, vg1->coord);
     VMOVE(edir, dir);
     eu_len = MAGNITUDE(dir);
-    if (eu_len < is->tol.dist) {
-	if (UNLIKELY(rt_g.NMG_debug & DEBUG_POLYSECT))
+    if (eu_len < is->tol.dist || eu_len <= SMALL_FASTF) {
+	if (rt_g.NMG_debug & DEBUG_POLYSECT)
 	    bu_log("\tnmg_isec_eu_fu: 0 length edge\n");
 	return;
     }
@@ -3842,14 +3846,14 @@
     NMG_GET_FU_PLANE(pl, fu);
     /* check if edge line intersects plane of fu */
     if (bn_isect_line3_plane(&dist, vg1->coord, dir, pl, &is->tol) < 1) {
-	if (UNLIKELY(rt_g.NMG_debug & DEBUG_POLYSECT))
+	if (rt_g.NMG_debug & DEBUG_POLYSECT)
 	    bu_log("\tnmg_isec_eu_fu: no intersection\n");
 	return;
     }
 
     VJOIN1(hit_pt, vg1->coord, dist, dir);
 
-    if (UNLIKELY(rt_g.NMG_debug & DEBUG_POLYSECT))
+    if (rt_g.NMG_debug & DEBUG_POLYSECT)
 	bu_log("\tintersection point at (%g %g %g)\n", V3ARGS(hit_pt));
 
     /* create a list of intersection vertices */
@@ -3883,14 +3887,16 @@
 	int class;
 	fastf_t dist_to_plane;
 
-	if (UNLIKELY(rt_g.NMG_debug & DEBUG_POLYSECT))
+	if (rt_g.NMG_debug & DEBUG_POLYSECT)
 	    bu_log("\tNo intersection points found\n");
 
 	/* check if EU endpoints are within tolerance of FU
 	 * If so, the endpoint is the intersection and nothing to do
 	 */
-	dist_to_plane = fabs(DIST_PT_PLANE(vg1->coord, pl));
-	if (dist_to_plane < is->tol.dist) {
+	dist_to_plane = DIST_PT_PLANE(vg1->coord, pl);
+	if (dist_to_plane < 0.0)
+	    dist_to_plane = (-dist_to_plane);
+	if (dist_to_plane <= is->tol.dist) {
 	    /* check if hit point is within fu */
 	    class = nmg_class_pt_fu_except(vg1->coord, fu, (struct loopuse *)NULL,
 					   0, 0, (char *)NULL, 0, 0, &is->tol);
@@ -3907,8 +3913,10 @@
 	    goto out;
 	}
 
-	dist_to_plane = fabs(DIST_PT_PLANE(vg2->coord, pl));
-	if (dist_to_plane < is->tol.dist) {
+	dist_to_plane = DIST_PT_PLANE(vg2->coord, pl);
+	if (dist_to_plane < 0.0)
+	    dist_to_plane = (-dist_to_plane);
+	if (dist_to_plane <= is->tol.dist) {
 	    /* check if hit point is within fu */
 	    class = nmg_class_pt_fu_except(vg2->coord, fu, (struct loopuse *)NULL,
 					   0, 0, (char *)NULL, 0, 0, &is->tol);
@@ -3929,21 +3937,21 @@
 
 	/* make sure intersection is within limits of eu */
 	if (dist < (-is->tol.dist) || dist > eu_len+is->tol.dist) {
-	    if (UNLIKELY(rt_g.NMG_debug & DEBUG_POLYSECT))
+	    if (rt_g.NMG_debug & DEBUG_POLYSECT)
 		bu_log("\tnmg_isec_eu_fu: intersection beyond ends of EU\n");
 	    goto out;
 	}
 
 	/* check if hit_point is within tolerance of an end of eu */
-	if (bn_pt3_pt3_equal(hit_pt, vg1->coord, &is->tol)) {
+	if (VDIST_SQ(hit_pt, vg1->coord) <= is->tol.dist_sq) {
 	    v = eu->vu_p->v_p;
 	    VMOVE(hit_pt, vg1->coord);
-	} else if (bn_pt3_pt3_equal(hit_pt, vg2->coord, &is->tol)) {
+	} else if (VDIST_SQ(hit_pt, vg2->coord) <= is->tol.dist_sq) {
 	    v = eu->eumate_p->vu_p->v_p;
 	    VMOVE(hit_pt, vg2->coord);
 	}
 
-	if (UNLIKELY(rt_g.NMG_debug & DEBUG_POLYSECT)) {
+	if (rt_g.NMG_debug & DEBUG_POLYSECT) {
 	    bu_log("\tHit point is not within tolerance of eu endpoints\n");
 	    bu_log("\t\thit_pt=(%g %g %g), eu=(%g %g %g)<->(%g %g %g)\n",
 		   V3ARGS(hit_pt), V3ARGS(vg1->coord), V3ARGS(vg2->coord));
@@ -3960,13 +3968,13 @@
 	    if (!v)
 		v = nmg_find_pt_in_model(m, hit_pt, &is->tol);
 	    if (v != eu->vu_p->v_p && v != eu->eumate_p->vu_p->v_p) {
-		if (UNLIKELY(rt_g.NMG_debug & DEBUG_POLYSECT))
+		if (rt_g.NMG_debug & DEBUG_POLYSECT)
 		    bu_log("\tsplitting eu (x%x) at hit_pt (v=x%x)\n", eu, v);
 
 		new_eu = nmg_esplit(v, eu, 1);
 		if (!v) {
 		    v = new_eu->vu_p->v_p;
-		    if (UNLIKELY(rt_g.NMG_debug & DEBUG_POLYSECT))
+		    if (rt_g.NMG_debug & DEBUG_POLYSECT)
 			bu_log("\tnew vertex at hit point is x%x\n", v);
 		    nmg_vertex_gv(v, hit_pt);
 		}
@@ -3990,7 +3998,7 @@
 	v = (struct vertex *)BU_PTBL_GET(&inters, 0);
 	NMG_CK_VERTEX(v);
 
-	if (UNLIKELY(rt_g.NMG_debug & DEBUG_POLYSECT))
+	if (rt_g.NMG_debug & DEBUG_POLYSECT)
 	    bu_log("Only one intersect vertex (x%x), just split all EU's at (x%x)\n", v, eu);
 
 	if (v == eu->vu_p->v_p || v == eu->eumate_p->vu_p->v_p)
@@ -4006,7 +4014,7 @@
     inter_dist = (fastf_t *)bu_calloc(BU_PTBL_END(&inters), sizeof(fastf_t),
 				      "nmg_isect_eu_fu: inter_dist");
 
-    if (UNLIKELY(rt_g.NMG_debug & DEBUG_POLYSECT))
+    if (rt_g.NMG_debug & DEBUG_POLYSECT)
 	bu_log("%d intersect vertices along eu (x%x)\n", BU_PTBL_END(&inters), eu);
 
     for (i=0; i<BU_PTBL_END(&inters); i++) {
@@ -4020,13 +4028,13 @@
 	NMG_CK_VERTEX_G(vg);
 
 	VSUB2(diff, vg->coord, vg1->coord);
-	if (UNLIKELY(VDOT(diff, dir) < -SMALL_FASTF)) {
+	if (VDOT(diff, dir) < -SMALL_FASTF) {
 	    bu_bomb("nmg_isect_eu_fu: intersection point not on eu\n");
 	}
 	inter_dist[i] = MAGSQ(diff);
     }
 
-    if (UNLIKELY(rt_g.NMG_debug & DEBUG_POLYSECT)) {
+    if (rt_g.NMG_debug & DEBUG_POLYSECT) {
 	bu_log("Intersect vertices along eu x%x:\n", eu);
 	for (i=0; i<BU_PTBL_END(&inters); i++)
 	    bu_log("%d x%x %g\n", i+1, BU_PTBL_GET(&inters, i), inter_dist[i]);
@@ -4054,7 +4062,7 @@
 	NMG_CK_VERTEX(v);
 
 	if (v != eu->vu_p->v_p && v != eu->eumate_p->vu_p->v_p) {
-	    if (UNLIKELY(rt_g.NMG_debug & DEBUG_POLYSECT))
+	    if (rt_g.NMG_debug & DEBUG_POLYSECT)
 		bu_log("Breaking edges at vertex #%d, dist=%g, v=x%x\n", i+1, inter_dist[i], v);
 	    (void)nmg_break_all_es_on_v(&fu->l.magic, v, &is->tol);
 	    (void)nmg_break_all_es_on_v(&eu->l.magic, v, &is->tol);
@@ -4068,7 +4076,7 @@
 out:
     bu_ptbl_free(&inters);
 
-    if (UNLIKELY(rt_g.NMG_debug & DEBUG_POLYSECT))
+    if (rt_g.NMG_debug & DEBUG_POLYSECT)
 	bu_log("nmg_isect_eu_fu: eu=x%x, fu=x%x END\n", eu, fu);
 
 }
@@ -4614,7 +4622,7 @@
 		 * attempt to get the correct ordering of vertices
 		 * on the intersection list, since using the
 		 * actual distance can get them reversed when
-		 * a VU is chosen over the actual intersection
+		 * a VU is chosen over the actual interection
 		 * point.
 		 */
 		nmg_enlist_vu(is, vu1a, 0, dist[0]);
@@ -6691,7 +6699,7 @@
  * Check if two faceuses can be intersected normally, by looking at the line
  * of intersection and determining if the vertices from each face are all
  * above the other face on one side of the intersection line and below it
- * on the other side of the intersection line.
+ * on the other side of the interection line.
  *
  * return:
  * 1 - faceuses meet criteria and can be intersected normally
@@ -6778,7 +6786,7 @@
 	    else
 		on_left++;
 	} else {
-	    /* right of intersection line */
+	    /* right of intersction line */
 	    if (dist > tol->dist)
 		above_right++;
 	    else if (dist < (-tol->dist))
@@ -6834,7 +6842,7 @@
 	    else
 		on_left++;
 	} else {
-	    /* right of intersection line */
+	    /* right of intersction line */
 	    if (dist > tol->dist)
 		above_right++;
 	    else if (dist < (-tol->dist))
@@ -6972,7 +6980,7 @@
 	status = (-1);
     }
 
-    if (V3RPP_DISJOINT_TOL(f2->min_pt, f2->max_pt,
+    if (!V3RPP_OVERLAP_TOL(f2->min_pt, f2->max_pt,
 			   f1->min_pt, f1->max_pt, bs.tol.dist)) {
 	return;
     }
@@ -7422,24 +7430,23 @@
 void
 nmg_crackshells(struct shell *s1, struct shell *s2, const struct bn_tol *tol)
 {
-    struct bu_ptbl faces1, faces2;
     struct bu_ptbl vert_list1, vert_list2;
     struct nmg_inter_struct is;
-    struct edgeuse *eu1, *eu2;
-    struct loopuse *lu1, *lu2;
+    struct shell_a *sa1, *sa2;
+    struct face *f1, *f2;
     struct faceuse *fu1, *fu2;
-    struct face *fp1, *fp2;
-    struct shell_a *sa1, *sa2;
-    size_t i, j;
+    struct loopuse *lu1;
+    struct loopuse *lu2;
+    struct edgeuse *eu1;
+    struct edgeuse *eu2;
+    struct model *m;
+    char *flags, *tmp;
+    size_t flag_len, old_flag_len;
     point_t isect_min_pt, isect_max_pt;
 
-    if (UNLIKELY(rt_g.NMG_debug & DEBUG_POLYSECT)) {
+    if (rt_g.NMG_debug & DEBUG_POLYSECT)
 	bu_log("nmg_crackshells(s1=x%x, s2=x%x)\n", s1, s2);
-    }
 
-    /* initialize 'is' structure */
-    memset((void *)&is, 0, sizeof(struct nmg_inter_struct));
-
     BN_CK_TOL(tol);
     NMG_CK_SHELL(s1);
     sa1 = s1->sa_p;
@@ -7449,25 +7456,25 @@
     sa2 = s2->sa_p;
     NMG_CK_SHELL_A(sa2);
 
-    if (UNLIKELY(s1->r_p->m_p != s2->r_p->m_p)) {
-	bu_bomb("nmg_crackshells(): shells are not in the same model");
+    if (s1->r_p->m_p != s2->r_p->m_p) {
+	bu_bomb("nmg_crackshells(): shells are not in the same model\n");
     }
 
-    if (UNLIKELY(rt_g.NMG_debug & DEBUG_VERIFY)) {
+    NMG_CK_REGION(s1->r_p);
+    NMG_CK_REGION(s2->r_p);
+    m = s1->r_p->m_p;
+    NMG_CK_MODEL(m);
+
+    if (rt_g.NMG_debug & DEBUG_VERIFY) {
 	nmg_ck_vs_in_region(s1->r_p, tol);
 	nmg_ck_vs_in_region(s2->r_p, tol);
     }
 
-    /* test if shell s1 and s2 disjoint by at least distance tolerance */
-    if (V3RPP_DISJOINT_TOL(sa1->min_pt, sa1->max_pt, sa2->min_pt, sa2->max_pt, tol->dist)) {
+    /* test if shell s1 and s2 overlap by at least distance tolerance */
+    if (!V3RPP_OVERLAP_TOL(sa1->min_pt, sa1->max_pt, sa2->min_pt, sa2->max_pt, tol->dist)) {
 	return;
     }
 
-    bu_ptbl_init(&faces1, 64, "faces1 buffer");
-    bu_ptbl_init(&faces2, 64, "faces2 buffer");
-    nmg_face_tabulate(&faces1, &s1->l.magic);
-    nmg_face_tabulate(&faces2, &s2->l.magic);
-
     /* create a new bounding box which is the intersection
      * of the shell s1 and s2 bounding boxes
      */
@@ -7479,47 +7486,85 @@
     /* All the non-face/face isect subroutines need are tol, l1, and l2 */
     is.magic = NMG_INTER_STRUCT_MAGIC;
     is.vert2d = (fastf_t *)NULL;
-    is.tol = *tol; /* struct copy */
+    is.tol = *tol;		/* struct copy */
     is.l1 = &vert_list1;
     is.l2 = &vert_list2;
     is.s1 = s1;
     is.s2 = s2;
     is.fu1 = (struct faceuse *)NULL;
     is.fu2 = (struct faceuse *)NULL;
-
     (void)bu_ptbl_init(&vert_list1, 64, "&vert_list1");
     (void)bu_ptbl_init(&vert_list2, 64, "&vert_list2");
 
-    if (UNLIKELY(rt_g.NMG_debug & DEBUG_VERIFY)) {
+    if (rt_g.NMG_debug & DEBUG_VERIFY) {
 	nmg_vshell(&s1->r_p->s_hd, s1->r_p);
 	nmg_vshell(&s2->r_p->s_hd, s2->r_p);
     }
 
-    for (i = 0; i < (size_t)BU_PTBL_END(&faces1); i++) {
-	fp1 = (struct face *)BU_PTBL_GET(&faces1, i);
-	NMG_CK_FACE(fp1);
-	fu1 = fp1->fu_p;
+    flag_len = m->maxindex * 2;
+    flags = (char *)bu_calloc(flag_len, sizeof(char), "nmg_crackshells flags[]");
+
+    /*
+     * Check each of the faces in shell 1 to see
+     * if they overlap the extent of shell 2
+     */
+    for (BU_LIST_FOR(fu1, faceuse, &s1->fu_hd)) {
+	if ((size_t)(m->maxindex) >= flag_len) {
+	    old_flag_len = flag_len;
+	    flag_len *= 2;
+	    tmp = (char *)bu_realloc(flags, flag_len * sizeof(char), "realloc nmg_crackshells flags[]");
+	    flags = tmp;
+	    /* initialize new space */
+	    memset((char *)(flags + (old_flag_len * sizeof(char))), 0, (flag_len - old_flag_len) * sizeof(char));
+	}
 	NMG_CK_FACEUSE(fu1);
+	f1 = fu1->f_p;
+	NMG_CK_FACE(f1);
 
-	if (fu1->orientation == OT_OPPOSITE) {
-	    fu1 = fu1->fumate_p;
-	}
-	if (V3RPP_DISJOINT_TOL(fp1->min_pt, fp1->max_pt, isect_min_pt, isect_max_pt, tol->dist)) {
+	if (fu1->orientation != OT_SAME) continue;
+	if (NMG_INDEX_IS_SET(flags, f1)) continue;
+	NMG_CK_FACE_G_PLANE(f1->g.plane_p);
+
+	/* test if the face f1 bounding box and isect bounding box
+	 * by at least distance tolerance
+	 */
+	if (!V3RPP_OVERLAP_TOL(f1->min_pt, f1->max_pt, isect_min_pt, isect_max_pt, tol->dist)) {
+	    NMG_INDEX_SET(flags, f1);
 	    continue;
 	}
 
-	for (j = 0; j < (size_t)BU_PTBL_END(&faces2); j++) {
-	    fp2 = (struct face *)BU_PTBL_GET(&faces2, j);
-	    NMG_CK_FACE(fp2);
-	    fu2 = fp2->fu_p;
+	is.fu1 = fu1;
+
+	/*
+	 * Now, check the face f1 from shell 1
+	 * against each of the faces of shell 2
+	 */
+	for (BU_LIST_FOR(fu2, faceuse, &s2->fu_hd)) {
+	    if ((size_t)(m->maxindex) >= flag_len) {
+		old_flag_len = flag_len;
+		flag_len *= 2;
+		tmp = (char *)bu_realloc(flags, flag_len * sizeof(char), "realloc nmg_crackshells flags[]");
+		flags = tmp;
+		/* initialize new space */
+		memset((char *)(flags + (old_flag_len * sizeof(char))), 0, (flag_len - old_flag_len) * sizeof(char));
+	    }
 	    NMG_CK_FACEUSE(fu2);
+	    NMG_CK_FACE(fu2->f_p);
 
-	    if (fu2->orientation == OT_OPPOSITE) {
-		fu2 = fu2->fumate_p;
-	    }
-	    if (V3RPP_DISJOINT_TOL(fp2->min_pt, fp2->max_pt, isect_min_pt, isect_max_pt, tol->dist)) {
+	    f2 = fu2->f_p;
+	    NMG_CK_FACE(f2);
+
+	    if (fu2->orientation != OT_SAME) continue;
+	    if (NMG_INDEX_IS_SET(flags, f2)) continue;
+
+	    /* test if the face f2 bounding box and isect bounding box
+	     * overlap by at least distance tolerance
+	     */
+	    if (!V3RPP_OVERLAP_TOL(f2->min_pt, f2->max_pt, isect_min_pt, isect_max_pt, tol->dist)) {
+		NMG_INDEX_SET(flags, f2);
 		continue;
 	    }
+
 	    nmg_isect_two_generic_faces(fu1, fu2, tol);
 	}
 
@@ -7534,8 +7579,6 @@
 	 * If coplanar, need to cut face.
 	 * If non-coplanar, can only hit at one point.
 	 */
-
-	is.fu1 = fu1;
 	is.fu2 = (struct faceuse *)NULL;
 
 	/* Check f1 from s1 against wire loops of s2 */
@@ -7544,29 +7587,30 @@
 	    /* Not interested in vert_list here */
 	    (void)nmg_isect_wireloop3p_face3p(&is, lu2, fu1);
 	}
+
 	/* Check f1 from s1 against wire edges of s2 */
 	for (BU_LIST_FOR(eu2, edgeuse, &s2->eu_hd)) {
 	    NMG_CK_EDGEUSE(eu2);
+
 	    nmg_isect_wireedge3p_face3p(&is, eu2, fu1);
 	}
+
 	/* Check f1 from s1 against lone vert of s2 */
 	if (s2->vu_p) {
 	    nmg_isect_3vertex_3face(&is, s2->vu_p, fu1);
 	}
 
-	if (UNLIKELY(rt_g.NMG_debug & DEBUG_VERIFY)) {
+	NMG_INDEX_SET(flags, f1);
+
+	if (rt_g.NMG_debug & DEBUG_VERIFY) {
 	    nmg_vshell(&s1->r_p->s_hd, s1->r_p);
 	    nmg_vshell(&s2->r_p->s_hd, s2->r_p);
 	}
     }
 
-    bu_ptbl_free(&faces1);
-    bu_ptbl_free(&faces2);
-
+    /* Check each wire loop of shell 1 against non-faces of shell 2. */
     is.fu1 = (struct faceuse *)NULL;
     is.fu2 = (struct faceuse *)NULL;
-
-    /* Check each wire loop of shell 1 against non-faces of shell 2. */
     for (BU_LIST_FOR(lu1, loopuse, &s1->lu_hd)) {
 	NMG_CK_LOOPUSE(lu1);
 	/* XXX Can there be lone-vertex loops here? (yes, need an intersector) */
@@ -7613,18 +7657,28 @@
 	/* Check vert of s1 against vert of s2 */
 	/* Unnecessary: already done by vertex fuser */
     }
+    if ((size_t)(m->maxindex) >= flag_len) {
+	old_flag_len = flag_len;
+	flag_len *= 2;
+	tmp = (char *)bu_realloc(flags, flag_len * sizeof(char), "realloc nmg_crackshells flags[]");
+	flags = tmp;
+	/* initialize new space */
+	memset((char *)(flags + (old_flag_len * sizeof(char))), 0, (flag_len - old_flag_len) * sizeof(char));
+    }
 
     /* Release storage from bogus isect line */
     (void)bu_ptbl_free(&vert_list1);
     (void)bu_ptbl_free(&vert_list2);
 
+    bu_free((char *)flags, "nmg_crackshells flags[]");
+
     /* Eliminate stray vertices that were added along edges in this step */
     (void)nmg_unbreak_region_edges(&s1->l.magic);
     (void)nmg_unbreak_region_edges(&s2->l.magic);
 
     nmg_isect2d_cleanup(&is);
 
-    if (UNLIKELY(rt_g.NMG_debug & DEBUG_VERIFY)) {
+    if (rt_g.NMG_debug & DEBUG_VERIFY) {
 	nmg_vshell(&s1->r_p->s_hd, s1->r_p);
 	nmg_vshell(&s2->r_p->s_hd, s2->r_p);
 	nmg_ck_vs_in_region(s1->r_p, tol);
@@ -7759,7 +7813,7 @@
 	for (BU_LIST_FOR(eu, edgeuse, &lu->down_hd)) {
 	    NMG_CK_EDGEUSE(eu);
 	    cnt++;
-	    dist = fabs(DIST_PT_PLANE(eu->vu_p->v_p->vg_p->coord, f2_pl));
+	    dist = DIST_PT_PLANE(eu->vu_p->v_p->vg_p->coord, f2_pl);
 	    tot_dist += dist;
 	    /* the current distance is included in the average
 	     * that the current distance is compared against
@@ -7790,7 +7844,7 @@
 	    for (BU_LIST_FOR(eu, edgeuse, &lu->down_hd)) {
 		NMG_CK_EDGEUSE(eu);
 		cnt++;
-		dist = fabs(DIST_PT_PLANE(eu->vu_p->v_p->vg_p->coord, f1_pl));
+		dist = DIST_PT_PLANE(eu->vu_p->v_p->vg_p->coord, f1_pl);
 		tot_dist += dist;
 		/* the current distance is included in the average
 		 * that the current distance is compared against
@@ -7809,7 +7863,7 @@
     if (!nmg_ck_fu_verts(fu2, f1, tol) && !nmg_ck_fu_verts(fu1, f2, tol) &&
 	NEAR_ZERO(fabs(f1_pl[W] - f2_pl[W]), tol->dist)) {
 	/* true when fu1 and fu2 are coplanar, i.e. all vertices
-	 * of faceuse (fu1) are within distance tolerance of
+	 * of faceuse (fu1) are within distance tolarance of
 	 * face (f2) and vice-versa.
 	 */
 	coplanar = 1;
@@ -7872,8 +7926,15 @@
     abs_dir[Y] = fabs(dir[Y]);
     abs_dir[Z] = fabs(dir[Z]);
 
-    /* Clamp abs_dir vector to zero if within tolerance of zero. */
-    VCLAMP(abs_dir);
+    if (ZERO(abs_dir[X])) {
+	abs_dir[X] = 0.0;
+    }
+    if (ZERO(abs_dir[Y])) {
+	abs_dir[Y] = 0.0;
+    }
+    if (ZERO(abs_dir[Z])) {
+	abs_dir[Z] = 0.0;
+    }
 
     if (abs_dir[X] >= abs_dir[Y]) {
 	if (abs_dir[X] >= abs_dir[Z]) {
Index: src/librt/primitives/nmg/nmg_manif.c
===================================================================
--- src/librt/primitives/nmg/nmg_manif.c	(revision 53222)
+++ src/librt/primitives/nmg/nmg_manif.c	(working copy)
@@ -374,7 +374,7 @@
 
     /* all the faces painted with "interior" paint are 2manifolds
      * those faces still painted with "exterior" paint are
-     * 3manifolds, i.e. part of the enclosing surface
+     * 3manifolds, ie. part of the enclosing surface
      */
     for (BU_LIST_FOR(fu_p, faceuse, &sp->fu_hd)) {
 	BU_LIST_LINK_CHECK(&fu_p->l);
Index: src/librt/primitives/nmg/nmg_info.c
===================================================================
--- src/librt/primitives/nmg/nmg_info.c	(revision 53222)
+++ src/librt/primitives/nmg/nmg_info.c	(working copy)
@@ -63,7 +63,7 @@
 
  top:
     if (magic_p == NULL) {
-	bu_log("nmg_find_model(x%x) encountered null pointer\n",
+	bu_log("nmg_find_model(x%x) enountered null pointer\n",
 	       magic_p_arg);
 	bu_bomb("nmg_find_model() null pointer\n");
 	/* NOTREACHED */
@@ -125,7 +125,7 @@
 {
  top:
     if (magic_p == NULL) {
-	bu_log("nmg_find_shell(x%x) encountered null pointer\n", magic_p);
+	bu_log("nmg_find_shell(x%x) enountered null pointer\n", magic_p);
 	bu_bomb("nmg_find_shell() null pointer\n");
     }
 
@@ -601,7 +601,7 @@
  * return true.
  * This is useful for detecting "accordian pleats"
  * unexpectedly showing up in a loop.
- * Derived from nmg_split_touchingloops().
+ * Derrived from nmg_split_touchingloops().
  *
  * Returns -
  * vu Yes, the loop touches itself at least once, at this vu.
@@ -1230,7 +1230,7 @@
 /**
  * N M G _ F I N D _ E _ N E A R E S T _ P T 2
  *
- * A geometric search routine to find the edge that is nearest to
+ * A geometric search routine to find the edge that is neaest to
  * the given point, when all edges are projected into 2D using
  * the matrix 'mat'.
  * Useful for finding the edge nearest a mouse click, for example.
@@ -1616,6 +1616,7 @@
 struct vertexuse *
 nmg_find_pt_in_lu(const struct loopuse *lu, const fastf_t *pt, const struct bn_tol *tol)
 {
+    vect_t delta;
     register struct edgeuse *eu;
     register struct vertex_g *vg;
     uint32_t magic1;
@@ -1625,12 +1626,11 @@
 	struct vertexuse *vu;
 	vu = BU_LIST_FIRST(vertexuse, &lu->down_hd);
 	vg = vu->v_p->vg_p;
-	if (!vg) {
+	if (!vg)
 	    return (struct vertexuse *)NULL;
-	}
-	if (bn_pt3_pt3_equal(vg->coord, pt, tol)) {
+	VSUB2(delta, vg->coord, pt);
+	if (MAGSQ(delta) < tol->dist_sq)
 	    return vu;
-	}
 	return (struct vertexuse *)NULL;
     }
     if (magic1 != NMG_EDGEUSE_MAGIC) {
@@ -1639,12 +1639,11 @@
 
     for (BU_LIST_FOR(eu, edgeuse, &lu->down_hd)) {
 	vg = eu->vu_p->v_p->vg_p;
-	if (!vg) {
+	if (!vg)
 	    continue;
-	}
-	if (bn_pt3_pt3_equal(vg->coord, pt, tol)) {
+	VSUB2(delta, vg->coord, pt);
+	if (MAGSQ(delta) < tol->dist_sq)
 	    return eu->vu_p;
-	}
     }
 
     return (struct vertexuse *)NULL;
@@ -1705,6 +1704,7 @@
     const struct vertexuse *vu;
     struct vertex *v;
     const struct vertex_g *vg;
+    vect_t delta;
 
     NMG_CK_SHELL(s);
     BN_CK_TOL(tol);
@@ -1742,9 +1742,9 @@
 	vg = v->vg_p;
 
 	if (vg) {
-	    if (bn_pt3_pt3_equal(vg->coord, pt, tol)) {
+	    VSUB2(delta, vg->coord, pt);
+	    if (MAGSQ(delta) <= tol->dist_sq)
 		return v;
-	    }
 	}
     }
 
@@ -1755,9 +1755,9 @@
 	vg = v->vg_p;
 
 	if (vg) {
-	    if (bn_pt3_pt3_equal(vg->coord, pt, tol)) {
+	    VSUB2(delta, vg->coord, pt);
+	    if (MAGSQ(delta) <= tol->dist_sq)
 		return v;
-	    }
 	}
     }
     return (struct vertex *)0;
Index: src/librt/primitives/nmg/nmg_bool.c
===================================================================
--- src/librt/primitives/nmg/nmg_bool.c	(revision 53222)
+++ src/librt/primitives/nmg/nmg_bool.c	(working copy)
@@ -42,7 +42,6 @@
 #include "vmath.h"
 #include "nmg.h"
 #include "raytrace.h"
-#include "plot3.h"
 
 
 extern int nmg_class_nothing_broken;
@@ -57,99 +56,6 @@
 
 int debug_file_count=0;
 
-
-/**
- * N M G _ P L O T _ O P E N _ E D G E S
- *
- * Find open edges, if any, in NMG object pointed to by magic_p and
- * create a UNIX plot file containing these edges.
- *
- * The prefix string will be appended to the front of the file name
- * of the plot file.
- *
- * Returns -
- * 0  No open edges, no plot file created.
- * !0 Has open edges, plot file created.
- */
-size_t
-nmg_plot_open_edges(const uint32_t *magic_p, const char *prefix)
-{
-    struct loopuse *lu;
-    struct edgeuse *eu;
-    const struct edgeuse *eur;
-    struct faceuse *newfu;
-    struct bu_ptbl faces;
-    struct face *fp;
-    struct faceuse *fu, *fu1, *fu2;
-    int done;
-    const char *manifolds = NULL;
-    point_t pt1, pt2;
-    size_t i;
-    FILE *plotfp = NULL;
-    struct bu_vls plot_file_name = BU_VLS_INIT_ZERO;
-    size_t cnt;
-
-    bu_ptbl_init(&faces, 64, "faces buffer");
-    nmg_face_tabulate(&faces, magic_p);
-
-    cnt = 0;
-    for (i = 0; i < (size_t)BU_PTBL_END(&faces) ; i++) {
-	fp = (struct face *)BU_PTBL_GET(&faces, i);
-	NMG_CK_FACE(fp);
-	fu = fu1 = fp->fu_p;
-	NMG_CK_FACEUSE(fu1);
-	fu2 = fp->fu_p->fumate_p;
-	NMG_CK_FACEUSE(fu2);
-	done = 0;
-	while (!done) {
-	    NMG_CK_FACEUSE(fu);
-	    for (BU_LIST_FOR(lu, loopuse, &fu->lu_hd)) {
-		NMG_CK_LOOPUSE(lu);
-		if (BU_LIST_FIRST_MAGIC(&lu->down_hd) == NMG_EDGEUSE_MAGIC) {
-		    for (BU_LIST_FOR(eu, edgeuse, &lu->down_hd)) {
-			NMG_CK_EDGEUSE(eu);
-			eur = nmg_radial_face_edge_in_shell(eu);
-			newfu = eur->up.lu_p->up.fu_p;
-			while (manifolds &&
-			       NMG_MANIFOLDS(manifolds, newfu) &
-			       NMG_2MANIFOLD &&
-			       eur != eu->eumate_p) {
-			    eur = nmg_radial_face_edge_in_shell(eur->eumate_p);
-			    newfu = eur->up.lu_p->up.fu_p;
-			}
-			if (eur == eu->eumate_p) {
-			    VMOVE(pt1, eu->vu_p->v_p->vg_p->coord);
-			    VMOVE(pt2, eu->eumate_p->vu_p->v_p->vg_p->coord);
-			    if (!plotfp) {
-				bu_vls_sprintf(&plot_file_name, "%s.%zu.pl", prefix, magic_p);
-				if ((plotfp = fopen(bu_vls_addr(&plot_file_name), "wb")) == (FILE *)NULL) {
-				    bu_log("nmg_plot_open_edges(): Unable to create plot file (%s)\n", bu_vls_addr(&plot_file_name));
-				    bu_bomb("nmg_plot_open_edges(): Unable to create plot file.");
-				}
-			    }
-			    pdv_3line(plotfp, pt1, pt2);
-			    cnt++;
-			}
-		    }
-		}
-	    }
-	    if (fu == fu1) fu = fu2;
-	    if (fu == fu2) done = 1;
-	};
-
-    }
-
-    if (plotfp) {
-	(void)fclose(plotfp);
-	bu_vls_free(&plot_file_name);
-    }
-
-    bu_ptbl_free(&faces);
-
-    return cnt;
-}
-
-
 static void
 nmg_dangling_handler(uint32_t *longp, genptr_t state, int UNUSED(unused))
 {
@@ -659,11 +565,10 @@
 	bu_bomb("nmg_bool(): internal error, both shells are not in the same nmg model\n");
     }
 
-    /* for the simple case where shells sA and sB are disjoint by at
-     * least distance tolerance, we can skip most of the steps to
-     * perform the boolean operation
+    /* for the simple case where shells sA and sB do not overlap, we
+     * can skip most of the steps to perform the boolean operation
      */
-    if (V3RPP_DISJOINT_TOL(sA->sa_p->min_pt, sA->sa_p->max_pt,
+    if (!V3RPP_OVERLAP_TOL(sA->sa_p->min_pt, sA->sa_p->max_pt,
 			   sB->sa_p->min_pt, sB->sa_p->max_pt, tol->dist)) {
 	switch (oper) {
 	    case NMG_BOOL_ADD: {
@@ -726,7 +631,7 @@
 
     debug_file_count++;
     if (rt_g.NMG_debug & DEBUG_VERIFY) {
-	/* Sometimes the tessellations of non-participating regions
+	/* Sometimes the tessllations of non-participating regions
 	 * are damaged during a boolean operation.  Check everything.
 	 */
 	nmg_vmodel(m);
@@ -786,7 +691,7 @@
     }
 
     if (rt_g.NMG_debug & DEBUG_VERIFY) {
-	/* Sometimes the tessellations of non-participating regions
+	/* Sometimes the tessllations of non-participating regions
 	 * are damaged during a boolean operation.  Check everything.
 	 */
 	nmg_vmodel(m);
@@ -847,7 +752,7 @@
     (void)nmg_kill_cracks(sA);
     (void)nmg_kill_cracks(sB);
 
-    /* eliminate unnecessary breaks in edges */
+    /* eliminate unecessary breaks in edges */
     (void)nmg_simplify_shell_edges(sA, tol);
     (void)nmg_simplify_shell_edges(sB, tol);
 
@@ -856,7 +761,7 @@
     (void)nmg_edge_fuse(&m->magic, tol);
 
     if (rt_g.NMG_debug & DEBUG_VERIFY) {
-	/* Sometimes the tessellations of non-participating regions
+	/* Sometimes the tessllations of non-participating regions
 	 * are damaged during a boolean operation.  Check everything.
 	 */
 	nmg_vmodel(m);
@@ -887,7 +792,7 @@
     }
 
     if (rt_g.NMG_debug & DEBUG_VERIFY) {
-	/* Sometimes the tessellations of non-participating regions
+	/* Sometimes the tessllations of non-participating regions
 	 * are damaged during a boolean operation.  Check everything.
 	 */
 	nmg_vmodel(m);
@@ -951,7 +856,7 @@
 	bu_log("nmg_bool() WARNING: sB unclosed before classification.  Boldly pressing on.\n");
 
     if (rt_g.NMG_debug & DEBUG_VERIFY) {
-	/* Sometimes the tessellations of non-participating regions
+	/* Sometimes the tessllations of non-participating regions
 	 * are damaged during a boolean operation.  Check everything.
 	 */
 	nmg_vmodel(m);
@@ -1061,7 +966,6 @@
 	    }
 	} else {
 	    if (nmg_has_dangling_faces((uint32_t *)rA, (char *)NULL)) {
-		(void)nmg_plot_open_edges((const uint32_t *)rA, "open_edges");
 		bu_bomb("nmg_bool(): Dangling faces detected in rA after boolean\n");
 	    }
 	}
@@ -1114,7 +1018,7 @@
 	bu_log("Returning from NMG_BOOL\n");
     }
     if (rt_g.NMG_debug & DEBUG_VERIFY) {
-	/* Sometimes the tessellations of non-participating regions
+	/* Sometimes the tessllations of non-participating regions
 	 * are damaged during a boolean operation.  Check everything.
 	 */
 	nmg_vmodel(m);
@@ -1617,4 +1521,3 @@
  * End:
  * ex: shiftwidth=4 tabstop=8
  */
-
Index: src/librt/primitives/nmg/nmg_misc.c
===================================================================
--- src/librt/primitives/nmg/nmg_misc.c	(revision 53222)
+++ src/librt/primitives/nmg/nmg_misc.c	(working copy)
@@ -69,7 +69,7 @@
     if (*lu->up.fu_p->f_p->g.magic_p != NMG_FACE_G_SNURB_MAGIC)
 	bu_bomb("nmg_snurb_calc_lu_uv_orient: LU is not part of a SNURB face\n");
 
-    /* count "pseudo-vertices" in loop */
+    /* count "psuedo-vertices" in loop */
     for (BU_LIST_FOR (eu, edgeuse, &lu->down_hd)) {
 	struct edge_g_cnurb *eg;
 
@@ -87,10 +87,10 @@
 	    edge_count += 5;
     }
 
-    /* allocate memory for "pseudo-vertices" */
+    /* allocate memory for "psuedo-vertices" */
     pts = (point_t *)bu_calloc(edge_count, sizeof(point_t), "Orient_nurb_face_loops: pts");
 
-    /* Assign uv geometry to each "pseudo-vertex" */
+    /* Assign uv geometry to each "psuedo-vertex" */
     edge_no = 0;
     for (BU_LIST_FOR (eu, edgeuse, &lu->down_hd)) {
 	struct edge_g_cnurb *eg;
@@ -1122,7 +1122,7 @@
  * edgeuses are not counted.
  *
  * returns:
- * number of edgeuse/mate pairs radially around eu that meet restrictions
+ * number of edgeuse/mate pairs radiall around eu that meet restrictions
  */
 int
 nmg_radial_face_count(const struct edgeuse *eu, const struct shell *s)
@@ -1152,7 +1152,7 @@
  * N M G _ C H E C K _ C L O S E D _ S H E L L
  *
  * Looks at every eu in OT_SAME fu's. If any eu has no radials, then
- * it must be the edge of a dangling face and therefore the edge of an
+ * it must be the edge of a dangling face and therfore the edge of an
  * opening.
  *
  * returns:
@@ -1431,18 +1431,18 @@
  *
  * This function only works correctly when the loop represents a
  * "simple polygon" (i.e. simple meaning not self intersecting) and
- * the loop is "not" a "weakly simple polygon" (i.e. weakly simple
+ * the loop is "not" a "weakly simple polygon" (i.e. weakly simple 
  * meaning is simple and at least one vertex is reused by the polygon).
  *
  * returns:
  * the area of the loop
- * positive area is ccw loop
+ * postive area is ccw loop
  * negative area is cw loop
  * zero is no area or degenerate loop
  *
  * pl is assigned the plane equation for the loop
  *
- * NOTE: The rotation cw/ccw is actual, meaning not relative to the
+ * NOTE: The rotation cw/ccw is actual, meaning not relative to the 
  *       faceuse normal.
  */
 fastf_t
@@ -1474,7 +1474,7 @@
     /* find the smallest floating point value which will be used
      * to determine the scaling factor, which is done to improve
      * floating point precision
-     */
+     */ 
     for (BU_LIST_FOR(eu, edgeuse, &lu->down_hd)) {
 	tmp = eu->vu_p->v_p->vg_p->coord;
 	for (i = 0; i < 3 ; i++) {
@@ -1720,7 +1720,7 @@
 	/* get average vertex coordinates */
 	VSCALE(vsum, vsum, one_over_vertex_count);
 
-	/* get distance from plane to origin */
+	/* get distance from plane to orgin */
 	pl[H] = VDOT(pl, vsum);
 
 	/* make sure it points in the correct direction */
@@ -1763,7 +1763,7 @@
 	    /* get average vertex coordinates */
 	    VSCALE(vsum, vsum, one_over_vertex_count);
 
-	    /* get distance from plane to origin */
+	    /* get distance from plane to orgin */
 	    pl[H] = VDOT(pl, vsum);
 
 	    /* make sure it points in the correct direction */
@@ -2072,7 +2072,7 @@
  * N M G _ I N _ O R _ R E F
  *
  * if the given vertexuse "vu" is in the table given by "b" or if "vu"
- * references a vertex which is referenced by a vertexuse in the table,
+ * references a vertex which is refernced by a vertexuse in the table,
  * then we return 1.  Otherwise, we return 0.
  */
 int
@@ -2303,7 +2303,7 @@
     struct bu_ptbl eu_tbl;		/* table of free edgeuses from shell */
     struct bu_ptbl vert_tbl;	/* table of vertices for use in nmg_cface */
     int *idx;			/* array of indices into eu_tbl, ordered to form a loop */
-    int loop_size;			/* number of edgeuses in loop */
+    int loop_size;			/* number of edgeueses in loop */
     struct faceuse *fu;
     struct loopuse *lu;
     struct edgeuse *eu;
@@ -2370,7 +2370,7 @@
 	/* Create new faces to close the shell */
 	while (loop_size > 3) {
 	    struct edgeuse *eu1, *eu2=NULL, *eu_new = NULL;
-	    struct edgeuse **eu_used;	/* array of edgeuses used, for deletion */
+	    struct edgeuse **eu_used;	/* array of edgueses used, for deletion */
 	    int edges_used=0;			/* number of edges used in making a face */
 	    int found_face=0;		/* flag - indicates that a face with the correct normal will be created */
 	    int start_idx, end_idx;	/* start and stop index for loop */
@@ -2647,7 +2647,7 @@
 		    nmg_kfu(fu);
 		}
 	    } else
-		bu_log("Not making face, edges are collinear!\n");
+		bu_log("Not makeing face, edges are collinear!\n");
 
 	    loop_size = 0;
 	    continue;
@@ -2676,7 +2676,7 @@
 		bu_log("Failed planeeq\n");
 
 	} else
-	    bu_log("Not making face, edges are collinear!\n");
+	    bu_log("Not makeing face, edges are collinear!\n");
 
 	/* remove the last three edges from the table */
 	{
@@ -2707,7 +2707,7 @@
  *
  * The vertex geometry is copied from the source faces into
  * topologically distinct (new) vertex and vertex_g structs.  They
- * will start out being geometrically coincident, but it is anticipated
+ * will start out being geometricly coincident, but it is anticipated
  * that the caller will modify the geometry, e.g. as in an extrude
  * operation.
  *
@@ -2737,7 +2737,7 @@
 
     m = nmg_find_model((uint32_t *)s);
 
-    /* create translation table double size to accommodate both copies */
+    /* create translation table double size to accomodate both copies */
     tbl_size = m->maxindex * 3;
     (*trans_tbl) = (long **)bu_calloc(tbl_size, sizeof(long *),
 				      "nmg_dup_shell trans_tbl");
@@ -3308,7 +3308,7 @@
  * N M G _ C O N N E C T _ S A M E _ F U _ O R I E N T S
  *
  * looks for radially connected faceuses that have disagreeing
- * orientations.  if such a condition is found, the radial pointers
+ * orientations.  if such a condiftion is found, the radial pointers
  * are rearranged to make the radial faces agree in orientation.
  */
 void
@@ -3550,7 +3550,7 @@
 /**
  * N M G _ F I X _ N O R M A L S
  *
- * Routine to set faceuse normals to correct direction.
+ * Routine to set faceuse normlas to correct direction.
  *
  * Method:
  *   1. Make a copy of the shell in another model.
@@ -3684,7 +3684,7 @@
 	}
     }
 
-    /* now set faces in original shell to match our calculations */
+    /* now set faces in orignal shell to match our calculations */
     nmg_connect_same_fu_orients(s_orig);
 
     for (BU_LIST_FOR (s1, shell, &tmp_r->s_hd)) {
@@ -3705,7 +3705,7 @@
 
 	    fu_in_s = NMG_INDEX_GETP(faceuse, trans_tbl, fu);
 	    if (!fu_in_s) {
-		bu_log("fu x%x does not have correspondence in original shell\n", fu);
+		bu_log("fu x%x does not have corrrespondence in original shell\n", fu);
 		nmg_pr_fu_briefly(fu, "");
 		continue;
 	    }
@@ -3740,7 +3740,7 @@
  *   *<----------------------------*
  *
  * where one long edgeuse (the bottom one above) and two or more
- * shorter edgeuses (the top ones) are collinear and have the same
+ * shorter edgeusess (the tops ones) are collinear and have the same
  * start and end vertices.  The code breaks the longer edgeuse into
  * ones that can be radials of the shorter ones.  Returns the number
  * of splits performed.
@@ -3949,7 +3949,7 @@
 	else if (lu->orientation == OT_OPPOSITE)
 	    otopp_loops++;
 	else {
-	    bu_log("nmg_split_loops_into_faces: faceuse (x%x) with %s loopuse (x%x)\n",
+	    bu_log("nmg_split_loops_into_faces: facuse (x%x) with %s loopuse (x%x)\n",
 		   fu, nmg_orientation(lu->orientation), lu);
 	    return;
 	}
@@ -4085,7 +4085,7 @@
 /**
  * N M G _ S P L I T _ L O O P S _ I N T O _ F A C E S
  *
- * Visits each faceuse and splits disjoint loops into separate faces.
+ * Visits each faceuse and splits disjoint loops into seperate faces.
  *
  * Returns the number of faces modified.
  */
@@ -4286,7 +4286,7 @@
 	     * shells_at_edge[i] is the number of edgeuses of this
 	     * edge that have been assigned to shell number i.
 	     * shells_at_edge[0] is the number of uses of this edge
-	     * that have not been assigned to any shell yet
+	     * that have not been asigned to any shell yet
 	     */
 	    for (k=0; k<=no_of_shells; k++)
 		shells_at_edge[k] = 0;
@@ -4629,7 +4629,7 @@
  * edgeuse visit routine for nmg_unbreak_region_edges.
  *
  * checks if edgeuse "eu" and its successor are candidates to be
- * unbroken.  looks for two consecutive edgeuses sharing the same
+ * unbroken.  looks for two consectutive edgeuses sharing the same
  * edge geometry. Checks that the middle vertex has no other uses,
  * and, if so, kills the second edgeuse.  Also moves the vu of the
  * first edgeuse mate to the vu of the killed edgeuse mate.
@@ -5432,7 +5432,7 @@
 
 	other_fus = (struct intersect_fus *)BU_PTBL_GET(int_faces, next_edge_no);
 
-	/* skip over edges between loops of same face */
+	/* skip over edges betwen loops of same face */
 	while (other_fus->fu[0] == other_fus->fu[1] && other_fus != edge_fus) {
 	    next_edge_no++;
 	    if (next_edge_no == BU_PTBL_END(int_faces))
@@ -5883,7 +5883,7 @@
 	struct intersect_fus *i_fus;
 	struct intersect_fus *j_fus;
 
-	/* get two consecutive structures */
+	/* get two consectutive structures */
 	i_fus = (struct intersect_fus *)BU_PTBL_GET(int_faces, edge_no);
 	next_edge_no = edge_no+1;
 	if (next_edge_no == BU_PTBL_END(int_faces))
@@ -5942,7 +5942,7 @@
 	    VSUB2(j_dist_to_new_v, new_v->vg_p->coord, j_fus->vp->vg_p->coord);
 
 	    if (VDOT(i_dist_to_new_v, j_dist_to_new_v) < 0.0) {
-		/* points are collinear with new_v, but in opposite directions */
+		/* points are collinear with new_v, but in opoosit directions */
 		edge_no++;
 		continue;
 	    }
@@ -6062,7 +6062,7 @@
 	struct faceuse *new_fu;
 	struct faceuse *fu;
 
-	/* get two consecutive structures */
+	/* get two consectutive structures */
 	i_fus = (struct intersect_fus *)BU_PTBL_GET(int_faces, edge_no);
 	next_edge_no = edge_no+1;
 	if (next_edge_no == BU_PTBL_END(int_faces))
@@ -6772,7 +6772,7 @@
  * This routine may create new edges and/or faces and Modifies the
  * location of "new_v"
  *
- * if approximate is non-zero, the new geometry is approximated by
+ * if approximate is non-zero, the new geomatry is approximated by
  * calculating the point with minimum distance to all the intersecting
  * faces
  *
@@ -6974,7 +6974,7 @@
 
 	NMG_CK_FACEUSE(fu);
 
-	/* only check OT_SAME faceuses */
+	/* only check OT_SAME faseuses */
 	if (fu->orientation != OT_SAME)
 	    continue;
 
@@ -7982,7 +7982,7 @@
  * N M G _ O P E N _ S H E L L S _ C O N N E C T
  *
  * Two open shells are connected along their free edges by building
- * new faces.  The resulting closed shell is in "dst", and "src" shell
+ * new faces.  The resluting closed shell is in "dst", and "src" shell
  * is destroyed.  The "copy_tbl" is a translation table that provides
  * a one-to-one translation between the vertices in the two shells,
  * i.e., NMG_INDEX_GETP(vertex, copy_tbl, v), where v is a pointer to
@@ -8359,9 +8359,9 @@
     NMG_CK_SHELL(s);
 
     /* Loops may be inadvertently connected with a crack,
-     * this code is to disconnect them and kill the connecting crack.
+     * this code is to dissconnect them and kill the connecting crack.
      * Look for cracks that are two EU's from one loop that
-     * share the same edge, but are not consecutive in the loop.
+     * share the same edge, but are not consectutive in the loop.
      * This will require a split_lu to handle.
      */
     for (BU_LIST_FOR (fu, faceuse, &s->fu_hd)) {
@@ -8621,7 +8621,7 @@
  *
  * Check all vertices on faces of specified shell. Any face containing
  * vertices more than tol->dist off the plane of the face will be
- * triangulated and broken into separate faces
+ * triangulated and broken into seperate faces
  */
 void
 nmg_make_faces_within_tol(struct shell *s, const struct bn_tol *tol)
@@ -8817,7 +8817,7 @@
     BU_CK_LIST_HEAD(crv_head);
 
     /* Check that all curves are the same pt_type and
-     * have multiplicity equal to order at endpoints.
+     * have mutliplicity equal to order at endpoints.
      */
     for (BU_LIST_FOR (crv, edge_g_cnurb, crv_head)) {
 	curve_count++;
@@ -9158,7 +9158,7 @@
 /**
  * n m g _ b r e a k _ e d g e _ a t _ v e r t s
  *
- * split an edge into multiple edges at specified vertices if they
+ * split an edge into multiple edges at specified vertices iff they
  * are within tolerance distance.
  *
  * Returns the number of additional edges that were created.
Index: src/librt/primitives/nmg/nmg_mesh.c
===================================================================
--- src/librt/primitives/nmg/nmg_mesh.c	(revision 53222)
+++ src/librt/primitives/nmg/nmg_mesh.c	(working copy)
@@ -127,7 +127,7 @@
  * best represents the direction of the little stub edge AD (shared with AE).
  * In this case, eg2 is the correct choice, as AD (and AE) lie on line AB.
  *
- * It would be disastrous to force *all* of eg1 to use the edge geometry
+ * It would be disasterous to force *all* of eg1 to use the edge geometry
  * of eg2, as the two lines are very different.
  */
 struct edge_g_lseg *
@@ -439,7 +439,7 @@
 	/*
 	 * Make eu2 radial to eu1.
 	 * This should insert eu2 between eu1 and eu1->radial_p
-	 * (which may be less far around than eur, but that's OK).
+	 * (which may be less far around than eur, but thats OK).
 	 * This does NOT change the edge geometry pointer.
 	 */
 	nmg_je(eu1, eu2);
Index: src/librt/primitives/metaball/metaball.c
===================================================================
--- src/librt/primitives/metaball/metaball.c	(revision 53222)
+++ src/librt/primitives/metaball/metaball.c	(working copy)
@@ -229,7 +229,7 @@
     nmb->finalstep = /*stp->st_aradius * */minfstr / 1e5;
 
     /* generate a bounding box around the sphere...
-     * XXX this can be optimized greatly to reduce the BSP presence... */
+     * XXX this can be optimized greatly to reduce the BSP presense... */
     if (rt_metaball_bbox(ip, &(stp->st_min), &(stp->st_max), &rtip->rti_tol)) return 1;
     stp->st_specific = (void *)nmb;
     return 0;
@@ -445,7 +445,7 @@
 			STEPIN(in)
 			fhin = 1;
 			BU_LIST_INSERT(&(seghead->l), &(segp->l));
-			/* reset the ray-walk stuff */
+			/* reset the ray-walk shtuff */
 			mb_stat = 1;
 			VADD2(p, p, inc);	/* set p to a point inside */
 			step = mb->initstep;
@@ -940,9 +940,7 @@
 rt_metaball_adjust(struct bu_vls *logstr, struct rt_db_internal *intern, int argc, const char **argv)
 {
     struct rt_metaball_internal *mb;
-    const char *pts;
-    const char *pend;
-    double thresh;
+    const char *pts, *pend;;
 
     if(argc != 3)  {
 	bu_vls_printf(logstr, "Invalid number of arguments: %d\n", argc);
@@ -958,8 +956,7 @@
 	return BRLCAD_ERROR;
     }
     mb->method = *argv[0] - '0';
-    sscanf(argv[1], "%lG", &thresh);
-    mb->threshold = thresh;
+    sscanf(argv[1], "%lG", &mb->threshold);
     BU_LIST_INIT(&mb->metaball_ctrl_head);
 
     pts = argv[2];
@@ -967,16 +964,13 @@
 
     while(1) {
 	int len;
-	double xyz[3];
-	double fldstr, goo;
+	fastf_t fldstr, goo;
 	point_t loc;
 	const point_t *locp = (const point_t *)&loc;
 
 	while( pts < pend && *pts != '{' ) ++pts;
 	if(pts >= pend) break;
-	len = sscanf(pts, "{%lG %lG %lG %lG %lG}", &xyz[0], &xyz[1], &xyz[2], &fldstr, &goo);
-	VMOVE(loc, xyz);
-
+	len = sscanf(pts, "{%lG %lG %lG %lG %lG}", loc+X, loc+Y, loc+Z, &fldstr, &goo);
 	if(len == EOF) break;
 	if(len != 5) {
 	    bu_vls_printf(logstr, "Failed to parse point information: \"%s\"", pts);
Index: src/librt/primitives/bot/tie_kdtree.c
===================================================================
--- src/librt/primitives/bot/tie_kdtree.c	(revision 53222)
+++ src/librt/primitives/bot/tie_kdtree.c	(working copy)
@@ -47,7 +47,7 @@
 
 #define	TIE_KDTREE_NODE_MAX	4	/* Maximum number of triangles that can reside in a given node until it should be split */
 #define	TIE_KDTREE_DEPTH_K1	1.4	/* K1 Depth Constant Coefficient */
-#define	TIE_KDTREE_DEPTH_K2	1	/* K2 Constant */
+#define	TIE_KDTREE_DEPTH_K2	1	/* K2 Contant */
 
 #define _MIN(a, b) (a)<(b)?(a):(b)
 #define _MAX(a, b) (a)>(b)?(a):(b)
@@ -173,7 +173,7 @@
      * 1) the {x, y, z}-directions (actually, since we use the AABB of the triangle
      *    we do not even need to test these)
      * 2) normal of the triangle
-     * 3) crossproduct(edge from tri, {x, y, z}-direction)
+     * 3) crossproduct(edge from tri, {x, y, z}-directin)
      *    this gives 3x3=9 more tests
      */
     TIE_3 v0, v1, v2, normal, e0, e1, e2, fe, p;
@@ -423,8 +423,8 @@
 
     /*
      * To eliminate "empty" areas, build a list of spans where geometric complexity is
-     * less than MIN_SPAN of the overall nodes size and then selecting the splitting plane
-     * that corresponds to the span slice domain nearest the center to bias towards a balanced tree
+     * less than MIN_SPAN of the overal nodes size and then selecting the splitting plane
+     * the corresponds to the span slice domain nearest the center to bias towards a balanced tree
      */
 
     for (d = 0; d < 3; d++) {
@@ -462,7 +462,7 @@
     /*
      * If there is a gap atleast MIN_SPAN in side wrt the nodes dimension size
      * then use the nearest edge of the gap to 0.5 as the splitting plane,
-     * Use the gap with the largest span.
+     * Use the the gap with the largest span.
      * If no gaps are found meeting the criteria then weight the span values to
      * bias towards a balanced kd-tree and choose the minima of that weighted curve.
      */
@@ -662,7 +662,7 @@
     }
 
     /*
-     * Now that the triangles have been propagated to the appropriate child nodes,
+     * Now that the triangles have been propogated to the appropriate child nodes,
      * free the triangle list on this node.
      */
     node_gd->tri_num = 0;
Index: src/librt/primitives/bot/tie.c
===================================================================
--- src/librt/primitives/bot/tie.c	(revision 53222)
+++ src/librt/primitives/bot/tie.c	(working copy)
@@ -72,7 +72,7 @@
 	mag_sq = MAGSQ(tri->data[1].v);
 	if (UNLIKELY(mag_sq < SMALL_FASTF)) {
 	    /* Can not unitize normal, most likely we have a zero area
-	     * triangle (i.e. degenerate) so skip it.
+	     * triangle (ie degenerate) so skip it.
 	     */
 	    continue;
 	}
@@ -199,7 +199,7 @@
  * @return the return value from the user hitfunc() is used.
  * In the event that the ray does not hit anything, or the ray exits the geometry space, a null value will be returned.
  * @retval 0 ray did not hit anything, or ray was propagated through the geometry completely.
- * @retval !0 the value returned from the last invocation of hitfunc()
+ * @retval !0 the value returned from the last invokation of hitfunc()
  */
 void* TIE_VAL(tie_work)(struct tie_s *tie, struct tie_ray_s *ray, struct tie_id_s *id, void *(*hitfunc)(struct tie_ray_s*, struct tie_id_s*, struct tie_tri_s*, void *ptr), void *ptr)
 {
@@ -270,7 +270,7 @@
 	while (TIE_HAS_CHILDREN(node_aligned->data)) {
 	    ray->kdtree_depth++;
 
-	    /* Retrieve the splitting plane */
+	    /* Retreive the splitting plane */
 	    split = ((intptr_t)(node_aligned->data)) & 0x3;
 
 	    /* Calculate the projected 1d distance to splitting axis */
@@ -318,7 +318,7 @@
 	    /*
 	     * Intersection point on triangle must lie within the kdtree node or it is rejected
 	     * Apply TIE_PREC to near and far such that triangles that lie on orthogonal planes
-	     * aren't in a precision fuzz boundary, thus missing something they should actually
+	     * aren't in a precision fuzz boundary, thus missing something they should actualy
 	     * have hit.
 	     */
 	    if (t.dist < near-TIE_PREC || t.dist > far+TIE_PREC)
@@ -401,7 +401,7 @@
  * Add a new triangle to the universe to be raytraced.
  *
  * @param tie the universe
- * @param tlist is an array of TIE_3 vertex triplets (v0, v1, v2) that form each triangle.
+ * @param tlist is an array of TIE_3 vertice triplets (v0, v1, v2) that form each triangle.
  * @param tnum is the number of triangles (tlist = 3 * tnum of TIE_3's).
  * @param plist is a list of pointer data that gets assigned to the ptr of each triangle.
  * This will typically be 4-byte (32-bit architecture) spaced array of pointers that
Index: src/librt/primitives/bot/bot.c
===================================================================
--- src/librt/primitives/bot/bot.c	(revision 53222)
+++ src/librt/primitives/bot/bot.c	(working copy)
@@ -1483,49 +1483,11 @@
 }
 
 
-size_t
-rt_bot_get_edge_list(const struct rt_bot_internal *bot, size_t **edge_list)
-{
-    size_t i;
-    size_t edge_count=0;
-    size_t v1, v2, v3;
-
-    if (bot->num_faces < 1)
-	return edge_count;
-
-    *edge_list = (size_t *)bu_calloc(bot->num_faces * 3 * 2, sizeof(size_t), "bot edge list");
-
-    for (i = 0; i < bot->num_faces; i++) {
-	v1 = bot->faces[i*3 + 0];
-	v2 = bot->faces[i*3 + 1];
-	v3 = bot->faces[i*3 + 2];
-
-	if (!rt_bot_edge_in_list(v1, v2, *edge_list, edge_count)) {
-	    (*edge_list)[edge_count*2 + 0] = v1;
-	    (*edge_list)[edge_count*2 + 1] = v2;
-	    edge_count++;
-	}
-	if (!rt_bot_edge_in_list(v3, v2, *edge_list, edge_count)) {
-	    (*edge_list)[edge_count*2 + 0] = v3;
-	    (*edge_list)[edge_count*2 + 1] = v2;
-	    edge_count++;
-	}
-	if (!rt_bot_edge_in_list(v1, v3, *edge_list, edge_count)) {
-	    (*edge_list)[edge_count*2 + 0] = v1;
-	    (*edge_list)[edge_count*2 + 1] = v3;
-	    edge_count++;
-	}
-    }
-
-    return edge_count;
-}
-
-
 int
-rt_bot_edge_in_list(const size_t v1, const size_t v2, const size_t edge_list[], const size_t edge_count)
+rt_bot_edge_in_list(const int v1, const int v2, const int edge_list[], const size_t edge_count)
 {
     size_t i;
-    size_t ev1, ev2;
+    int ev1, ev2;
 
     for (i = 0; i < edge_count; i++) {
 	ev1 = edge_list[i*2 + 0];
@@ -1556,8 +1518,9 @@
     const mat_t mat)
 {
     size_t i;
+    size_t v1, v2, v3;
     fastf_t dist=MAX_FASTF, tmp_dist;
-    size_t *edge_list;
+    int *edge_list;
     size_t edge_count=0;
     struct bn_tol tol;
 
@@ -1567,10 +1530,31 @@
 	return -1;
 
     /* first build a list of edges */
-    if ((edge_count = rt_bot_get_edge_list(bot, &edge_list)) == 0)
-	return -1;
+    edge_list = (int *)bu_calloc(bot->num_faces * 3 * 2, sizeof(int), "bot edge list");
 
-    /* build a tolerance structure for the bn_dist routine */
+    for (i = 0; i < bot->num_faces; i++) {
+	v1 = bot->faces[i*3 + 0];
+	v2 = bot->faces[i*3 + 1];
+	v3 = bot->faces[i*3 + 2];
+
+	if (!rt_bot_edge_in_list(v1, v2, edge_list, edge_count)) {
+	    edge_list[edge_count*2 + 0] = v1;
+	    edge_list[edge_count*2 + 1] = v2;
+	    edge_count++;
+	}
+	if (!rt_bot_edge_in_list(v3, v2, edge_list, edge_count)) {
+	    edge_list[edge_count*2 + 0] = v3;
+	    edge_list[edge_count*2 + 1] = v2;
+	    edge_count++;
+	}
+	if (!rt_bot_edge_in_list(v1, v3, edge_list, edge_count)) {
+	    edge_list[edge_count*2 + 0] = v1;
+	    edge_list[edge_count*2 + 1] = v3;
+	    edge_count++;
+	}
+    }
+
+    /* build a tyolerance structure for the bn_dist routine */
     tol.magic   = BN_TOL_MAGIC;
     tol.dist    = 0.0;
     tol.dist_sq = 0.0;
@@ -2019,7 +2003,7 @@
 		    return BRLCAD_ERROR;
 		}
 
-		if (isdigit((int)*argv[1])) {
+		if (isdigit(*argv[1])) {
 		    if (atol(argv[1]) == 0)
 			BU_BITCLR(bot->face_mode, li);
 		    else
@@ -2081,7 +2065,7 @@
 		bot->num_face_normals = len;
 		for (i = 0; i < (size_t)len; i++) {
 		    f_str = Tcl_GetStringFromObj(obj_array[i], NULL);
-		    while (isspace((int)*f_str)) f_str++;
+		    while (isspace(*f_str)) f_str++;
 
 		    if (*f_str == '\0') {
 			bu_vls_printf(logstr, "incomplete list of face_normals");
@@ -2140,7 +2124,7 @@
 		}
 		i = (size_t)li;
 		f_str = Tcl_GetStringFromObj(obj, NULL);
-		while (isspace((int)*f_str)) f_str++;
+		while (isspace(*f_str)) f_str++;
 
 		li = atol(f_str);
 		if (li < 0) {
@@ -2197,7 +2181,7 @@
 		bot->normals = (fastf_t *)bu_calloc(len*3, sizeof(fastf_t), "BOT normals");
 		for (i = 0; i < (size_t)len; i++) {
 		    v_str = Tcl_GetStringFromObj(obj_array[i], NULL);
-		    while (isspace((int)*v_str)) v_str++;
+		    while (isspace(*v_str)) v_str++;
 		    if (*v_str == '\0') {
 			bu_vls_printf(logstr, "incomplete list of normals");
 			Tcl_DecrRefCount(obj);
@@ -2229,7 +2213,7 @@
 		}
 		i = (size_t)li;
 		v_str = Tcl_GetStringFromObj(obj, NULL);
-		while (isspace((int)*v_str)) v_str++;
+		while (isspace(*v_str)) v_str++;
 
 		bot->normals[i*3+0] = atof(v_str);
 		v_str = bu_next_token(v_str);
@@ -2263,7 +2247,7 @@
 		bot->vertices = (fastf_t *)bu_calloc(len*3, sizeof(fastf_t), "BOT vertices");
 		for (i = 0; i < (size_t)len; i++) {
 		    v_str = Tcl_GetStringFromObj(obj_array[i], NULL);
-		    while (isspace((int)*v_str)) v_str++;
+		    while (isspace(*v_str)) v_str++;
 		    if (*v_str == '\0') {
 			bu_vls_printf(logstr, "incomplete list of vertices");
 			Tcl_DecrRefCount(obj);
@@ -2294,7 +2278,7 @@
 		}
 		i = (size_t)li;
 		v_str = Tcl_GetStringFromObj(obj, NULL);
-		while (isspace((int)*v_str)) v_str++;
+		while (isspace(*v_str)) v_str++;
 
 		bot->vertices[i*3+0] = atof(v_str);
 		v_str = bu_next_token(v_str);
@@ -2343,7 +2327,7 @@
 		}
 		for (i = 0; i < (size_t)len; i++) {
 		    f_str = Tcl_GetStringFromObj(obj_array[i], NULL);
-		    while (isspace((int)*f_str)) f_str++;
+		    while (isspace(*f_str)) f_str++;
 
 		    if (*f_str == '\0') {
 			bu_vls_printf(logstr, "incomplete list of faces");
@@ -2398,7 +2382,7 @@
 		}
 		i = (size_t)li;
 		f_str = Tcl_GetStringFromObj(obj, NULL);
-		while (isspace((int)*f_str)) f_str++;
+		while (isspace(*f_str)) f_str++;
 
 		li = atol(f_str);
 		if (li < 0) {
@@ -2478,7 +2462,7 @@
 	    char *m_str;
 
 	    m_str = Tcl_GetStringFromObj(obj, NULL);
-	    if (isdigit((int)*m_str)) {
+	    if (isdigit(*m_str)) {
 		int mode;
 
 		mode = atoi(m_str);
@@ -2507,7 +2491,7 @@
 	    char *o_str;
 
 	    o_str = Tcl_GetStringFromObj(obj, NULL);
-	    if (isdigit((int)*o_str)) {
+	    if (isdigit(*o_str)) {
 		int orient;
 
 		orient = atoi(o_str);
@@ -3233,7 +3217,7 @@
 
 
 /**
- * Get rid of unused vertices
+ * Get rid of unused verticies
  */
 int
 rt_bot_condense(struct rt_bot_internal *bot)
@@ -3248,7 +3232,7 @@
     num_verts = bot->num_vertices;
     verts = (int *)bu_calloc(num_verts, sizeof(int), "rt_bot_condense: verts");
 
-    /* walk the list of vertices, and mark each one if it is used */
+    /* walk the list of verticies, and mark each one if it is used */
 
     for (i = 0; i < bot->num_faces*3; i++) {
 	j = bot->faces[i];
@@ -3259,7 +3243,7 @@
 	verts[j] = 1;
     }
 
-    /* Walk the list of vertices, eliminate each unused vertex by
+    /* Walk the list of verticies, eliminate each unused vertex by
      * copying the rest of the array downwards
      */
     for (i = 0; i < num_verts-dead_verts; i++) {
@@ -3379,7 +3363,7 @@
 {
     fastf_t *centers = (fastf_t *)NULL;	/* triangle centers, used when all else fails */
     int *new_faces = (int *)NULL;	/* the sorted list of faces to be attached to the BOT at the end of this routine */
-    int *new_norms = (int *)NULL;	/* the sorted list of vertex normals corresponding to the "new_faces" list */
+    int *new_norms = (int *)NULL;	/* the sorted list of vertex normals corrsponding to the "new_faces" list */
     int *old_faces = (int *)NULL;	/* a copy of the original face list from the BOT */
     int *piece = (int *)NULL;		/* a small face list, for just the faces in the current piece */
     int *piece_norms = (int *)NULL;	/* vertex normals for faces in the current piece */
@@ -3830,7 +3814,7 @@
 		    ptr = edges[v2];
 		    while (ptr) {
 			if ((size_t)ptr->v == i) {
-			    /* found another occurrence of this edge
+			    /* found another occurence of this edge
 			     * increment use count
 			     */
 			    ptr->use_count++;
@@ -3844,19 +3828,19 @@
 			ptr = ptr->next;
 		    }
 		    if (!ptr) {
-			/* did not find another occurrence, add to list */
+			/* did not find another occurence, add to list */
 			edg->next = edges[v2];
 			edges[v2] = edg;
 		    }
 		    edg = next;
 		} else if ((size_t)v2 > i) {
-		    /* look for other occurrences of this edge in this
+		    /* look for other occurences of this edge in this
 		     * list if found, just increment use count
 		     */
 		    ptr = edges[i];
 		    while (ptr) {
 			if (ptr->v == v2 && ptr != edg) {
-			    /* found another occurrence */
+			    /* found another occurence */
 			    /* increment use count */
 			    ptr->use_count++;
 
@@ -3931,7 +3915,7 @@
  *
  * any constraint value of -1.0 means ignore this constraint
  *
- * returns 1 if edge can be eliminated without breaking constraints, 0
+ * returns 1 if edge can be eliminated without breaking conatraints, 0
  * otherwise.
  */
 HIDDEN int
@@ -4112,7 +4096,7 @@
  * removed from the list.  The list is used to direct the edge
  * decimation process and to avoid deforming the shape of a non-volume
  * enclosing BOT by keeping track of use counts (and thereby free
- * edges) If a free edge would be moved, that decimation is not
+ * edges) If a free edge would be moved, that deciamtion is not
  * performed.
  */
 int
@@ -4233,7 +4217,7 @@
     }
 
     if (actual_count % 3) {
-	bu_log("rt_bot_decimate: face vertices count is not a multiple of 3!!\n");
+	bu_log("rt_bot_decimate: face vertices count is not a multilple of 3!!\n");
 	bu_free(faces, "faces");
 	return -1;
     }
Index: src/librt/primitives/bot/g_bot_include.c
===================================================================
--- src/librt/primitives/bot/g_bot_include.c	(revision 53222)
+++ src/librt/primitives/bot/g_bot_include.c	(working copy)
@@ -38,7 +38,7 @@
  * This function is called with pointers to 3 points, and is used to
  * prepare BOT faces.  ap, bp, cp point to vect_t points.
  *
- * Returns 0 if the 3 points didn't form a plane (e.g., colinear, etc.).
+ * Returns 0 if the 3 points didn't form a plane (eg, colinear, etc).
  * Returns # pts (3) if a valid plane resulted.
  */
 int
@@ -931,7 +931,7 @@
 		dot1 = dot2;
 		dot2 = hits[i].hit_vpriv[X];
 		if (dot1 > 0.0 && dot2 > 0.0) {
-		    /* two consecutive exits, manufacture an entrance
+		    /* two consectutive exits, manufacture an entrance
 		     * at same distance as second exit.
 		     */
 		    /* XXX This consumes an extra hit structure in the array */
@@ -954,7 +954,7 @@
 		    bu_log("\t\tadding fictitious entry at %f (%s)\n", hits[i].hit_dist, stp->st_name);
 		    bu_log("\t\t\tray = (%g %g %g) -> (%g %g %g)\n", V3ARGS(ap->a_ray.r_pt), V3ARGS(ap->a_ray.r_dir));
 		} else if (dot1 < 0.0 && dot2 < 0.0) {
-		    /* two consecutive entrances, manufacture an exit
+		    /* two consectutive entrances, manufacture an exit
 		     * between them.
 		     */
 		    /* XXX This consumes an extra hit structure in the
@@ -1069,7 +1069,7 @@
 	dn = VDOT(trip->tri_wn, rp->r_dir);
 
 	/*
-	 * If ray lies directly along the face, (i.e., dot product is
+	 * If ray lies directly along the face, (ie, dot product is
 	 * zero), drop this face.
 	 */
 	abs_dn = dn >= 0.0 ? dn : (-dn);
@@ -1203,7 +1203,7 @@
 	if (debug_shoot)
 	    bu_log("%s piece %d ...\n", stp->st_name, piecenum);
 
-	/* Now intersect with each piece, which means intersecting with
+	/* Now intersect with each piece, which means intesecting with
 	 * each triangle that makes up the piece.
 	 */
 	face_array_index = piecenum*bot->bot_tri_per_piece;
@@ -1223,7 +1223,7 @@
 	    dN = VDOT(trip->tri_N, rp->r_dir);
 
 	    /*
-	     * If ray lies directly along the face, (i.e., dot product
+	     * If ray lies directly along the face, (ie, dot product
 	     * is zero), drop this face.
 	     */
 	    abs_dN = dN >= 0.0 ? dN : (-dN);
Index: src/librt/primitives/dsp/dsp_brep.cpp
===================================================================
--- src/librt/primitives/dsp/dsp_brep.cpp	(revision 53222)
+++ src/librt/primitives/dsp/dsp_brep.cpp	(working copy)
@@ -123,7 +123,7 @@
      * trimmed by a curve describing the cross section of the DSP
      * surface with the plane of the face.
      *
-     * 3.  The top surface - a generalized Bezier surface with
+     * 3.  The top surface - a genaralized Bezier surface with
      * boundaries equal to those of the four side surface intersection
      * curves. Surface topology is deduced as a function of the height
      * values.
@@ -361,7 +361,7 @@
     (*b)->SetTrimIsoFlags(s4f);
     (*b)->FlipFace(s4f);
 
-    // Next, define the top face with full resolution.
+    // Next, define the top face with full resultion.
 
     ON_BezierSurface *bezsurf = new ON_BezierSurface(3, false, dsp_ip->dsp_xcnt, dsp_ip->dsp_ycnt);
 
Index: src/librt/primitives/dsp/dsp.c
===================================================================
--- src/librt/primitives/dsp/dsp.c	(revision 53222)
+++ src/librt/primitives/dsp/dsp.c	(working copy)
@@ -151,7 +151,7 @@
  * per-solid ray tracing form of solid, including precomputed terms
  *
  * The dsp_i element MUST BE FIRST so that we can cast a pointer to a
- * dsp_specific to a rt_dsp_internal.
+ * dsp_specific to a rt_dsp_intermal.
  */
 struct dsp_specific {
     struct rt_dsp_internal dsp_i;	/* MUST BE FIRST */
@@ -165,8 +165,8 @@
 
 
 struct bbox_isect {
-    fastf_t in_dist;
-    fastf_t out_dist;
+    double in_dist;
+    double out_dist;
     int in_surf;
     int out_surf;
 };
@@ -942,7 +942,7 @@
     dsp->dsp_pl_dist[ZMAX] = (fastf_t)dsp_max;
     dsp->dsp_pl_dist[ZMID] = (fastf_t)dsp_min;
 
-    /* compute enlarged bounding box and sphere */
+    /* compute enlarged bounding box and spere */
 
 #define BBOX_PT(_x, _y, _z) \
 	VSET(pt, (fastf_t)_x, (fastf_t)_y, (fastf_t)_z); \
@@ -996,7 +996,7 @@
  *
  * Note:  because the stand-along bbox calculation requires much
  * of the prep logic, the in-prep bbox calculations are left
- * in to avoid duplication rather than calling rt_dsp_bbox.
+ * in to avoid dupliation rather than calling rt_dsp_bbox.
  */
 int
 rt_dsp_prep(struct soltab *stp, struct rt_db_internal *ip, struct rt_i *rtip)
@@ -1075,7 +1075,7 @@
     dsp->dsp_pl_dist[ZMAX] = (fastf_t)dsp_max;
     dsp->dsp_pl_dist[ZMID] = (fastf_t)dsp_min;
 
-    /* compute enlarged bounding box and sphere */
+    /* compute enlarged bounding box and spere */
 
 #define BBOX_PT(_x, _y, _z) \
 	VSET(pt, (fastf_t)_x, (fastf_t)_y, (fastf_t)_z); \
@@ -1177,8 +1177,8 @@
 
 {
     struct seg *seg;
-    fastf_t tt = isect->tol->dist;
-    fastf_t delta;
+    double tt = isect->tol->dist;
+    double delta;
 #ifndef ORDERED_ISECT
     struct bu_list *spot;
 #endif
@@ -1351,15 +1351,15 @@
 		   point_t B,
 		   point_t C,
 		   struct hit *hitp,
-		   fastf_t alphabbeta[])
+		   double alphabbeta[])
 {
-    point_t P;			/* plane intercept point */
+    point_t P;		/* plane intercept point */
     vect_t AB, AC, AP;
-    plane_t N;			/* Normal for plane of triangle */
-    fastf_t NdotDir;
-    fastf_t alpha, beta;	/* barycentric distances */
-    fastf_t hitdist;		/* distance to ray/triangle intercept */
-    fastf_t toldist;		/* distance tolerance from isect->tol */
+    plane_t N;		/* Normal for plane of triangle */
+    double NdotDir;
+    double alpha, beta;	/* barycentric distances */
+    double hitdist;	/* distance to ray/trianlge intercept */
+    double toldist;	/* distance tolerance from isect->tol */
 
 #ifdef FULL_DSP_DEBUGGING
     if (RT_G_DEBUG & DEBUG_HF) {
@@ -1484,7 +1484,7 @@
     }
 #endif
 
-    /* Ordinarily, in 2D we would say:
+    /* Oridnarily, in 2D we would say:
      *
      * beta = AB[X] * AP[X] + AB[Y] * AP[Y];
      * alpha = AC[X] * AP[X] + AC[Y] * AP[Y];
@@ -1539,7 +1539,7 @@
  * P E R M U T E _ C E L L
  *
  * For adaptive diagonal selection or for Upper-Left to lower right
- * cell cut, we must permute the vertices of the cell before handing
+ * cell cut, we must permute the verticies of the cell before handing
  * them to the intersection algorithm.  That's what this function
  * does.
  */
@@ -1571,8 +1571,8 @@
 	case DSP_CUT_DIR_ADAPT: {
 	    int lo[2], hi[2];
 	    point_t tmp;
-	    fastf_t h1, h2, h3, h4;
-	    fastf_t cAD, cBC;  /* curvature in direction AD, and BC */
+	    double h1, h2, h3, h4;
+	    double cAD, cBC;  /* curvature in direction AD, and BC */
 
 	    if (RT_G_DEBUG & DEBUG_HF)
 		bu_log("cell %d, %d adaptive triangulation... ",
@@ -1718,9 +1718,9 @@
 		    point_t D,
 		    point_t P)
 {
-    fastf_t slope = 0.0;
-    fastf_t delta = 0.0;
-    fastf_t origin = 0.0;
+    double slope = 0.0;
+    double delta = 0.0;
+    double origin = 0.0;
 
 #ifdef FULL_DSP_DEBUGGING
     dlog("check_bbpt_hit_elev(");
@@ -1802,8 +1802,8 @@
  * I S E C T _ R A Y _ C E L L _ T O P
  *
  * Return
- * 0 continue intersection calculations
- * 1 Terminate intersection computation
+ * 0 continue intesection calculations
+ * 1 Terminate intesection computation
  */
 HIDDEN int
 isect_ray_cell_top(struct isect_stuff *isect, struct dsp_bb *dsp_bb)
@@ -1818,7 +1818,7 @@
     int cond, i;
     int hitcount = 0;
     point_t bbmin, bbmax;
-    fastf_t dot, dot2;
+    double dot, dot2;
 
     for(x=0;x<4;x++)
 	memset(hits+x, 0, sizeof(struct hit));
@@ -1982,7 +1982,7 @@
 	plot_cell_top(isect, dsp_bb, A, B, C, D, hits, hitf, 1);
 	for (i=0; i < 4; i++) {
 	    if (hitf & (1<<i)) {
-		fastf_t v = VDOT(isect->r.r_dir, hits[i].hit_normal);
+		double v = VDOT(isect->r.r_dir, hits[i].hit_normal);
 
 		bu_log("%d dist:%g N:%g %g %g ",
 		       i, hits[i].hit_dist, V3ARGS(hits[i].hit_normal));
@@ -2068,7 +2068,7 @@
 /**
  * D S P _ I N _ R P P
  *
- * Compute the intersections of a ray with a rectangular parallelepiped
+ * Compute the intersections of a ray with a rectangular parallelpiped
  * (RPP) that has faces parallel to the coordinate planes
  *
  * The algorithm here was developed by Gary Kuehl for GIFT.  A good
@@ -2218,8 +2218,8 @@
  * R E C U R S E _ D S P _ B B
  *
  * Return
- * 0 continue intersection calculations
- * 1 Terminate intersection computation
+ * 0 continue intesection calculations
+ * 1 Terminate intesection computation
  */
 HIDDEN int
 recurse_dsp_bb(struct isect_stuff *isect,
@@ -2229,15 +2229,15 @@
 	       point_t bbmin, /* min point of bb (Z=0) */
 	       point_t UNUSED(bbmax)) /* max point of bb */
 {
-    fastf_t tDX;		/* dist along ray to span 1 cell in X dir */
-    fastf_t tDY;		/* dist along ray to span 1 cell in Y dir */
-    fastf_t tX, tY;	/* dist from hit pt. to next cell boundary */
-    fastf_t curr_dist;
+    double tDX;		/* dist along ray to span 1 cell in X dir */
+    double tDY;		/* dist along ray to span 1 cell in Y dir */
+    double tX, tY;	/* dist from hit pt. to next cell boundary */
+    double curr_dist;
     short cX, cY;	/* coordinates of current cell */
     short cs;		/* cell X, Y dimension */
     short stepX, stepY;	/* dist to step in child array for each dir */
     short stepPX, stepPY;
-    fastf_t out_dist;
+    double out_dist;
     struct dsp_bb **p;
     fastf_t *stom = &isect->dsp->dsp_i.dsp_stom[0];
     point_t pt, v;
@@ -2385,15 +2385,15 @@
  * of rt_dsp_shot()
  *
  * Return
- * 0 continue intersection calculations
- * 1 Terminate intersection computation
+ * 0 continue intesection calculations
+ * 1 Terminate intesection computation
  */
 HIDDEN int
 isect_ray_dsp_bb(struct isect_stuff *isect, struct dsp_bb *dsp_bb)
 {
     point_t bbmin, bbmax;
     point_t minpt, maxpt;
-    fastf_t min_z;
+    double min_z;
     /* the rest of these support debugging output */
     FILE *fp;
     static int plotnum;
@@ -2604,7 +2604,7 @@
     vect_t dir;	/* temp storage */
     vect_t v;
     struct isect_stuff isect;
-    fastf_t delta;
+    double delta;
 
     RT_DSP_CK_MAGIC(dsp);
     BU_CK_VLS(&dsp->dsp_i.dsp_name);
@@ -2713,8 +2713,8 @@
     }
 
     if (RT_G_DEBUG & DEBUG_HF) {
-	fastf_t NdotD;
-	fastf_t d;
+	double NdotD;
+	double d;
 	static const plane_t plane = {0.0, 0.0, -1.0, 0.0};
 
 	NdotD = VDOT(plane, rp->r_dir);
@@ -2740,7 +2740,7 @@
 			    unsigned int x,
 			    unsigned int y,
 			    FILE *fd,
-			    fastf_t len)
+			    double len)
 {
     /* Gridpoint specified is "B" we compute normal by taking the
      * cross product of the vectors  A->C, D->E
@@ -2851,11 +2851,11 @@
     vect_t N, t, tmp, A;
     struct dsp_specific *dsp = (struct dsp_specific *)stp->st_specific;
     vect_t Anorm, Bnorm, Dnorm, Cnorm, ABnorm, CDnorm;
-    fastf_t Xfrac, Yfrac;
+    double Xfrac, Yfrac;
     int x, y;
     point_t pt;
-    fastf_t dot;
-    fastf_t len;
+    double dot;
+    double len;
     FILE *fd = (FILE *)NULL;
 
 
@@ -2896,7 +2896,7 @@
 	/* We've hit one of the sides or bottom, or the user didn't
 	 * ask for smoothing of the elevation data, so there's no
 	 * interpolation to do.  Just transform the normal to model
-	 * space, and compute the actual hit point
+	 * space, and comput the actual hit point
 	 */
 
 	/* transform normal into model space */
@@ -2999,7 +2999,7 @@
 
     if ((ZERO(hitp->hit_vpriv[Z]) && dot > 0.0)/* in-hit needs fix */ ||
 	(ZERO(hitp->hit_vpriv[Z] - 1.0) && dot < 0.0)/* out-hit needs fix */) {
-	/* bring the normal back to being perpendicular to the ray to
+	/* bring the normal back to being perpindicular to the ray to
 	 * avoid "flipped normal" warnings
 	 */
 	VCROSS(A, rp->r_dir, N);
@@ -3062,7 +3062,7 @@
 	(struct dsp_specific *)stp->st_specific;
     point_t pt;
     vect_t tmp;
-    fastf_t r;
+    double r;
     fastf_t min_r_U, min_r_V;
     vect_t norm;
     vect_t rev_dir;
@@ -3070,7 +3070,7 @@
     vect_t UV_dir;
     vect_t U_dir, V_dir;
     fastf_t U_len, V_len;
-    fastf_t one_over_len;
+    double one_over_len;
 
     MAT4X3PNT(pt, dsp->dsp_i.dsp_mtos, hitp->hit_point);
 
@@ -3502,10 +3502,10 @@
  */
     int height[8];
     int xx, yy;
-    fastf_t c02, c13;  /* curvature in direction 0<->2, and 1<->3 */
+    double c02, c13;  /* curvature in direction 0<->2, and 1<->3 */
 
     if (dsp_ip->dsp_cuttype != DSP_CUT_DIR_ADAPT) {
-	/* not using adaptive cut type, so just return the cut type */
+	/* not using adpative cut type, so just return the cut type */
 	return dsp_ip->dsp_cuttype;
     }
 
@@ -4893,8 +4893,8 @@
 
 	case DSP_CUT_DIR_ADAPT: {
 	    int lo[2], hi[2];
-	    fastf_t h1, h2, h3, h4;
-	    fastf_t cAD, cBC;  /* curvature in direction AD, and BC */
+	    double h1, h2, h3, h4;
+	    double cAD, cBC;  /* curvature in direction AD, and BC */
 
 
 	    /*
@@ -4999,7 +4999,7 @@
 	   point_t pt)
 {
     int dx, dy;
-    fastf_t alpha, beta, x, y;
+    double alpha, beta, x, y;
     vect_t AB, AC;
 
     if (RT_G_DEBUG & DEBUG_HF) {
Index: src/librt/primitives/xxx/xxx.c
===================================================================
--- src/librt/primitives/xxx/xxx.c	(revision 53222)
+++ src/librt/primitives/xxx/xxx.c	(working copy)
@@ -28,7 +28,7 @@
  * Design disk record
  *
  * define rt_xxx_internal --- parameters for solid
- * define xxx_specific --- raytracing form, possibly w/precomputed terms
+ * define xxx_specific --- raytracing form, possibly w/precomuted terms
  * define rt_xxx_parse --- struct bu_structparse for "db get", "db adjust", ...
  *
  * code import/export4/describe/print/ifree/plot/prep/shot/curve/uv/tess
Index: src/librt/primitives/xxx/xxx.h
===================================================================
--- src/librt/primitives/xxx/xxx.h	(revision 53222)
+++ src/librt/primitives/xxx/xxx.h	(working copy)
@@ -25,7 +25,7 @@
  * Design disk record
  *
  * define rt_xxx_internal --- parameters for solid
- * define xxx_specific --- raytracing form, possibly w/precomputed terms
+ * define xxx_specific --- raytracing form, possibly w/precomuted terms
  * define rt_xxx_parse --- struct bu_structparse for "db get", "db adjust", ...
  *
  * code import/export4/describe/print/ifree/plot/prep/shot/curve/uv/tess
Index: src/librt/primitives/pipe/pipe.c
===================================================================
--- src/librt/primitives/pipe/pipe.c	(revision 53222)
+++ src/librt/primitives/pipe/pipe.c	(working copy)
@@ -177,7 +177,7 @@
 
     /* bounding box for entire torus */
     /* include od of previous and next segment
-     * to allow for discontinuous radii
+     * to allow for dinscontinuous radii
      */
     max_od = od;
     if (prev_od > max_od) {
@@ -634,7 +634,7 @@
     point_t hit_pt;
     fastf_t radius_sq;
 
-    /* calculate intersection with plane at center (with normal "norm") */
+    /* calculate interstection with plane at center (with normal "norm") */
     dist_to_plane = VDOT(norm, center);
     norm_dist = dist_to_plane - VDOT(norm, rp->r_pt);
     slant_factor = VDOT(norm, rp->r_dir);
@@ -1627,7 +1627,7 @@
  * v1 and v2 must be unit vectors normal to each other in plane of
  * circle.  v1 must be in direction from center to start point (unless
  * a full circle is requested). "End" is the endpoint of
- * arc. "Seg_count" is how many straight line segments to use to draw
+ * arc. "Seg_count" is how many straight line segements to use to draw
  * the arc. "Full_circle" is a flag to indicate that a complete circle
  * is desired.
  */
@@ -3890,7 +3890,7 @@
 	    BU_LIST_INIT(&pip->pipe_segs_head);
 	}
 
-	if (!isdigit((int)argv[0][1])) {
+	if (!isdigit(argv[0][1])) {
 	    bu_vls_printf(logstr, "no vertex number specified");
 	    return BRLCAD_ERROR;
 	}
@@ -3935,7 +3935,7 @@
 		list = Tcl_NewListObj(0, NULL);
 		Tcl_ListObjAppendList(brlcad_interp, list, obj);
 		v_str = Tcl_GetStringFromObj(list, NULL);
-		while (isspace((int)*v_str)) v_str++;
+		while (isspace(*v_str)) v_str++;
 		if (*v_str == '\0') {
 		    bu_vls_printf(logstr, "incomplete vertex specification");
 		    Tcl_DecrRefCount(list);
Index: src/librt/primitives/hyp/hyp.c
===================================================================
--- src/librt/primitives/hyp/hyp.c	(revision 53222)
+++ src/librt/primitives/hyp/hyp.c	(working copy)
@@ -234,7 +234,7 @@
 /* hit_surfno is set to one of these */
 #define HYP_NORM_BODY	(1)		/* compute normal */
 #define HYP_NORM_TOP	(2)		/* copy hyp_Hunit */
-#define HYP_NORM_BOTTOM	(3)		/* copy -hyp_Hunit */
+#define HYP_NORM_BOTTOM	(3)		/* copy -hyp_Huint */
 
 
 /**
@@ -776,7 +776,25 @@
     VMOVE(Au, xip->hyp_Au);
     VCROSS(Bu, Hu, Au);
 
-    dtol = primitive_get_absolute_tolerance(ttol, 2.0 * r2);
+    /*
+     * Establish tolerances
+     */
+    if (ttol->rel <= 0.0 || ttol->rel >= 1.0)
+	dtol = 0.0;		/* none */
+    else
+	/* Convert rel to absolute by scaling by smallest side */
+	dtol = ttol->rel * 2 * r2;
+    if (ttol->abs <= 0.0) {
+	if (dtol <= 0.0) {
+	    /* No tolerance given, use a default */
+	    dtol = 2 * 0.10 * r2;	/* 10% */
+	}
+	/* else, use absolute-ized relative tolerance */
+    } else {
+	/* Absolute tolerance was given, pick smaller */
+	if (ttol->rel <= 0.0 || dtol > ttol->abs)
+	    dtol = ttol->abs;
+    }
 
     /* To ensure normal tolerance, remain below this angle */
     if (ttol->norm > 0.0)
Index: src/librt/primitives/grip/grip.c
===================================================================
--- src/librt/primitives/grip/grip.c	(revision 53222)
+++ src/librt/primitives/grip/grip.c	(working copy)
@@ -23,13 +23,13 @@
  *
  * Intersect a ray with a "grip" and return nothing.
  *
- * A GRIP is defined by a direction normal, a center and a
- * height/magnitude vector.  The center is the control point used for
+ * A GRIP is defiend by a direction normal, a center and a
+ * height/magnitued vector.  The center is the control point used for
  * all grip movements.
  *
  * All Ray intersections return "missed"
  *
- * The bounding box for a grip is empty.
+ * The bounding box for a grip is emtpy.
  *
  */
 
@@ -221,7 +221,7 @@
  *
  * We represent a GRIP as a pyramid.  The center describes where the
  * center of the base is.  The normal describes which direction the
- * tip of the pyramid is.  Mag describes the distance from the center
+ * tip of the pyramid is.  Mag describes the distence from the center
  * to the tip. 1/4 of the width is the length of a base side.
  *
  */
Index: src/librt/primitives/ebm/ebm.c
===================================================================
--- src/librt/primitives/ebm/ebm.c	(revision 53222)
+++ src/librt/primitives/ebm/ebm.c	(working copy)
@@ -1583,7 +1583,7 @@
  * "H" - height of each cell (mm)
  * "M" - matrix to transform EBM solid into model coordinates
  *
- * no parameters requested returns all
+ * no paramaters requested returns all
  */
 int
 rt_ebm_get(struct bu_vls *logstr, const struct rt_db_internal *intern, const char *attr)
@@ -1665,7 +1665,7 @@
 	    ar_ptr = array;
 
 	    if (tcl_list_to_fastf_array(brlcad_interp, argv[1], &ar_ptr, &len) != len) {
-		bu_vls_printf(logstr, "ERROR: incorrect number of coefficients for matrix\n");
+		bu_vls_printf(logstr, "ERROR: incorrect number of coefficents for matrix\n");
 		return BRLCAD_ERROR;
 	    }
 	    MAT_COPY(ebm->mat, array);
Index: src/librt/primitives/epa/epa.c
===================================================================
--- src/librt/primitives/epa/epa.c	(revision 53222)
+++ src/librt/primitives/epa/epa.c	(working copy)
@@ -103,7 +103,7 @@
  * NORMALS.  Given the point W on the surface of the epa, what is the
  * vector normal to the tangent plane at that point?
  *
- * Map W onto the unit epa, i.e.:  W' = S(R(W - V)).
+ * Map W onto the unit epa, ie:  W' = S(R(W - V)).
  *
  * Plane on unit epa at W' has a normal vector N' where
  *
@@ -160,7 +160,6 @@
 
 #include "../../librt_private.h"
 
-static int epa_is_valid(struct rt_epa_internal *epa);
 
 struct epa_specific {
     point_t epa_V;		/* vector to epa origin */
@@ -261,7 +260,7 @@
 
     fastf_t magsq_h;
     fastf_t mag_a, mag_h;
-    fastf_t r1, r2;
+    fastf_t f, r1, r2;
     mat_t R;
     mat_t Rinv;
     mat_t S;
@@ -269,16 +268,25 @@
     RT_CK_DB_INTERNAL(ip);
 
     xip = (struct rt_epa_internal *)ip->idb_ptr;
-    if (!epa_is_valid(xip)) {
-	return 1;
-    }
+    RT_EPA_CK_MAGIC(xip);
 
     /* compute |A| |H| */
     mag_a = sqrt(MAGSQ(xip->epa_Au));
     mag_h = sqrt(magsq_h = MAGSQ(xip->epa_H));
     r1 = xip->epa_r1;
     r2 = xip->epa_r2;
+    /* Check for |H| > 0, |A| == 1, r1 > 0, r2 > 0 */
+    if (NEAR_ZERO(mag_h, RT_LEN_TOL)
+	|| !NEAR_EQUAL(mag_a, 1.0, RT_LEN_TOL)
+	|| r1 < 0.0 || r2 < 0.0) {
+	return 1;		/* BAD, too small */
+    }
 
+    /* Check for A.H == 0 */
+    f = VDOT(xip->epa_Au, xip->epa_H) / mag_h;
+    if (! NEAR_ZERO(f, RT_DOT_TOL)) {
+	return 1;		/* BAD */
+    }
 
     /*
      * EPA is ok
@@ -326,7 +334,7 @@
     /* approximate bounding radius */
     stp->st_aradius = stp->st_bradius;
 
-    /* Calculate bounding box (RPP) */
+    /* Calcuate bounding box (RPP) */
     if (rt_epa_bbox(ip, &(stp->st_min), &(stp->st_max), &rtip->rti_tol)) return 1;
 
     return 0;			/* OK */
@@ -649,232 +657,13 @@
 }
 
 
-/* A canonical parabola in the Y-Z plane has equation z = y^2 / 4p, and opens
- * toward positive z with vertex at the origin.
- *
- * The contour of an epa in the plane H-R (where R is one of the epa axes A or
- * B) is a parabola with vertex at H, opening toward -H. We can transform this
- * parabola to get an equivalent canonical parabola in the Y-Z plane, opening
- * toward positive Z (-H) with vertex at the origin (H).
- *
- * This parabola passes through the point (r, |H|) (where r = |A| or |B|).  If
- * we plug the point (r, |H|) into our canonical equation, we see how p relates
- * to r and |H|:
- *
- *   |H| = r^2 / 4p
- *     p = (r^2) / (4|H|)
- */
-static fastf_t
-epa_parabola_p(fastf_t r, fastf_t mag_h)
-{
-    return (r * r) / (4 * mag_h);
-}
-
-/* The contour of an epa in the plane H-R (where R is one of the epa axes A or
- * B) is a parabola with vertex at H, opening toward -H. We can transform this
- * parabola to get an equivalent parabola in the Y-Z plane, opening toward
- * positive Z (-H) with vertex at (0, -|H|).
- *
- * The part of this parabola that passes between (0, -|H|) and (r, 0) is
- * approximated by num_points points (including (0, -|H|) and (r, 0)).
- *
- * The constructed point list is returned (NULL returned on error). Because the
- * above transformation puts the epa vertex at the origin and the parabola
- * vertex at (0, -|H|), multiplying the z values by -1 gives corresponding
- * distances along the epa height vector H.
- */
-static struct rt_pt_node *
-epa_parabolic_curve(fastf_t mag_h, fastf_t r, int num_points)
-{
-    int count;
-    struct rt_pt_node *curve;
-
-    curve = (struct rt_pt_node *)bu_malloc(sizeof(struct rt_pt_node), "rt_pt_node");
-    curve->next = (struct rt_pt_node *)bu_malloc(sizeof(struct rt_pt_node), "rt_pt_node");
-
-    curve->next->next = NULL;
-    VSET(curve->p,       0, 0, -mag_h);
-    VSET(curve->next->p, 0, r, 0);
-
-    count = approximate_parabolic_curve(curve, epa_parabola_p(r, mag_h), num_points - 2);
-
-    if (count != (num_points - 2)) {
-	return NULL;
-    }
-
-    return curve;
-}
-
-/* The contour of an epa in the plane H-R (where R is one of the epa axes A or
- * B) is a parabola with vertex at H, opening toward -H. We can transform this
- * parabola into an equivalent one in the Y-Z plane which has vertext at (0, |H|)
- * and opens toward -Z.
- *
- * The equation for this parabola is a variant of the equation for a canonical
- * parabola in the Y-Z plane (z = y^2 / 4p):
- *   z = |H| - y^2 / 4p
- *
- * Solving this equation for y yields:
- *   y = sqrt(4p * (|H| - z))
- *
- * Substituting p = r^2 / 4|H| (see above comment):
- *   y = sqrt(r^2 * (|H| - z) / |H|)
- *     = r * sqrt((|H| - z) / |H|)
- *     = r * sqrt(1 - z / |H|)
- */
-static fastf_t
-epa_parabola_y(fastf_t r, fastf_t mag_H, fastf_t z)
-{
-    return r * sqrt(1 - z / mag_H);
-}
-
-/* Plot the elliptical cross section of the given epa at distance h along the
- * epa height vector (h >= 0, h <= |H|) consisting of num_points points.
- */
-static void
-epa_plot_ellipse(
-	struct bu_list *vhead,
-	struct rt_epa_internal *epa,
-	fastf_t h,
-	fastf_t num_points)
-{
-    fastf_t mag_H;
-    vect_t V, Hu, Au, Bu, A, B, cross_section_plane;
-
-    VMOVE(V, epa->epa_V);
-
-    mag_H = MAGNITUDE(epa->epa_H);
-    VSCALE(Hu, epa->epa_H, 1.0 / mag_H);
-
-    VMOVE(Au, epa->epa_Au);
-    VCROSS(Bu, Au, Hu);
-
-    /* calculate semi-major and semi-minor axis for the elliptical
-     * cross-section at distance h along H
-     */
-    VSCALE(A, Au, epa_parabola_y(epa->epa_r1, mag_H, h));
-    VSCALE(B, Bu, epa_parabola_y(epa->epa_r2, mag_H, h));
-    VJOIN1(cross_section_plane, V, h, Hu);
-
-    plot_ellipse(vhead, cross_section_plane, A, B, num_points);
-}
-
-static void
-epa_plot_parabola(
-	struct bu_list *vhead,
-	struct rt_epa_internal *epa,
-	struct rt_pt_node *pts,
-	vect_t Ru,
-	fastf_t r)
-{
-    point_t p;
-    vect_t epa_V, Hu;
-    fastf_t mag_H, z;
-    struct rt_pt_node *node;
-
-    VMOVE(epa_V, epa->epa_V);
-    mag_H = MAGNITUDE(epa->epa_H);
-    VSCALE(Hu, epa->epa_H, 1.0 / mag_H);
-
-    z = pts->p[Z];
-    VJOIN2(p, epa_V, epa_parabola_y(r, mag_H, -z), Ru, -z, Hu);
-    RT_ADD_VLIST(vhead, p, BN_VLIST_LINE_MOVE);
-
-    node = pts->next;
-    while (node != NULL) {
-	z = node->p[Z];
-	VJOIN2(p, epa_V, epa_parabola_y(r, mag_H, -z), Ru, -z, Hu);
-
-	RT_ADD_VLIST(vhead, p, BN_VLIST_LINE_DRAW);
-
-	node = node->next;
-    }
-}
-
-int
-rt_epa_adaptive_plot(struct rt_db_internal *ip, const struct rt_view_info *info)
-{
-    vect_t epa_H, Hu, Au, Bu;
-    fastf_t mag_H, z, r1, r2;
-    int i, num_curve_points, num_ellipse_points;
-    struct rt_epa_internal *epa;
-    struct rt_pt_node *pts_r1, *pts_r2, *node, *node1, *node2;
-
-    num_curve_points = sqrt(primitive_diagonal_samples(ip, info)) / 4.0;
-
-    if (num_curve_points < 3) {
-	num_curve_points = 3;
-    }
-
-    num_ellipse_points = 4 * num_curve_points;
-
-    BU_CK_LIST_HEAD(info->vhead);
-    RT_CK_DB_INTERNAL(ip);
-
-    epa = (struct rt_epa_internal *)ip->idb_ptr;
-    if (!epa_is_valid(epa)) {
-	return -2;
-    }
-
-    VMOVE(epa_H, epa->epa_H);
-
-    mag_H = MAGNITUDE(epa_H);
-    VSCALE(Hu, epa->epa_H, 1.0 / mag_H);
-
-    VMOVE(Au, epa->epa_Au);
-    VCROSS(Bu, Au, Hu);
-
-    r1 = epa->epa_r1;
-    r2 = epa->epa_r2;
-
-    pts_r1 = epa_parabolic_curve(mag_H, r1, num_curve_points);
-    pts_r2 = epa_parabolic_curve(mag_H, r2, num_curve_points);
-
-    if (pts_r1 == NULL || pts_r2 == NULL) {
-	return -1;
-    }
-
-    node1 = pts_r1;
-    node2 = pts_r2;
-    for (i = 0; i < num_curve_points; ++i) {
-	/* Select cross-section to draw by averaging the z values and flip over y-axis
-	 * to get a distance along H.
-	 */
-	z = (node1->p[Z] + node2->p[Z]) / 2.0;
-	epa_plot_ellipse(info->vhead, epa, -z, num_ellipse_points);
-
-	node1 = node1->next;
-	node2 = node2->next;
-    }
-
-    epa_plot_parabola(info->vhead, epa, pts_r1, Au, r1);
-    epa_plot_parabola(info->vhead, epa, pts_r1, Au, -r1);
-    epa_plot_parabola(info->vhead, epa, pts_r1, Bu, r2);
-    epa_plot_parabola(info->vhead, epa, pts_r1, Bu, -r2);
-
-    node1 = pts_r1;
-    node2 = pts_r2;
-    for (i = 0; i < num_curve_points; ++i) {
-	node = node1;
-	bu_free(node, "rt_pt_node");
-
-	node = node2;
-	bu_free(node, "rt_pt_node");
-
-	node1 = node1->next;
-	node2 = node2->next;
-    }
-
-    return 0;
-}
-
 /**
  * R T _ E P A _ P L O T
  */
 int
 rt_epa_plot(struct bu_list *vhead, struct rt_db_internal *ip, const struct rt_tess_tol *ttol, const struct bn_tol *UNUSED(tol), const struct rt_view_info *UNUSED(info))
 {
-    fastf_t dtol, mag_a, mag_h, ntol, r1, r2;
+    fastf_t dtol, f, mag_a, mag_h, ntol, r1, r2;
     fastf_t **ellipses, theta_new, theta_prev;
     int *pts_dbl, i, j, nseg;
     int jj, na, nb, nell, recalc_b;
@@ -887,18 +676,31 @@
 
     BU_CK_LIST_HEAD(vhead);
     RT_CK_DB_INTERNAL(ip);
-
     xip = (struct rt_epa_internal *)ip->idb_ptr;
-    if (!epa_is_valid(xip)) {
-	return -2;
-    }
+    RT_EPA_CK_MAGIC(xip);
 
+    /*
+     * make sure epa description is valid
+     */
+
     /* compute |A| |H| */
     mag_a = MAGSQ(xip->epa_Au);	/* should already be unit vector */
     mag_h = MAGNITUDE(xip->epa_H);
     r1 = xip->epa_r1;
     r2 = xip->epa_r2;
+    /* Check for |H| > 0, |A| == 1, r1 > 0, r2 > 0 */
+    if (NEAR_ZERO(mag_h, RT_LEN_TOL)
+	|| !NEAR_EQUAL(mag_a, 1.0, RT_LEN_TOL)
+	|| r1 <= 0.0 || r2 <= 0.0) {
+	return -2;		/* BAD */
+    }
 
+    /* Check for A.H == 0 */
+    f = VDOT(xip->epa_Au, xip->epa_H) / mag_h;
+    if (! NEAR_ZERO(f, RT_DOT_TOL)) {
+	return -2;		/* BAD */
+    }
+
     /* make unit vectors in A, H, and BxH directions */
     VMOVE(Hu, xip->epa_H);
     VUNITIZE(Hu);
@@ -912,7 +714,25 @@
     VREVERSE(&R[8], Hu);
     bn_mat_trn(invR, R);			/* inv of rot mat is trn */
 
-    dtol = primitive_get_absolute_tolerance(ttol, 2.0 * r2);
+    /*
+     * Establish tolerances
+     */
+    if (ttol->rel <= 0.0 || ttol->rel >= 1.0)
+	dtol = 0.0;		/* none */
+    else
+	/* Convert rel to absolute by scaling by smallest side */
+	dtol = ttol->rel * 2 * r2;
+    if (ttol->abs <= 0.0) {
+	if (dtol <= 0.0) {
+	    /* No tolerance given, use a default */
+	    dtol = 2 * 0.10 * r2;	/* 10% */
+	}
+	/* Use absolute-ized relative tolerance */
+    } else {
+	/* Absolute tolerance was given, pick smaller */
+	if (ttol->rel <= 0.0 || dtol > ttol->abs)
+	    dtol = ttol->abs;
+    }
 
     /* To ensure normal tolerance, remain below this angle */
     if (ttol->norm > 0.0)
@@ -933,7 +753,6 @@
     VSET(pts_b->next->p, 0, r2, 0);
     /* 2 endpoints in 1st approximation */
     nb = 2;
-
     /* recursively break segment 'til within error tolerances */
     nb += rt_mk_parabola(pts_b, r2, mag_h, dtol, ntol);
     nell = nb - 1;	/* # of ellipses needed */
@@ -1164,7 +983,7 @@
 int
 rt_epa_tess(struct nmgregion **r, struct model *m, struct rt_db_internal *ip, const struct rt_tess_tol *ttol, const struct bn_tol *tol)
 {
-    fastf_t dtol, mag_a, mag_h, ntol, r1, r2;
+    fastf_t dtol, f, mag_a, mag_h, ntol, r1, r2;
     fastf_t **ellipses, **normals, theta_new, theta_prev;
     int *pts_dbl, face, i, j, nseg;
     int *segs_per_ell;
@@ -1186,18 +1005,30 @@
     struct faceuse *fu;
 
     RT_CK_DB_INTERNAL(ip);
-
     xip = (struct rt_epa_internal *)ip->idb_ptr;
-    if (!epa_is_valid(xip)) {
-	return -2;
-    }
+    RT_EPA_CK_MAGIC(xip);
 
+    /*
+     * make sure epa description is valid
+     */
+
     /* compute |A| |H| */
     mag_a = MAGSQ(xip->epa_Au);	/* should already be unit vector */
     mag_h = MAGNITUDE(xip->epa_H);
     r1 = xip->epa_r1;
     r2 = xip->epa_r2;
+    /* Check for |H| > 0, |A| == 1, r1 > 0, r2 > 0 */
+    if (NEAR_ZERO(mag_h, RT_LEN_TOL)
+	|| !NEAR_EQUAL(mag_a, 1.0, RT_LEN_TOL)
+	|| r1 <= 0.0 || r2 <= 0.0) {
+	return -2;		/* BAD */
+    }
 
+    /* Check for A.H == 0 */
+    f = VDOT(xip->epa_Au, xip->epa_H) / mag_h;
+    if (! NEAR_ZERO(f, RT_DOT_TOL)) {
+	return -2;		/* BAD */
+    }
 
     /* make unit vectors in A, H, and BxH directions */
     VMOVE(Hu, xip->epa_H);
@@ -1215,7 +1046,25 @@
     VREVERSE(&R[8], Hu);
     bn_mat_trn(invR, R);			/* inv of rot mat is trn */
 
-    dtol = primitive_get_absolute_tolerance(ttol, 2.0 * r2);
+    /*
+     * Establish tolerances
+     */
+    if (ttol->rel <= 0.0 || ttol->rel >= 1.0)
+	dtol = 0.0;		/* none */
+    else
+	/* Convert rel to absolute by scaling by smallest side */
+	dtol = ttol->rel * 2 * r2;
+    if (ttol->abs <= 0.0) {
+	if (dtol <= 0.0) {
+	    /* No tolerance given, use a default */
+	    dtol = 2 * 0.10 * r2;	/* 10% */
+	}
+	/* Use absolute-ized relative tolerance */
+    } else {
+	/* Absolute tolerance was given, pick smaller */
+	if (ttol->rel <= 0.0 || dtol > ttol->abs)
+	    dtol = ttol->abs;
+    }
 
     /* To ensure normal tolerance, remain below this angle */
     if (ttol->norm > 0.0)
@@ -1943,43 +1792,7 @@
     *area = 2.0/3.0 * M_PI * xip->epa_r1 * xip->epa_r2 * (m + (1.0 / (m + 1.0)));
 }
 
-static int
-epa_is_valid(struct rt_epa_internal *epa)
-{
-    fastf_t mag_h, cos_angle_ah;
-    vect_t epa_H, epa_Au;
 
-    RT_EPA_CK_MAGIC(epa);
-
-    if (!(epa->epa_r1 > 0.0 && epa->epa_r2 > 0.0)) {
-	return 0;
-    }
-
-    VMOVE(epa_H, epa->epa_H);
-    VMOVE(epa_Au, epa->epa_Au);
-
-    /* Check that Au is a unit vector. If it is, then it should be true that
-     * |Au| == |Au|^2 == 1.0.
-     */
-    if (!NEAR_EQUAL(MAGSQ(epa_Au), 1.0, RT_LEN_TOL)) {
-	return 0;
-    }
-
-    /* check that |H| > 0.0 */
-    mag_h = MAGNITUDE(epa_H);
-    if (NEAR_ZERO(mag_h, RT_LEN_TOL)) {
-	return 0;
-    }
-
-    /* check that A and H are orthogonal */
-    cos_angle_ah = VDOT(epa_Au, epa_H) / mag_h;
-    if (!NEAR_ZERO(cos_angle_ah, RT_DOT_TOL)) {
-	return 0;
-    }
-
-    return 1;
-}
-
 /** @} */
 /*
  * Local Variables:
Index: src/librt/primitives/part/part.c
===================================================================
--- src/librt/primitives/part/part.c	(revision 53222)
+++ src/librt/primitives/part/part.c	(working copy)
@@ -37,7 +37,7 @@
  * be transformed into a set of points on a unit cylinder (or cone)
  * with the transformed base (V') located at the origin with a
  * transformed radius of 1 (vrad').  The height of the cylinder (or
- * cone) along the +Z axis is +1 (i.e., H' = (0, 0, 1)), with a
+ * cone) along the +Z axis is +1 (ie, H' = (0, 0, 1)), with a
  * transformed radius of hrad/vrad.
  *
  *
@@ -148,10 +148,10 @@
  * NORMALS.  Given the point W on the surface of the cylinder, what is
  * the vector normal to the tangent plane at that point?
  *
- * Map W onto the unit cylinder, i.e.:  W' = S(R(W - V)).
+ * Map W onto the unit cylinder, ie:  W' = S(R(W - V)).
  *
  * Plane on unit cylinder at W' has a normal vector N' of the same
- * value as W' in x and y, with z set to zero, i.e., (Wx', Wy', 0)
+ * value as W' in x and y, with z set to zero, ie, (Wx', Wy', 0)
  *
  * The plane transforms back to the tangent plane at W, and this new
  * plane (on the original cylinder) has a normal vector of N, viz:
@@ -190,7 +190,6 @@
 #include "rtgeom.h"
 #include "raytrace.h"
 #include "nmg.h"
-#include "../../librt_private.h"
 
 
 struct part_specific {
@@ -470,7 +469,7 @@
     int check_v, check_h;
 
     if (part->part_int.part_type == RT_PARTICLE_TYPE_SPHERE) {
-	vect_t ov;		/* ray origin to center (V - P) */
+	vect_t ov;		/* ray orgin to center (V - P) */
 	fastf_t vrad_sq;
 	fastf_t magsq_ov;	/* length squared of ov */
 	fastf_t b;		/* second term of quadratic eqn */
@@ -522,7 +521,7 @@
     }
     check_v = check_h = 0;
 
-    /* Find roots of the equation, using formula for quadratic */
+    /* Find roots of the equation, using forumla for quadratic */
     /* Note that vrad' = 1 and hrad' = hrad/vrad */
     if (part->part_int.part_type == RT_PARTICLE_TYPE_CYLINDER) {
 	/* Cylinder case, hrad == vrad, m = 0 */
@@ -607,7 +606,7 @@
      */
  check_hemispheres:
     if (check_v) {
-	vect_t ov;		/* ray origin to center (V - P) */
+	vect_t ov;		/* ray orgin to center (V - P) */
 	fastf_t rad_sq;
 	fastf_t magsq_ov;	/* length squared of ov */
 	fastf_t b;
@@ -654,7 +653,7 @@
 
  do_check_h:
     if (check_h) {
-	vect_t ov;		/* ray origin to center (V - P) */
+	vect_t ov;		/* ray orgin to center (V - P) */
 	fastf_t rad_sq;
 	fastf_t magsq_ov;	/* length squared of ov */
 	fastf_t b;		/* second term of quadratic eqn */
@@ -804,7 +803,7 @@
     register struct part_specific *part =
 	(struct part_specific *)stp->st_specific;
     point_t hit_local;	/* hit_point, with V as origin */
-    point_t hit_unit;	/* hit_point in unit coords, +Z along H */
+    point_t hit_unit;	/* hit_poit in unit coords, +Z along H */
 
     switch (hitp->hit_surfno) {
 	case RT_PARTICLE_SURF_VSPHERE:
@@ -1109,8 +1108,8 @@
     int boff;		/* base offset */
     int toff;		/* top offset */
     int blim;		/* base subscript limit */
-    int tlim;		/* top subscript limit */
-    fastf_t dtol;	/* Absolutized relative tolerance */
+    int tlim;		/* top subscrpit limit */
+    fastf_t rel;	/* Absolutized relative tolerance */
 
     RT_CK_DB_INTERNAL(ip);
     pip = (struct rt_part_internal *)ip->idb_ptr;
@@ -1163,17 +1162,36 @@
     if (pip->part_hrad > radius)
 	radius = pip->part_hrad;
 
-    dtol = primitive_get_absolute_tolerance(ttol, radius);
-
-    if (dtol > radius) {
-	dtol = radius;
+    /*
+     * Establish tolerances
+     */
+    if (ttol->rel <= 0.0 || ttol->rel >= 1.0) {
+	rel = 0.0;		/* none */
+    } else {
+	/* Convert rel to absolute by scaling by radius */
+	rel = ttol->rel * radius;
     }
+    if (ttol->abs <= 0.0) {
+	if (rel <= 0.0) {
+	    /* No tolerance given, use a default */
+	    rel = 0.10 * radius;	/* 10% */
+	} else {
+	    /* Use absolute-ized relative tolerance */
+	}
+    } else {
+	/* Absolute tolerance was given, pick smaller */
+	if (ttol->rel <= 0.0 || rel > ttol->abs) {
+	    rel = ttol->abs;
+	    if (rel > radius)
+		rel = radius;
+	}
+    }
 
     /*
      * Converte distance tolerance into a maximum permissible
      * angle tolerance.  'radius' is largest radius.
      */
-    state.theta_tol = 2 * acos(1.0 - dtol / radius);
+    state.theta_tol = 2 * acos(1.0 - rel / radius);
 
     /* To ensure normal tolerance, remain below this angle */
     if (ttol->norm > 0.0 && ttol->norm < state.theta_tol) {
@@ -1190,7 +1208,7 @@
     /* Find total number of strips of vertices that will be needed.
      * nsegs for each hemisphere, plus one equator each.
      * The two equators will be stitched together to make the cylinder.
-     * Note that faces are listed in the stripe ABOVE, i.e., toward
+     * Note that faces are listed in the the stripe ABOVE, ie, toward
      * the poles.  Thus, strips[0] will have 4 faces.
      */
     nstrips = 2 * nsegs + 2;
@@ -1201,7 +1219,7 @@
     strips[0].nverts = 1;
     strips[0].nverts_per_strip = 0;
     strips[0].nfaces = 4;
-    /* South pole (Lower hemisphere, V end) */
+    /* South pole (Lower hemispehre, V end) */
     strips[nstrips-1].nverts = 1;
     strips[nstrips-1].nverts_per_strip = 0;
     strips[nstrips-1].nfaces = 4;
Index: src/librt/primitives/table.c
===================================================================
--- src/librt/primitives/table.c	(revision 53222)
+++ src/librt/primitives/table.c	(working copy)
@@ -53,7 +53,6 @@
     extern int rt_##name##_class(); \
     extern void rt_##name##_free(struct soltab *stp); \
     extern int rt_##name##_plot(struct bu_list *vhead, struct rt_db_internal *ip, const struct rt_tess_tol *ttol, const struct bn_tol *tol, const struct rt_view_info *info); \
-    extern int rt_##name##_adaptive_plot(struct rt_db_internal *ip, const struct rt_view_info *info); \
     extern void rt_##name##_vshot(struct soltab *stp[], struct xray *rp[], struct seg *segp, int n, struct application *ap); \
     extern int rt_##name##_tess(struct nmgregion **r, struct model *m, struct rt_db_internal *ip, const struct rt_tess_tol *ttol, const struct bn_tol *tol); \
     extern int rt_##name##_tnurb(struct nmgregion **r, struct model *m, struct rt_db_internal *ip, const struct bn_tol *tol); \
@@ -179,7 +178,6 @@
 	NULL,
 	NULL,
 	NULL,
-	NULL,
 	0,
 	0,
 	NULL,
@@ -208,7 +206,6 @@
 	rt_tor_class,
 	rt_tor_free,
 	rt_tor_plot,
-	rt_tor_adaptive_plot,
 	rt_tor_vshot,
 	rt_tor_tess,
 	NULL,
@@ -249,7 +246,6 @@
 	rt_tgc_class,
 	rt_tgc_free,
 	rt_tgc_plot,
-	rt_tgc_adaptive_plot,
 	rt_tgc_vshot,
 	rt_tgc_tess,
 	rt_tgc_tnurb,
@@ -290,7 +286,6 @@
 	rt_ell_class,
 	rt_ell_free,
 	rt_ell_plot,
-	rt_ell_adaptive_plot,
 	rt_ell_vshot,
 	rt_ell_tess,
 	rt_ell_tnurb,
@@ -331,7 +326,6 @@
 	rt_arb_class,
 	rt_arb_free,
 	rt_arb_plot,
-	NULL,
 	rt_arb_vshot,
 	rt_arb_tess,
 	rt_arb_tnurb,
@@ -373,7 +367,6 @@
 	rt_bot_free,
 	rt_ars_plot,
 	NULL,
-	NULL,
 	rt_ars_tess,
 	NULL,
 	rt_ars_brep,
@@ -413,7 +406,6 @@
 	rt_hlf_class,
 	rt_hlf_free,
 	rt_hlf_plot,
-	NULL,
 	rt_hlf_vshot,
 	rt_hlf_tess,
 	NULL,
@@ -454,7 +446,6 @@
 	rt_rec_class,
 	rt_rec_free,
 	rt_tgc_plot,
-	rt_tgc_adaptive_plot,
 	rt_rec_vshot,
 	rt_tgc_tess,
 	NULL,
@@ -496,7 +487,6 @@
 	rt_pg_free,
 	rt_pg_plot,
 	NULL,
-	NULL,
 	rt_pg_tess,
 	NULL,
 	NULL,
@@ -537,7 +527,6 @@
 	rt_nurb_free,
 	rt_nurb_plot,
 	NULL,
-	NULL,
 	rt_nurb_tess,
 	NULL,
 	NULL,
@@ -577,7 +566,6 @@
 	rt_sph_class,
 	rt_sph_free,
 	rt_ell_plot,
-	rt_ell_adaptive_plot,
 	rt_sph_vshot,
 	rt_ell_tess,
 	rt_ell_tnurb,
@@ -619,7 +607,6 @@
 	rt_nmg_free,
 	rt_nmg_plot,
 	NULL,
-	NULL,
 	rt_nmg_tess,
 	NULL,
 	rt_nmg_brep,
@@ -660,7 +647,6 @@
 	rt_ebm_free,
 	rt_ebm_plot,
 	NULL,
-	NULL,
 	rt_ebm_tess,
 	NULL,
 	rt_ebm_brep,
@@ -701,7 +687,6 @@
 	rt_vol_free,
 	rt_vol_plot,
 	NULL,
-	NULL,
 	rt_vol_tess,
 	NULL,
 	rt_vol_brep,
@@ -742,7 +727,6 @@
 	rt_arbn_free,
 	rt_arbn_plot,
 	NULL,
-	NULL,
 	rt_arbn_tess,
 	NULL,
 	rt_arbn_brep,
@@ -783,7 +767,6 @@
 	rt_pipe_free,
 	rt_pipe_plot,
 	NULL,
-	NULL,
 	rt_pipe_tess,
 	NULL,
 	rt_pipe_brep,
@@ -824,7 +807,6 @@
 	rt_part_free,
 	rt_part_plot,
 	NULL,
-	NULL,
 	rt_part_tess,
 	NULL,
 	rt_part_brep,
@@ -864,7 +846,6 @@
 	rt_rpc_class,
 	rt_rpc_free,
 	rt_rpc_plot,
-	rt_rpc_adaptive_plot,
 	NULL,
 	rt_rpc_tess,
 	NULL,
@@ -905,7 +886,6 @@
 	rt_rhc_class,
 	rt_rhc_free,
 	rt_rhc_plot,
-	rt_rhc_adaptive_plot,
 	NULL,
 	rt_rhc_tess,
 	NULL,
@@ -946,7 +926,6 @@
 	rt_epa_class,
 	rt_epa_free,
 	rt_epa_plot,
-	rt_epa_adaptive_plot,
 	NULL,
 	rt_epa_tess,
 	NULL,
@@ -987,7 +966,6 @@
 	rt_ehy_class,
 	rt_ehy_free,
 	rt_ehy_plot,
-	rt_ehy_adaptive_plot,
 	NULL,
 	rt_ehy_tess,
 	NULL,
@@ -1070,7 +1048,6 @@
 	rt_grp_free,
 	rt_grp_plot,
 	NULL,
-	NULL,
 	rt_grp_tess,
 	NULL,
 	rt_grp_brep,
@@ -1122,7 +1099,6 @@
 	NULL,
 	NULL,
 	NULL,
-	NULL,
 	0,
 	0,
 	NULL,
@@ -1152,7 +1128,6 @@
 	rt_hf_free,
 	rt_hf_plot,
 	NULL,
-	NULL,
 	rt_hf_tess,
 	NULL,
 	rt_hf_brep,
@@ -1193,7 +1168,6 @@
 	rt_dsp_free,
 	rt_dsp_plot,
 	NULL,
-	NULL,
 	rt_dsp_tess,
 	NULL,
 	rt_dsp_brep,
@@ -1236,7 +1210,6 @@
 	NULL,
 	NULL,
 	NULL,
-	NULL,
 	rt_sketch_brep,
 	rt_sketch_import5,
 	rt_sketch_export5,
@@ -1275,7 +1248,6 @@
 	rt_extrude_free,
 	rt_extrude_plot,
 	NULL,
-	NULL,
 	rt_extrude_tess,
 	NULL,
 	rt_extrude_brep,
@@ -1316,7 +1288,6 @@
 	rt_submodel_free,
 	rt_submodel_plot,
 	NULL,
-	NULL,
 	rt_submodel_tess,
 	NULL,
 	NULL,
@@ -1357,7 +1328,6 @@
 	rt_cline_free,
 	rt_cline_plot,
 	NULL,
-	NULL,
 	rt_cline_tess,
 	NULL,
 	rt_cline_brep,
@@ -1398,7 +1368,6 @@
 	rt_bot_free,
 	rt_bot_plot,
 	NULL,
-	NULL,
 	rt_bot_tess,
 	NULL,
 	rt_bot_brep,
@@ -1442,7 +1411,6 @@
 	NULL,
 	NULL,
 	NULL,
-	NULL,
 	rt_comb_import5,
 	rt_comb_export5,
 	rt_comb_import4,
@@ -1493,7 +1461,6 @@
 	NULL,
 	NULL,
 	NULL,
-	NULL,
 	0,
 	0,
 	NULL,
@@ -1527,7 +1494,6 @@
 	NULL,
 	NULL,
 	NULL,
-	NULL,
 	rt_binunif_export5,
 	NULL,
 	NULL,
@@ -1577,7 +1543,6 @@
 	NULL,
 	NULL,
 	NULL,
-	NULL,
 	0,
 	0,
 	NULL,
@@ -1607,7 +1572,6 @@
 	rt_superell_free,
 	rt_superell_plot,
 	NULL,
-	NULL,
 	rt_superell_tess,
 	NULL,
 	rt_superell_brep,
@@ -1648,7 +1612,6 @@
 	rt_metaball_free,
 	rt_metaball_plot,
 	NULL,
-	NULL,
 	rt_metaball_tess,
 	NULL,
 	NULL,
@@ -1690,7 +1653,6 @@
 	rt_brep_free,
 	rt_brep_plot,
 	NULL,
-	NULL,
 	rt_brep_tess,
 	NULL,
 	NULL,
@@ -1741,7 +1703,6 @@
 	NULL,
 	NULL,
 	NULL,
-	NULL,
 	0,
 	0,
 	0,
@@ -1772,7 +1733,6 @@
 	rt_hyp_free,
 	rt_hyp_plot,
 	NULL,
-	NULL,
 	rt_hyp_tess,
 	NULL,
 	rt_hyp_brep,
@@ -1816,7 +1776,6 @@
 	NULL,
 	NULL,
 	NULL,
-	NULL,
 	rt_constraint_import5,
 	rt_constraint_export5,
 	NULL,
@@ -1854,7 +1813,6 @@
 	rt_revolve_free,
 	rt_revolve_plot,
 	NULL,
-	NULL,
 	rt_revolve_tess,
 	NULL,
 	rt_revolve_brep,
@@ -1897,7 +1855,6 @@
 	NULL,
 	NULL,
 	NULL,
-	NULL,
 	rt_pnts_brep,
 	rt_pnts_import5,
 	rt_pnts_export5,
@@ -1947,7 +1904,6 @@
 	NULL,
 	NULL,
 	NULL,
-	NULL,
 	sizeof(struct rt_annotation_internal),
 	RT_ANNOTATION_INTERNAL_MAGIC,
 	NULL,
@@ -1988,7 +1944,6 @@
 	NULL,
 	NULL,
 	NULL,
-	NULL,
 	0,
 	0,
 	NULL,
@@ -2007,8 +1962,8 @@
 /* Map for database solidrec objects to internal objects */
 static char idmap[] = {
     ID_NULL,	/* undefined, 0 */
-    ID_NULL,	/* RPP	1 axis-aligned rectangular parallelepiped */
-    ID_NULL,	/* BOX	2 arbitrary rectangular parallelepiped */
+    ID_NULL,	/* RPP	1 axis-aligned rectangular parallelopiped */
+    ID_NULL,	/* BOX	2 arbitrary rectangular parallelopiped */
     ID_NULL,	/* RAW	3 right-angle wedge */
     ID_NULL,	/* ARB4	4 tetrahedron */
     ID_NULL,	/* ARB5	5 pyramid */
Index: src/librt/primitives/submodel/submodel.c
===================================================================
--- src/librt/primitives/submodel/submodel.c	(revision 53222)
+++ src/librt/primitives/submodel/submodel.c	(working copy)
@@ -227,7 +227,7 @@
     bn_mat_inv(submodel->m2subm, sip->root2leaf);
     submodel->rtip = sub_rtip;
 
-    /* Propagate submodel bounding box back upwards, rotated&scaled. */
+    /* Propagage submodel bounding box back upwards, rotated&scaled. */
     bn_rotate_bbox(stp->st_min, stp->st_max,
 		   submodel->subm2m,
 		   sub_rtip->mdl_min, sub_rtip->mdl_max);
@@ -611,7 +611,7 @@
     rtip = submodel->rtip;
     RT_CK_RTI(rtip);
 
-    /* Specifically free resource structures here */
+    /* Specificially free resource structures here */
     BU_CK_PTBL(&rtip->rti_resources);
     for (BU_PTBL_FOR(rpp, (struct resource **), &rtip->rti_resources)) {
 	if (*rpp == NULL) continue;
Index: src/librt/primitives/ell/ell.c
===================================================================
--- src/librt/primitives/ell/ell.c	(revision 53222)
+++ src/librt/primitives/ell/ell.c	(working copy)
@@ -119,7 +119,7 @@
  * NORMALS.  Given the point W on the ellipsoid, what is the vector
  * normal to the tangent plane at that point?
  *
- * Map W onto the unit sphere, i.e.:  W' = S(R(W - V)).
+ * Map W onto the unit sphere, ie:  W' = S(R(W - V)).
  *
  * Plane on unit sphere at W' has a normal vector of the same
  * value(!).  N' = W'
@@ -183,7 +183,7 @@
     magsq_b = MAGSQ(eip->b);
     magsq_c = MAGSQ(eip->c);
 
-    /* Try a shortcut - if this is a sphere, the calculation simplifies */
+    /* Try a shortcut - if this is a sphere, the calculation simpifies */
     /* Check whether |A|, |B|, and |C| are nearly equal */
     if (EQUAL(magsq_a, magsq_b) && EQUAL(magsq_a, magsq_c)) {
 	fastf_t sph_rad = sqrt(magsq_a);
@@ -669,6 +669,7 @@
     VJOIN2(ELLOUT(16), V, e, A, -f, B);
 }
 
+#ifdef ALTERNATE_PLOTTING
 struct ell_draw_configuration {
     struct bu_list *vhead;
     vect_t ell_center;
@@ -703,6 +704,28 @@
     return sqrt(target_axis_mag * target_axis_mag * (1.0 - fixed_term));
 }
 
+static void
+ellipse_cross_section_point_at_radian(
+	point_t *result,
+	struct ellipse_cross_section ellipse,
+	double radian)
+{
+    int i;
+    vect_t a, b, t;
+    double cos_rad, sin_rad;
+
+    VMOVE(a, ellipse.a);
+    VMOVE(b, ellipse.b);
+    VMOVE(t, ellipse.translation);
+
+    cos_rad = cos(radian);
+    sin_rad = sin(radian);
+
+    for (i = 0; i < ELEMENTS_PER_POINT; ++i ) {
+	(*result)[i] = t[i] + a[i] * cos_rad + b[i] * sin_rad;
+    }
+}
+
 /* Draws elliptical cross-sections along an ell vector (the "travel vector").
  *
  * algorithm overview:
@@ -716,13 +739,14 @@
 static void
 draw_cross_sections_along_ell_vector(struct ell_draw_configuration config)
 {
-    int i;
+    int i, j;
     vect_t ell_a, ell_b, ell_t;
     double ellipse_a_mag, ellipse_b_mag;
     double ell_a_mag, ell_b_mag, ell_t_mag;
     double num_cross_sections, points_per_section;
     double position_step, radian_step;
-    struct ellipse_cross_section cross_section = {VINIT_ZERO, VINIT_ZERO, VINIT_ZERO, 0.0, 0.0};
+    struct ellipse_cross_section cross_section;
+    point_t cross_section_point;
 
     VMOVE(ell_a, config.ell_axis_vector_a);
     VMOVE(ell_b, config.ell_axis_vector_b);
@@ -752,73 +776,56 @@
 		cross_section.ellipsoid_travel_axis_position / ell_t_mag);
 	VADD2(cross_section.translation, cross_section.translation, config.ell_center);
 
-	plot_ellipse(config.vhead, cross_section.translation, cross_section.a,
-		     cross_section.b, points_per_section);
+	ellipse_cross_section_point_at_radian(&cross_section_point,
+		cross_section, (points_per_section - 1) * radian_step);
+	RT_ADD_VLIST(config.vhead, cross_section_point, BN_VLIST_LINE_MOVE);
+
+	for (j = 0; j < points_per_section; ++j) {
+	    ellipse_cross_section_point_at_radian(&cross_section_point,
+		    cross_section, j * radian_step);
+	    RT_ADD_VLIST(config.vhead, cross_section_point, BN_VLIST_LINE_DRAW);
+	}
     }
 }
+#endif
 
+/**
+ * R T _ E L L _ P L O T
+ */
 int
-rt_ell_adaptive_plot(struct rt_db_internal *ip, const struct rt_view_info *info)
+rt_ell_plot(struct bu_list *vhead, struct rt_db_internal *ip, const struct rt_tess_tol *UNUSED(ttol), const struct bn_tol *UNUSED(tol), const struct rt_view_info *UNUSED(info))
 {
+#ifdef ALTERNATE_PLOTTING
     struct ell_draw_configuration config;
     struct rt_ell_internal *eip;
-    fastf_t samples;
 
-    BU_CK_LIST_HEAD(info->vhead);
+    BU_CK_LIST_HEAD(vhead);
     RT_CK_DB_INTERNAL(ip);
     eip = (struct rt_ell_internal *)ip->idb_ptr;
     RT_ELL_CK_MAGIC(eip);
 
-    samples = primitive_diagonal_samples(ip, info);
+    config.vhead = vhead;
+    config.num_cross_sections = 0;
+    config.points_per_section = 32;
 
-    config.vhead = info->vhead;
     VMOVE(config.ell_center, eip->v);
-    config.points_per_section = sqrt(samples);
 
-    if (config.points_per_section < 6) {
-	config.points_per_section = 6;
-    }
-
-    if (config.points_per_section > 32) {
-	config.points_per_section = 32;
-    }
-
-    config.num_cross_sections = sqrt(samples) / 3.0;
-
-    if (config.num_cross_sections < 1) {
-	config.num_cross_sections = 1;
-    }
-
-    if (config.num_cross_sections > 5) {
-	config.num_cross_sections = 5;
-    }
-
     VMOVE(config.ell_travel_vector, eip->a);
     VMOVE(config.ell_axis_vector_a, eip->b);
     VMOVE(config.ell_axis_vector_b, eip->c);
     draw_cross_sections_along_ell_vector(config);
 
-    config.num_cross_sections = 1;
-
     VMOVE(config.ell_travel_vector, eip->b);
     VMOVE(config.ell_axis_vector_a, eip->a);
     VMOVE(config.ell_axis_vector_b, eip->c);
     draw_cross_sections_along_ell_vector(config);
 
+    config.num_cross_sections = 16;
     VMOVE(config.ell_travel_vector, eip->c);
     VMOVE(config.ell_axis_vector_a, eip->a);
     VMOVE(config.ell_axis_vector_b, eip->b);
     draw_cross_sections_along_ell_vector(config);
-
-    return 0;
-}
-
-/**
- * R T _ E L L _ P L O T
- */
-int
-rt_ell_plot(struct bu_list *vhead, struct rt_db_internal *ip, const struct rt_tess_tol *UNUSED(ttol), const struct bn_tol *UNUSED(tol), const struct rt_view_info *UNUSED(info))
-{
+#else
     register int i;
     struct rt_ell_internal *eip;
     fastf_t top[16*3];
@@ -848,7 +855,7 @@
     for (i=0; i<16; i++) {
 	RT_ADD_VLIST(vhead, &middle[i*ELEMENTS_PER_VECT], BN_VLIST_LINE_DRAW);
     }
-
+#endif
     return 0;
 }
 
@@ -946,8 +953,8 @@
     int boff;		/* base offset */
     int toff;		/* top offset */
     int blim;		/* base subscript limit */
-    int tlim;		/* top subscript limit */
-    fastf_t dtol;	/* Absolutized relative tolerance */
+    int tlim;		/* top subscrpit limit */
+    fastf_t rel;	/* Absolutized relative tolerance */
 
     RT_CK_DB_INTERNAL(ip);
     state.eip = (struct rt_ell_internal *)ip->idb_ptr;
@@ -1025,16 +1032,35 @@
     if (Clen > radius)
 	radius = Clen;
 
-    dtol = primitive_get_absolute_tolerance(ttol, radius);
-
-    if (dtol > radius) {
-	dtol = radius;
+    /*
+     * Establish tolerances
+     */
+    if (ttol->rel <= 0.0 || ttol->rel >= 1.0) {
+	rel = 0.0;		/* none */
+    } else {
+	/* Convert rel to absolute by scaling by radius */
+	rel = ttol->rel * radius;
     }
+    if (ttol->abs <= 0.0) {
+	if (rel <= 0.0) {
+	    /* No tolerance given, use a default */
+	    rel = 0.10 * radius;	/* 10% */
+	} else {
+	    /* Use absolute-ized relative tolerance */
+	}
+    } else {
+	/* Absolute tolerance was given, pick smaller */
+	if (ttol->rel <= 0.0 || rel > ttol->abs) {
+	    rel = ttol->abs;
+	    if (rel > radius)
+		rel = radius;
+	}
+    }
 
-    /* Convert distance tolerance into a maximum permissible angle
+    /* Converte distance tolerance into a maximum permissible angle
      * tolerance.  'radius' is largest radius.
      */
-    state.theta_tol = 2 * acos(1.0 - dtol / radius);
+    state.theta_tol = 2 * acos(1.0 - rel / radius);
 
     /* To ensure normal tolerance, remain below this angle */
     if (ttol->norm > 0.0 && ttol->norm < state.theta_tol) {
@@ -1050,7 +1076,7 @@
 
     /* Find total number of strips of vertices that will be needed.
      * nsegs for each hemisphere, plus the equator.  Note that faces
-     * are listed in the stripe ABOVE, i.e., toward the poles.
+     * are listed in the the stripe ABOVE, ie, toward the poles.
      * Thus, strips[0] will have 4 faces.
      */
     nstrips = 2 * nsegs + 1;
Index: src/librt/primitives/rhc/rhc_brep.cpp
===================================================================
--- src/librt/primitives/rhc/rhc_brep.cpp	(revision 53222)
+++ src/librt/primitives/rhc/rhc_brep.cpp	(working copy)
@@ -100,7 +100,7 @@
     bcurve->GetNurbForm(*hypnurbscurve);
     delete bcurve;
 
-    // Also need a straight line from the beginning to the end to
+    // Also need a staight line from the beginning to the end to
     // complete the loop.
 
     ON_LineCurve* straightedge = new ON_LineCurve(onp3, onp1);
Index: src/librt/primitives/rhc/rhc.c
===================================================================
--- src/librt/primitives/rhc/rhc.c	(revision 53222)
+++ src/librt/primitives/rhc/rhc.c	(working copy)
@@ -106,7 +106,7 @@
  * NORMALS.  Given the point W on the surface of the rhc, what is the
  * vector normal to the tangent plane at that point?
  *
- * Map W onto the unit rhc, i.e.:  W' = S(R(W - V)).
+ * Map W onto the unit rhc, ie:  W' = S(R(W - V)).
  *
  * Plane on unit rhc at W' has a normal vector N' where
  *
@@ -175,8 +175,6 @@
 
 #include "../../librt_private.h"
 
-static int
-rhc_is_valid(struct rt_rhc_internal *rhc);
 
 struct rhc_specific {
     point_t rhc_V;		/* vector to rhc origin */
@@ -207,8 +205,7 @@
  * Calculate the bounding RPP for an RHC
  */
 int
-rt_rhc_bbox(struct rt_db_internal *ip, point_t *min, point_t *max, const struct bn_tol *UNUSED(tol))
-{
+rt_rhc_bbox(struct rt_db_internal *ip, point_t *min, point_t *max, const struct bn_tol *UNUSED(tol)) {
 
     struct rt_rhc_internal *xip;
     vect_t rinv, rvect, rv2, working;
@@ -279,6 +276,7 @@
     struct rhc_specific *rhc;
     fastf_t magsq_b, magsq_h, magsq_r;
     fastf_t mag_b, mag_h, mag_r;
+    fastf_t f;
     mat_t R;
     mat_t Rinv;
     mat_t S;
@@ -286,11 +284,8 @@
 
     RT_CK_DB_INTERNAL(ip);
     RT_CK_RTI(rtip);
-
     xip = (struct rt_rhc_internal *)ip->idb_ptr;
-    if (!rhc_is_valid(xip)) {
-	return 1;
-    }
+    RT_RHC_CK_MAGIC(xip);
 
     /* compute |B| |H| */
     mag_b = sqrt(magsq_b = MAGSQ(xip->rhc_B));
@@ -298,6 +293,21 @@
     mag_r = xip->rhc_r;
     magsq_r = mag_r * mag_r;
 
+    /* Check for |H| > 0, |B| > 0, |R| > 0 */
+    if (NEAR_ZERO(mag_h, RT_LEN_TOL) || NEAR_ZERO(mag_b, RT_LEN_TOL)
+	|| NEAR_ZERO(mag_r, RT_LEN_TOL)) {
+	return 1;		/* BAD, too small */
+    }
+
+    /* Check for B.H == 0 */
+    f = VDOT(xip->rhc_B, xip->rhc_H) / (mag_b * mag_h);
+    if (! NEAR_ZERO(f, RT_DOT_TOL)) {
+	return 1;		/* BAD */
+    }
+
+    /*
+     * RHC is ok
+     */
     stp->st_id = ID_RHC;		/* set soltab ID */
     stp->st_meth = &rt_functab[ID_RHC];
 
@@ -325,7 +335,7 @@
     bn_mat_trn(Rinv, R);			/* inv of rot mat is trn */
 
     /* Compute S */
-    VSET(invsq, 1.0 / magsq_h, 1.0 / magsq_r, 1.0 / magsq_b);
+    VSET(invsq, 1.0/magsq_h, 1.0/magsq_r, 1.0/magsq_b);
     MAT_IDN(S);
     S[ 0] = sqrt(invsq[0]);
     S[ 5] = sqrt(invsq[1]);
@@ -341,13 +351,11 @@
 	   mag_h / 2.0,	rhc->rhc_Hunit,
 	   mag_b / 2.0,	rhc->rhc_Bunit);
     /* bounding radius */
-    stp->st_bradius = 0.5 * sqrt(magsq_h + 4.0 * magsq_r + magsq_b);
+    stp->st_bradius = 0.5 * sqrt(magsq_h + 4.0*magsq_r + magsq_b);
     /* approximate bounding radius */
     stp->st_aradius = stp->st_bradius;
 
-    if (rt_rhc_bbox(ip, &(stp->st_min), &(stp->st_max), &rtip->rti_tol)) {
-	return 1;
-    }
+    if (rt_rhc_bbox(ip, &(stp->st_min), &(stp->st_max), &rtip->rti_tol)) return 1;
 
     return 0;			/* OK */
 }
@@ -410,28 +418,23 @@
 
     x = rhc->rhc_cprime;
 
-    if (ZERO(dprime[Y]) && ZERO(dprime[Z])) {
+    if (ZERO(dprime[Y]) && ZERO(dprime[Z]))
 	goto check_plates;
-    }
 
     /* Find roots of the equation, using formula for quadratic */
     {
 	fastf_t a, b, c;	/* coeffs of polynomial */
 	fastf_t disc;		/* disc of radical */
 
-	a = dprime[Z] * dprime[Z] - dprime[Y] * dprime[Y] * (1 + 2 * x);
-	b = 2 * ((pprime[Z] + x + 1) * dprime[Z]
-	         - (2 * x + 1) * dprime[Y] * pprime[Y]);
-	c = (pprime[Z] + x + 1) * (pprime[Z] + x + 1)
-	    - (2 * x + 1) * pprime[Y] * pprime[Y] - x * x;
-
+	a = dprime[Z] * dprime[Z] - dprime[Y] * dprime[Y] * (1 + 2*x);
+	b = 2*((pprime[Z] + x + 1) * dprime[Z]
+	       - (2*x + 1) * dprime[Y] * pprime[Y]);
+	c = (pprime[Z]+x+1)*(pprime[Z]+x+1)
+	    - (2*x + 1) * pprime[Y] * pprime[Y] - x*x;
 	if (!NEAR_ZERO(a, RT_PCOEF_TOL)) {
-	    disc = b * b - 4 * a * c;
-
-	    if (disc <= 0) {
-	        goto check_plates;
-	    }
-
+	    disc = b*b - 4 * a * c;
+	    if (disc <= 0)
+		goto check_plates;
 	    disc = sqrt(disc);
 
 	    k1 = (-b + disc) / (2.0 * a);
@@ -442,40 +445,37 @@
 	     * See if they fall in range.
 	     */
 	    VJOIN1(hitp->hit_vpriv, pprime, k1, dprime);		/* hit' */
-
 	    if (hitp->hit_vpriv[X] >= -1.0
-	        && hitp->hit_vpriv[X] <= 0.0
-	        && hitp->hit_vpriv[Z] >= -1.0
-	        && hitp->hit_vpriv[Z] <= 0.0) {
-	        hitp->hit_magic = RT_HIT_MAGIC;
-	        hitp->hit_dist = k1;
-	        hitp->hit_surfno = RHC_NORM_BODY;	/* compute N */
-	        hitp++;
+		&& hitp->hit_vpriv[X] <= 0.0
+		&& hitp->hit_vpriv[Z] >= -1.0
+		&& hitp->hit_vpriv[Z] <= 0.0) {
+		hitp->hit_magic = RT_HIT_MAGIC;
+		hitp->hit_dist = k1;
+		hitp->hit_surfno = RHC_NORM_BODY;	/* compute N */
+		hitp++;
 	    }
 
 	    VJOIN1(hitp->hit_vpriv, pprime, k2, dprime);		/* hit' */
-
 	    if (hitp->hit_vpriv[X] >= -1.0
-	        && hitp->hit_vpriv[X] <= 0.0
-	        && hitp->hit_vpriv[Z] >= -1.0
-	        && hitp->hit_vpriv[Z] <= 0.0) {
-	        hitp->hit_magic = RT_HIT_MAGIC;
-	        hitp->hit_dist = k2;
-	        hitp->hit_surfno = RHC_NORM_BODY;	/* compute N */
-	        hitp++;
+		&& hitp->hit_vpriv[X] <= 0.0
+		&& hitp->hit_vpriv[Z] >= -1.0
+		&& hitp->hit_vpriv[Z] <= 0.0) {
+		hitp->hit_magic = RT_HIT_MAGIC;
+		hitp->hit_dist = k2;
+		hitp->hit_surfno = RHC_NORM_BODY;	/* compute N */
+		hitp++;
 	    }
 	} else if (!NEAR_ZERO(b, RT_PCOEF_TOL)) {
-	    k1 = -c / b;
+	    k1 = -c/b;
 	    VJOIN1(hitp->hit_vpriv, pprime, k1, dprime);		/* hit' */
-
 	    if (hitp->hit_vpriv[X] >= -1.0
-	        && hitp->hit_vpriv[X] <= 0.0
-	        && hitp->hit_vpriv[Z] >= -1.0
-	        && hitp->hit_vpriv[Z] <= 0.0) {
-	        hitp->hit_magic = RT_HIT_MAGIC;
-	        hitp->hit_dist = k1;
-	        hitp->hit_surfno = RHC_NORM_BODY;	/* compute N */
-	        hitp++;
+		&& hitp->hit_vpriv[X] <= 0.0
+		&& hitp->hit_vpriv[Z] >= -1.0
+		&& hitp->hit_vpriv[Z] <= 0.0) {
+		hitp->hit_magic = RT_HIT_MAGIC;
+		hitp->hit_dist = k1;
+		hitp->hit_surfno = RHC_NORM_BODY;	/* compute N */
+		hitp++;
 	    }
 	}
     }
@@ -484,8 +484,7 @@
     /*
      * Check for hitting the top and end plates.
      */
-check_plates:
-
+ check_plates:
     /* check front and back plates */
     if (hitp < &hits[2]  &&  !ZERO(dprime[X])) {
 	/* 0 or 1 hits so far, this is worthwhile */
@@ -493,11 +492,10 @@
 	k2 = (-1.0 - pprime[X]) / dprime[X];	/* back plate */
 
 	VJOIN1(hitp->hit_vpriv, pprime, k1, dprime);	/* hit' */
-
 	if ((hitp->hit_vpriv[Z] + x + 1.0)
 	    * (hitp->hit_vpriv[Z] + x + 1.0)
 	    - hitp->hit_vpriv[Y] * hitp->hit_vpriv[Y]
-	    * (1.0 + 2 * x) >= x * x
+	    * (1.0 + 2*x) >= x*x
 	    && hitp->hit_vpriv[Z] >= -1.0
 	    && hitp->hit_vpriv[Z] <= 0.0) {
 	    hitp->hit_magic = RT_HIT_MAGIC;
@@ -507,11 +505,10 @@
 	}
 
 	VJOIN1(hitp->hit_vpriv, pprime, k2, dprime);	/* hit' */
-
 	if ((hitp->hit_vpriv[Z] + x + 1.0)
 	    * (hitp->hit_vpriv[Z] + x + 1.0)
 	    - hitp->hit_vpriv[Y] * hitp->hit_vpriv[Y]
-	    * (1.0 + 2 * x) >= x * x
+	    * (1.0 + 2*x) >= x*x
 	    && hitp->hit_vpriv[Z] >= -1.0
 	    && hitp->hit_vpriv[Z] <= 0.0) {
 	    hitp->hit_magic = RT_HIT_MAGIC;
@@ -527,7 +524,6 @@
 	k1 = -pprime[Z] / dprime[Z];		/* top plate */
 
 	VJOIN1(hitp->hit_vpriv, pprime, k1, dprime);	/* hit' */
-
 	if (hitp->hit_vpriv[X] >= -1.0 &&  hitp->hit_vpriv[X] <= 0.0
 	    && hitp->hit_vpriv[Y] >= -1.0
 	    && hitp->hit_vpriv[Y] <= 1.0) {
@@ -538,9 +534,8 @@
 	}
     }
 
-    if (hitp != &hits[2]) {
-	return 0;    /* MISS */
-    }
+    if (hitp != &hits[2])
+	return 0;	/* MISS */
 
     if (hits[0].hit_dist < hits[1].hit_dist) {
 	/* entry is [0], exit is [1] */
@@ -561,7 +556,6 @@
 	segp->seg_out = hits[0];	/* struct copy */
 	BU_LIST_INSERT(&(seghead->l), &(segp->l));
     }
-
     return 2;			/* HIT */
 }
 
@@ -580,33 +574,28 @@
 	(struct rhc_specific *)stp->st_specific;
 
     VJOIN1(hitp->hit_point, rp->r_pt, hitp->hit_dist, rp->r_dir);
-
     switch (hitp->hit_surfno) {
-    case RHC_NORM_BODY:
-	c = rhc->rhc_cprime;
-	VSET(can_normal,
-	     0.0,
-	     hitp->hit_vpriv[Y] * (1.0 + 2.0 * c),
-	     -hitp->hit_vpriv[Z] - c - 1.0);
-	MAT4X3VEC(hitp->hit_normal, rhc->rhc_invRoS, can_normal);
-	VUNITIZE(hitp->hit_normal);
-	break;
-
-    case RHC_NORM_TOP:
-	VREVERSE(hitp->hit_normal, rhc->rhc_Bunit);
-	break;
-
-    case RHC_NORM_FRT:
-	VREVERSE(hitp->hit_normal, rhc->rhc_Hunit);
-	break;
-
-    case RHC_NORM_BACK:
-	VMOVE(hitp->hit_normal, rhc->rhc_Hunit);
-	break;
-
-    default:
-	bu_log("rt_rhc_norm: surfno=%d bad\n", hitp->hit_surfno);
-	break;
+	case RHC_NORM_BODY:
+	    c = rhc->rhc_cprime;
+	    VSET(can_normal,
+		 0.0,
+		 hitp->hit_vpriv[Y] * (1.0 + 2.0*c),
+		 -hitp->hit_vpriv[Z] - c - 1.0);
+	    MAT4X3VEC(hitp->hit_normal, rhc->rhc_invRoS, can_normal);
+	    VUNITIZE(hitp->hit_normal);
+	    break;
+	case RHC_NORM_TOP:
+	    VREVERSE(hitp->hit_normal, rhc->rhc_Bunit);
+	    break;
+	case RHC_NORM_FRT:
+	    VREVERSE(hitp->hit_normal, rhc->rhc_Hunit);
+	    break;
+	case RHC_NORM_BACK:
+	    VMOVE(hitp->hit_normal, rhc->rhc_Hunit);
+	    break;
+	default:
+	    bu_log("rt_rhc_norm: surfno=%d bad\n", hitp->hit_surfno);
+	    break;
     }
 }
 
@@ -625,28 +614,27 @@
 	(struct rhc_specific *)stp->st_specific;
 
     switch (hitp->hit_surfno) {
-    case RHC_NORM_BODY:
-	/* most nearly flat direction */
-	VMOVE(cvp->crv_pdir, rhc->rhc_Hunit);
-	cvp->crv_c1 = 0;
-	/* k = z'' / (1 + z'^2) ^ 3/2 */
-	b = rhc->rhc_b;
-	c = rhc->rhc_c;
-	y = hitp->hit_point[Y];
-	rsq = rhc->rhc_rsq;
-	zp1_sq = y * (b * b + 2 * b * c) / rsq;
-	zp1_sq *= zp1_sq / (c * c + y * y * (b * b + 2 * b * c) / rsq);
-	zp2 = c * c / (rsq * c * c + y * y * (b * b + 2 * b * c));
-	cvp->crv_c2 = zp2 / pow((1 + zp1_sq), 1.5);
-	break;
-
-    case RHC_NORM_BACK:
-    case RHC_NORM_FRT:
-    case RHC_NORM_TOP:
-	/* any tangent direction */
-	bn_vec_ortho(cvp->crv_pdir, hitp->hit_normal);
-	cvp->crv_c1 = cvp->crv_c2 = 0;
-	break;
+	case RHC_NORM_BODY:
+	    /* most nearly flat direction */
+	    VMOVE(cvp->crv_pdir, rhc->rhc_Hunit);
+	    cvp->crv_c1 = 0;
+	    /* k = z'' / (1 + z'^2) ^ 3/2 */
+	    b = rhc->rhc_b;
+	    c = rhc->rhc_c;
+	    y = hitp->hit_point[Y];
+	    rsq = rhc->rhc_rsq;
+	    zp1_sq = y * (b*b + 2*b*c) / rsq;
+	    zp1_sq *= zp1_sq / (c*c + y*y*(b*b + 2*b*c)/rsq);
+	    zp2 = c*c / (rsq*c*c + y*y*(b*b + 2*b*c));
+	    cvp->crv_c2 = zp2 / pow((1 + zp1_sq), 1.5);
+	    break;
+	case RHC_NORM_BACK:
+	case RHC_NORM_FRT:
+	case RHC_NORM_TOP:
+	    /* any tangent direction */
+	    bn_vec_ortho(cvp->crv_pdir, hitp->hit_normal);
+	    cvp->crv_c1 = cvp->crv_c2 = 0;
+	    break;
     }
 }
 
@@ -668,9 +656,7 @@
     vect_t pprime;
     fastf_t len;
 
-    if (ap) {
-	RT_CK_APPLICATION(ap);
-    }
+    if (ap) RT_CK_APPLICATION(ap);
 
     /*
      * hit_point is on surface;  project back to unit rhc,
@@ -680,25 +666,23 @@
     MAT4X3VEC(pprime, rhc->rhc_SoR, work);
 
     switch (hitp->hit_surfno) {
-    case RHC_NORM_BODY:
-	/* Skin.  x, y coordinates define rotation.  radius = 1 */
-	len = sqrt(pprime[Y] * pprime[Y] + pprime[Z] * pprime[Z]);
-	uvp->uv_u = acos(pprime[Y] / len) * bn_invpi;
-	uvp->uv_v = -pprime[X];		/* height */
-	break;
-
-    case RHC_NORM_FRT:
-    case RHC_NORM_BACK:
-	/* end plates - circular mapping, not seamless w/body, top */
-	len = sqrt(pprime[Y] * pprime[Y] + pprime[Z] * pprime[Z]);
-	uvp->uv_u = acos(pprime[Y] / len) * bn_invpi;
-	uvp->uv_v = len;	/* rim v = 1 for both plates */
-	break;
-
-    case RHC_NORM_TOP:
-	uvp->uv_u = 1.0 - (pprime[Y] + 1.0) / 2.0;
-	uvp->uv_v = -pprime[X];		/* height */
-	break;
+	case RHC_NORM_BODY:
+	    /* Skin.  x, y coordinates define rotation.  radius = 1 */
+	    len = sqrt(pprime[Y]*pprime[Y] + pprime[Z]*pprime[Z]);
+	    uvp->uv_u = acos(pprime[Y]/len) * bn_invpi;
+	    uvp->uv_v = -pprime[X];		/* height */
+	    break;
+	case RHC_NORM_FRT:
+	case RHC_NORM_BACK:
+	    /* end plates - circular mapping, not seamless w/body, top */
+	    len = sqrt(pprime[Y]*pprime[Y] + pprime[Z]*pprime[Z]);
+	    uvp->uv_u = acos(pprime[Y]/len) * bn_invpi;
+	    uvp->uv_v = len;	/* rim v = 1 for both plates */
+	    break;
+	case RHC_NORM_TOP:
+	    uvp->uv_u = 1.0 - (pprime[Y] + 1.0)/2.0;
+	    uvp->uv_v = -pprime[X];		/* height */
+	    break;
     }
 
     /* uv_du should be relative to rotation, uv_dv relative to height */
@@ -728,232 +712,7 @@
     return 0;
 }
 
-/* Our canonical hyperbola in the Y-Z plane has equation
- * z = +- (a/b) * sqrt(b^2 + y^2), and opens toward +Z and -Z with asymptote
- * origin at the origin.
- *
- * The contour of an rhc in the plane B-R is the positive half of a hyperbola
- * with asymptote origin at ((|B| + c)Bu), opening toward -B. We can transform
- * this hyperbola to get an equivalent canonical hyperbola in the Y-Z plane,
- * opening toward +Z (-B) with asymptote origin at the origin.
- *
- * This hyperbola passes through the point (r, |B| + a) (a = c). If we plug the
- * point (r, |H| + a) into our canonical equation, we can derive b from |B|, a,
- * and r.
- *
- *                             |B| + a = (a/b) * sqrt(b^2 + r^2)
- *                       (|B| + a) / a = b * sqrt(b^2 + r^2)
- *                   (|B| + a)^2 / a^2 = 1 + (r^2 / b^2)
- *           ((|B| + a)^2 - a^2) / a^2 = r^2 / b^2
- *   (a^2 * r^2) / ((|B| + a)^2 - a^2) = b^2
- *      (ar) / sqrt((|B| + a)^2 - a^2) = b
- *         (ar) / sqrt(|B| (|B| + 2a)) = b
- */
-static fastf_t
-rhc_hyperbola_b(fastf_t mag_b, fastf_t c, fastf_t r)
-{
-    return (c * r) / sqrt(mag_b * (mag_b + 2.0 * c));
-}
 
-/* The contour of an rhc in the plane B-R is the positive half of a hyperbola
- * with asymptote origin at ((|B| + c)Bu), opening toward -B. We can transform
- * this hyperbola to get an equivalent hyperbola in the Y-Z plane, opening
- * toward +Z (-B) with asymptote origin at (0, -(|B| + c)).
- *
- * The part of this hyperbola that passes between (0, -(|B| + c)) and (r, 0) is
- * approximated by num_points points (including (0, -|B|) and (r, 0)).
- *
- * The constructed point list is returned (NULL returned on error). Because the
- * above transformation puts the rhc vertex at the origin and the hyperbola
- * asymptote origin at (0, -|B| + c), multiplying the z values by -1 gives
- * corresponding distances along the rhc breadth vector B.
- */
-static struct rt_pt_node *
-rhc_hyperbolic_curve(fastf_t mag_b, fastf_t c, fastf_t r, int num_points)
-{
-    int count;
-    struct rt_pt_node *curve;
-
-    curve = (struct rt_pt_node *)bu_malloc(sizeof(struct rt_pt_node), "rt_pt_node");
-    curve->next = (struct rt_pt_node *)bu_malloc(sizeof(struct rt_pt_node), "rt_pt_node");
-
-    curve->next->next = NULL;
-    VSET(curve->p,       0, 0, -mag_b);
-    VSET(curve->next->p, 0, r, 0);
-
-    count = approximate_hyperbolic_curve(curve, c, rhc_hyperbola_b(mag_b, c, r), num_points - 2);
-
-    if (count != (num_points - 2)) {
-	return NULL;
-    }
-
-    return curve;
-}
-
-/* plot half of a hyperbolic contour curve using the given (r, b) points (pts),
- * translation along H (rhc_H), and multiplier for r (rscale)
- */
-static void
-rhc_plot_hyperbolic_curve(
-	struct bu_list *vhead,
-	struct rhc_specific *rhc,
-	struct rt_pt_node *pts,
-	vect_t rhc_H,
-	fastf_t rscale)
-{
-    vect_t t, Ru, Bu;
-    point_t p;
-    struct rt_pt_node *node;
-
-    VADD2(t, rhc->rhc_V, rhc_H);
-    VMOVE(Ru, rhc->rhc_Runit);
-    VMOVE(Bu, rhc->rhc_Bunit);
-
-    VJOIN2(p, t, rscale * pts->p[Y], Ru, -pts->p[Z], Bu);
-    RT_ADD_VLIST(vhead, p, BN_VLIST_LINE_MOVE);
-
-    node = pts->next;
-    while (node != NULL) {
-	VJOIN2(p, t, rscale * node->p[Y], Ru, -node->p[Z], Bu);
-	RT_ADD_VLIST(vhead, p, BN_VLIST_LINE_DRAW);
-
-	node = node->next;
-    }
-}
-
-static void
-rhc_plot_hyperbolas(
-	struct bu_list *vhead,
-	struct rt_rhc_internal *rhc,
-	struct rt_pt_node *pts)
-{
-    vect_t rhc_H;
-    struct rhc_specific rhc_s;
-
-    VMOVE(rhc_s.rhc_V, rhc->rhc_V);
-
-    VMOVE(rhc_s.rhc_Bunit, rhc->rhc_B);
-    VUNITIZE(rhc_s.rhc_Bunit);
-
-    VCROSS(rhc_s.rhc_Runit, rhc_s.rhc_Bunit, rhc->rhc_H);
-    VUNITIZE(rhc_s.rhc_Runit);
-
-    /* plot hyperbolic contour curve of face containing V */
-    VSETALL(rhc_H, 0.0);
-    rhc_plot_hyperbolic_curve(vhead, &rhc_s, pts, rhc_H, 1.0);
-    rhc_plot_hyperbolic_curve(vhead, &rhc_s, pts, rhc_H, -1.0);
-
-    /* plot hyperbolic contour curve of opposing face */
-    VMOVE(rhc_H, rhc->rhc_H);
-    rhc_plot_hyperbolic_curve(vhead, &rhc_s, pts, rhc_H, 1.0);
-    rhc_plot_hyperbolic_curve(vhead, &rhc_s, pts, rhc_H, -1.0);
-}
-
-static void
-rhc_plot_curve_connections(
-	struct bu_list *vhead,
-	struct rt_rhc_internal *rhc,
-	struct rt_pt_node *pts,
-	fastf_t rscale)
-{
-    struct rt_pt_node *node;
-    vect_t rhc_V, VH, Ru, Bu, R, B, RB;
-    point_t p;
-
-    VMOVE(rhc_V, rhc->rhc_V);
-    VADD2(VH, rhc_V, rhc->rhc_H);
-
-    VMOVE(Bu, rhc->rhc_B);
-    VUNITIZE(Bu);
-
-    VCROSS(Ru, Bu, rhc->rhc_H);
-    VUNITIZE(Ru);
-
-    VSCALE(R, Ru, rscale * pts->p[Y]);
-    VSCALE(B, Bu, -pts->p[Z]);
-    VADD2(RB, R, B);
-
-    node = pts;
-    while (node != NULL) {
-	/* calculate face contour point */
-	VSCALE(R, Ru, rscale * node->p[Y]);
-	VSCALE(B, Bu, -node->p[Z]);
-	VADD2(RB, R, B);
-
-	/* start at point on face containing V */
-	VADD2(p, rhc_V, RB);
-	RT_ADD_VLIST(vhead, p, BN_VLIST_LINE_MOVE);
-
-	/* draw to corresponding point on opposing face */
-	VADD2(p, VH, RB);
-	RT_ADD_VLIST(vhead, p, BN_VLIST_LINE_DRAW);
-
-	node = node->next;
-    }
-}
-
-int
-rt_rhc_adaptive_plot(struct rt_db_internal *ip, const struct rt_view_info *info)
-{
-    point_t p;
-    vect_t rhc_R;
-    int num_curve_points;
-    struct rt_rhc_internal *rhc;
-    struct rt_pt_node *pts, *node, *tmp;
-
-    BU_CK_LIST_HEAD(info->vhead);
-    RT_CK_DB_INTERNAL(ip);
-
-    rhc = (struct rt_rhc_internal *)ip->idb_ptr;
-    if (!rhc_is_valid(rhc)) {
-	return -2;
-    }
-
-    num_curve_points = sqrt(primitive_diagonal_samples(ip, info)) / 4.0;
-
-    if (num_curve_points < 3) {
-	num_curve_points = 3;
-    }
-
-    VCROSS(rhc_R, rhc->rhc_B, rhc->rhc_H);
-    VUNITIZE(rhc_R);
-    VSCALE(rhc_R, rhc_R, rhc->rhc_r);
-
-    pts = rhc_hyperbolic_curve(MAGNITUDE(rhc->rhc_B), rhc->rhc_c, rhc->rhc_r, num_curve_points);
-
-    rhc_plot_hyperbolas(info->vhead, rhc, pts);
-
-    /* connect both halves of the hyperbolic contours of the opposing faces */
-    rhc_plot_curve_connections(info->vhead, rhc, pts, 1.0);
-    rhc_plot_curve_connections(info->vhead, rhc, pts, -1.0);
-
-    /* plot rectangular face */
-    VADD2(p, rhc->rhc_V, rhc_R);
-    RT_ADD_VLIST(info->vhead, p, BN_VLIST_LINE_MOVE);
-
-    VADD2(p, p, rhc->rhc_H);
-    RT_ADD_VLIST(info->vhead, p, BN_VLIST_LINE_DRAW);
-
-    VJOIN1(p, p, -2.0, rhc_R);
-    RT_ADD_VLIST(info->vhead, p, BN_VLIST_LINE_DRAW);
-
-    VJOIN1(p, p, -1.0, rhc->rhc_H);
-    RT_ADD_VLIST(info->vhead, p, BN_VLIST_LINE_DRAW);
-
-    VJOIN1(p, p, 2.0, rhc_R);
-    RT_ADD_VLIST(info->vhead, p, BN_VLIST_LINE_DRAW);
-
-    node = pts;
-    while (node != NULL) {
-	tmp = node;
-	node = node->next;
-
-	bu_free(tmp, "rt_pt_node");
-    }
-
-    return 0;
-}
-
 /**
  * R T _ R H C _ P L O T
  */
@@ -961,7 +720,7 @@
 rt_rhc_plot(struct bu_list *vhead, struct rt_db_internal *ip, const struct rt_tess_tol *ttol, const struct bn_tol *UNUSED(tol), const struct rt_view_info *UNUSED(info))
 {
     int i, n;
-    fastf_t b, c, *back, *front, h, rh;
+    fastf_t b, c, *back, f, *front, h, rh;
     fastf_t dtol, ntol;
     vect_t Bu, Hu, Ru;
     mat_t R;
@@ -971,11 +730,8 @@
 
     BU_CK_LIST_HEAD(vhead);
     RT_CK_DB_INTERNAL(ip);
-
     xip = (struct rt_rhc_internal *)ip->idb_ptr;
-    if (!rhc_is_valid(xip)) {
-	return -2;
-    }
+    RT_RHC_CK_MAGIC(xip);
 
     /* compute |B| |H| */
     b = MAGNITUDE(xip->rhc_B);	/* breadth */
@@ -983,6 +739,20 @@
     h = MAGNITUDE(xip->rhc_H);	/* height */
     c = xip->rhc_c;			/* dist to asympt origin */
 
+    /* Check for |H| > 0, |B| > 0, rh > 0, c > 0 */
+    if (NEAR_ZERO(h, RT_LEN_TOL) || NEAR_ZERO(b, RT_LEN_TOL)
+	|| NEAR_ZERO(rh, RT_LEN_TOL) || NEAR_ZERO(c, RT_LEN_TOL)) {
+	bu_log("rt_rhc_plot:  zero length H, B, c, or rh\n");
+	return -2;		/* BAD */
+    }
+
+    /* Check for B.H == 0 */
+    f = VDOT(xip->rhc_B, xip->rhc_H) / (b * h);
+    if (! NEAR_ZERO(f, RT_DOT_TOL)) {
+	bu_log("rt_rhc_plot: B not perpendicular to H, f=%f\n", f);
+	return -3;		/* BAD */
+    }
+
     /* make unit vectors in B, H, and BxH directions */
     VMOVE(Hu, xip->rhc_H);
     VUNITIZE(Hu);
@@ -997,20 +767,40 @@
     VREVERSE(&R[8], Bu);
     bn_mat_trn(invR, R);			/* inv of rot mat is trn */
 
-    if (rh < b) {
-	dtol = primitive_get_absolute_tolerance(ttol, 2.0 * rh);
+    /*
+     * Establish tolerances
+     */
+    if (ttol->rel <= 0.0 || ttol->rel >= 1.0) {
+	dtol = 0.0;		/* none */
     } else {
-	dtol = primitive_get_absolute_tolerance(ttol, 2.0 * b);
+	/* Convert rel to absolute by scaling by smallest side */
+	if (rh < b)
+	    dtol = ttol->rel * 2 * rh;
+	else
+	    dtol = ttol->rel * 2 * b;
     }
+    if (ttol->abs <= 0.0) {
+	if (dtol <= 0.0) {
+	    /* No tolerance given, use a default */
+	    if (rh < b)
+		dtol = 2 * 0.10 * rh;	/* 10% */
+	    else
+		dtol = 2 * 0.10 * b;	/* 10% */
+	} else {
+	    /* Use absolute-ized relative tolerance */
+	}
+    } else {
+	/* Absolute tolerance was given, pick smaller */
+	if (ttol->rel <= 0.0 || dtol > ttol->abs)
+	    dtol = ttol->abs;
+    }
 
     /* To ensure normal tolerance, remain below this angle */
-    if (ttol->norm > 0.0) {
+    if (ttol->norm > 0.0)
 	ntol = ttol->norm;
-    } else
+    else
 	/* tolerate everything */
-    {
 	ntol = bn_pi;
-    }
 
     /* initial hyperbola approximation is a single segment */
     pts = (struct rt_pt_node *)bu_malloc(sizeof(struct rt_pt_node), "rt_pt_node");
@@ -1024,13 +814,12 @@
     n += rt_mk_hyperbola(pts, rh, b, c, dtol, ntol);
 
     /* get mem for arrays */
-    front = (fastf_t *)bu_malloc(3 * n * sizeof(fastf_t), "fast_t");
-    back  = (fastf_t *)bu_malloc(3 * n * sizeof(fastf_t), "fast_t");
+    front = (fastf_t *)bu_malloc(3*n * sizeof(fastf_t), "fast_t");
+    back  = (fastf_t *)bu_malloc(3*n * sizeof(fastf_t), "fast_t");
 
     /* generate front & back plates in world coordinates */
     pos = pts;
     i = 0;
-
     while (pos) {
 	/* rotate back to original position */
 	MAT4X3VEC(&front[i], invR, pos->p);
@@ -1045,24 +834,22 @@
     }
 
     /* Draw the front */
-    RT_ADD_VLIST(vhead, &front[(n - 1)*ELEMENTS_PER_VECT],
-	         BN_VLIST_LINE_MOVE);
-
+    RT_ADD_VLIST(vhead, &front[(n-1)*ELEMENTS_PER_VECT],
+		 BN_VLIST_LINE_MOVE);
     for (i = 0; i < n; i++) {
-	RT_ADD_VLIST(vhead, &front[i * ELEMENTS_PER_VECT], BN_VLIST_LINE_DRAW);
+	RT_ADD_VLIST(vhead, &front[i*ELEMENTS_PER_VECT], BN_VLIST_LINE_DRAW);
     }
 
     /* Draw the back */
-    RT_ADD_VLIST(vhead, &back[(n - 1)*ELEMENTS_PER_VECT], BN_VLIST_LINE_MOVE);
-
+    RT_ADD_VLIST(vhead, &back[(n-1)*ELEMENTS_PER_VECT], BN_VLIST_LINE_MOVE);
     for (i = 0; i < n; i++) {
-	RT_ADD_VLIST(vhead, &back[i * ELEMENTS_PER_VECT], BN_VLIST_LINE_DRAW);
+	RT_ADD_VLIST(vhead, &back[i*ELEMENTS_PER_VECT], BN_VLIST_LINE_DRAW);
     }
 
     /* Draw connections */
     for (i = 0; i < n; i++) {
-	RT_ADD_VLIST(vhead, &front[i * ELEMENTS_PER_VECT], BN_VLIST_LINE_MOVE);
-	RT_ADD_VLIST(vhead, &back[i * ELEMENTS_PER_VECT], BN_VLIST_LINE_DRAW);
+	RT_ADD_VLIST(vhead, &front[i*ELEMENTS_PER_VECT], BN_VLIST_LINE_MOVE);
+	RT_ADD_VLIST(vhead, &back[i*ELEMENTS_PER_VECT], BN_VLIST_LINE_DRAW);
     }
 
     /* free mem */
@@ -1099,48 +886,36 @@
     intr = p0[Z] - m * p0[Y];
     /* find point on hyperbola with max dist between hyperbola and line */
     j = b + c;
-    k = 1 - m * m * r * r / (b * (b + 2 * c));
+    k = 1 - m*m*r*r/(b*(b + 2*c));
     A = k;
-    B = 2 * j * k;
-    C = j * j * k - c * c;
-    discr = sqrt(B * B - 4 * A * C);
+    B = 2*j*k;
+    C = j*j*k - c*c;
+    discr = sqrt(B*B - 4*A*C);
     z0 = (-B + discr) / (2. * A);
-
-    if (z0 + RHC_TOL >= -b) {	/* use top sheet of hyperboloid */
+    if (z0+RHC_TOL >= -b)	/* use top sheet of hyperboloid */
 	mpt[Z] = z0;
-    } else {
+    else
 	mpt[Z] = (-B - discr) / (2. * A);
-    }
-
-    if (NEAR_ZERO(mpt[Z], RHC_TOL)) {
+    if (NEAR_ZERO(mpt[Z], RHC_TOL))
 	mpt[Z] = 0.;
-    }
-
     mpt[X] = 0;
-    mpt[Y] = ((mpt[Z] + b + c) * (mpt[Z] + b + c) - c * c) / (b * (b + 2 * c));
-
-    if (NEAR_ZERO(mpt[Y], RHC_TOL)) {
+    mpt[Y] = ((mpt[Z] + b + c) * (mpt[Z] + b + c) - c*c) / (b*(b + 2*c));
+    if (NEAR_ZERO(mpt[Y], RHC_TOL))
 	mpt[Y] = 0.;
-    }
-
     mpt[Y] = r * sqrt(mpt[Y]);
-
-    if (p0[Y] < 0.) {
+    if (p0[Y] < 0.)
 	mpt[Y] = -mpt[Y];
-    }
-
     /* max distance between that point and line */
     dist = fabs(m * mpt[Y] - mpt[Z] + intr) / sqrt(m * m + 1);
     /* angles between normal of line and of hyperbola at line endpoints */
     VSET(norm_line, m, -1., 0.);
-    VSET(norm_hyperb, 0., (2 * c + 1) / (p0[Z] + c + 1), -1.);
+    VSET(norm_hyperb, 0., (2*c + 1) / (p0[Z] + c + 1), -1.);
     VUNITIZE(norm_line);
     VUNITIZE(norm_hyperb);
     theta0 = fabs(acos(VDOT(norm_line, norm_hyperb)));
-    VSET(norm_hyperb, 0., (2 * c + 1) / (p1[Z] + c + 1), -1.);
+    VSET(norm_hyperb, 0., (2*c + 1) / (p1[Z] + c + 1), -1.);
     VUNITIZE(norm_hyperb);
     theta1 = fabs(acos(VDOT(norm_line, norm_hyperb)));
-
     /* split segment at widest point if not within error tolerances */
     if (dist > dtol || theta0 > ntol || theta1 > ntol) {
 	/* split segment */
@@ -1154,10 +929,8 @@
 	n += rt_mk_hyperbola(pts, r, b, c, dtol, ntol);
 	/* recurse on second new segment */
 	n += rt_mk_hyperbola(newpt, r, b, c, dtol, ntol);
-    } else {
+    } else
 	n  = 0;
-    }
-
     return n;
 }
 
@@ -1173,7 +946,7 @@
 rt_rhc_tess(struct nmgregion **r, struct model *m, struct rt_db_internal *ip, const struct rt_tess_tol *ttol, const struct bn_tol *tol)
 {
     int i, j, n;
-    fastf_t b, c, *back, *front, h, rh;
+    fastf_t b, c, *back, f, *front, h, rh;
     fastf_t dtol, ntol;
     vect_t Bu, Hu, Ru;
     mat_t R;
@@ -1185,18 +958,15 @@
     struct vertex **vfront, **vback, **vtemp, *vertlist[4];
     vect_t *norms;
     fastf_t bb_plus_2bc, b_plus_c, r_sq;
-    int failure = 0;
+    int failure=0;
 
     NMG_CK_MODEL(m);
     BN_CK_TOL(tol);
     RT_CK_TESS_TOL(ttol);
 
     RT_CK_DB_INTERNAL(ip);
-
     xip = (struct rt_rhc_internal *)ip->idb_ptr;
-    if (!rhc_is_valid(xip)) {
-	return -2;
-    }
+    RT_RHC_CK_MAGIC(xip);
 
     /* compute |B| |H| */
     b = MAGNITUDE(xip->rhc_B);	/* breadth */
@@ -1204,6 +974,20 @@
     h = MAGNITUDE(xip->rhc_H);	/* height */
     c = xip->rhc_c;			/* dist to asympt origin */
 
+    /* Check for |H| > 0, |B| > 0, rh > 0, c > 0 */
+    if (NEAR_ZERO(h, RT_LEN_TOL) || NEAR_ZERO(b, RT_LEN_TOL)
+	|| NEAR_ZERO(rh, RT_LEN_TOL) || NEAR_ZERO(c, RT_LEN_TOL)) {
+	bu_log("rt_rhc_tess:  zero length H, B, c, or rh\n");
+	return -2;		/* BAD */
+    }
+
+    /* Check for B.H == 0 */
+    f = VDOT(xip->rhc_B, xip->rhc_H) / (b * h);
+    if (! NEAR_ZERO(f, RT_DOT_TOL)) {
+	bu_log("rt_rhc_tess: B not perpendicular to H, f=%f\n", f);
+	return -3;		/* BAD */
+    }
+
     /* make unit vectors in B, H, and BxH directions */
     VMOVE(Hu, xip->rhc_H);
     VUNITIZE(Hu);
@@ -1218,20 +1002,40 @@
     VREVERSE(&R[8], Bu);
     bn_mat_trn(invR, R);			/* inv of rot mat is trn */
 
-    if (rh < b) {
-	dtol = primitive_get_absolute_tolerance(ttol, 2.0 * rh);
+    /*
+     * Establish tolerances
+     */
+    if (ttol->rel <= 0.0 || ttol->rel >= 1.0) {
+	dtol = 0.0;		/* none */
     } else {
-	dtol = primitive_get_absolute_tolerance(ttol, 2.0 * b);
+	/* Convert rel to absolute by scaling by smallest side */
+	if (rh < b)
+	    dtol = ttol->rel * 2 * rh;
+	else
+	    dtol = ttol->rel * 2 * b;
     }
+    if (ttol->abs <= 0.0) {
+	if (dtol <= 0.0) {
+	    /* No tolerance given, use a default */
+	    if (rh < b)
+		dtol = 2 * 0.10 * rh;	/* 10% */
+	    else
+		dtol = 2 * 0.10 * b;	/* 10% */
+	} else {
+	    /* Use absolute-ized relative tolerance */
+	}
+    } else {
+	/* Absolute tolerance was given, pick smaller */
+	if (ttol->rel <= 0.0 || dtol > ttol->abs)
+	    dtol = ttol->abs;
+    }
 
     /* To ensure normal tolerance, remain below this angle */
-    if (ttol->norm > 0.0) {
+    if (ttol->norm > 0.0)
 	ntol = ttol->norm;
-    } else
+    else
 	/* tolerate everything */
-    {
 	ntol = bn_pi;
-    }
 
     /* initial hyperbola approximation is a single segment */
     pts = (struct rt_pt_node *)bu_malloc(sizeof(struct rt_pt_node), "rt_pt_node");
@@ -1245,33 +1049,31 @@
     n += rt_mk_hyperbola(pts, rh, b, c, dtol, ntol);
 
     /* get mem for arrays */
-    front = (fastf_t *)bu_malloc(3 * n * sizeof(fastf_t), "fastf_t");
-    back  = (fastf_t *)bu_malloc(3 * n * sizeof(fastf_t), "fastf_t");
+    front = (fastf_t *)bu_malloc(3*n * sizeof(fastf_t), "fastf_t");
+    back  = (fastf_t *)bu_malloc(3*n * sizeof(fastf_t), "fastf_t");
     norms = (vect_t *)bu_calloc(n, sizeof(vect_t), "rt_rhc_tess: norms");
-    vfront = (struct vertex **)bu_malloc((n + 1) * sizeof(struct vertex *), "vertex *");
-    vback = (struct vertex **)bu_malloc((n + 1) * sizeof(struct vertex *), "vertex *");
-    vtemp = (struct vertex **)bu_malloc((n + 1) * sizeof(struct vertex *), "vertex *");
+    vfront = (struct vertex **)bu_malloc((n+1) * sizeof(struct vertex *), "vertex *");
+    vback = (struct vertex **)bu_malloc((n+1) * sizeof(struct vertex *), "vertex *");
+    vtemp = (struct vertex **)bu_malloc((n+1) * sizeof(struct vertex *), "vertex *");
     outfaceuses =
-	(struct faceuse **)bu_malloc((n + 2) * sizeof(struct faceuse *), "faceuse *");
-
+	(struct faceuse **)bu_malloc((n+2) * sizeof(struct faceuse *), "faceuse *");
     if (!front || !back || !vfront || !vback || !vtemp || !outfaceuses) {
 	fprintf(stderr, "rt_rhc_tess: no memory!\n");
 	goto fail;
     }
 
     /* generate front & back plates in world coordinates */
-    bb_plus_2bc = b * b + 2.0 * b * c;
+    bb_plus_2bc = b*b + 2.0*b*c;
     b_plus_c = b + c;
-    r_sq = rh * rh;
+    r_sq = rh*rh;
     pos = pts;
     i = 0;
     j = 0;
-
     while (pos) {
 	vect_t tmp_norm;
 
 	/* calculate normal for 2D hyperbola */
-	VSET(tmp_norm, 0.0, pos->p[Y]*bb_plus_2bc, (-r_sq * (pos->p[Z] + b_plus_c)));
+	VSET(tmp_norm, 0.0, pos->p[Y]*bb_plus_2bc, (-r_sq*(pos->p[Z]+b_plus_c)));
 	MAT4X3VEC(norms[j], invR, tmp_norm);
 	VUNITIZE(norms[j]);
 	/* rotate back to original position */
@@ -1290,7 +1092,7 @@
     *r = nmg_mrsv(m);	/* Make region, empty shell, vertex */
     s = BU_LIST_FIRST(shell, &(*r)->s_hd);
 
-    for (i = 0; i < n; i++) {
+    for (i=0; i<n; i++) {
 	vfront[i] = vtemp[i] = (struct vertex *)0;
     }
 
@@ -1301,11 +1103,8 @@
 
     /* Back face topology.  Verts must go in opposite dir (CW) */
     outfaceuses[1] = nmg_cface(s, vtemp, n);
+    for (i=0; i<n; i++) vback[i] = vtemp[n-1-i];
 
-    for (i = 0; i < n; i++) {
-	vback[i] = vtemp[n - 1 - i];
-    }
-
     (void)nmg_mark_edges_real(&outfaceuses[1]->l.magic);
 
     /* Duplicate [0] as [n] to handle loop end condition, below */
@@ -1316,32 +1115,31 @@
      * connecting the front and back faces.
      * increasing indices go towards counter-clockwise (CCW).
      */
-    for (i = 0; i < n; i++) {
+    for (i=0; i<n; i++) {
 	vertlist[0] = vfront[i];	/* from top, */
 	vertlist[1] = vback[i];		/* straight down, */
-	vertlist[2] = vback[i + 1];	/* to left, */
-	vertlist[3] = vfront[i + 1];	/* straight up. */
-	outfaceuses[2 + i] = nmg_cface(s, vertlist, 4);
+	vertlist[2] = vback[i+1];	/* to left, */
+	vertlist[3] = vfront[i+1];	/* straight up. */
+	outfaceuses[2+i] = nmg_cface(s, vertlist, 4);
     }
 
-    (void)nmg_mark_edges_real(&outfaceuses[n + 1]->l.magic);
+    (void)nmg_mark_edges_real(&outfaceuses[n+1]->l.magic);
 
-    for (i = 0; i < n; i++) {
+    for (i=0; i<n; i++) {
 	NMG_CK_VERTEX(vfront[i]);
 	NMG_CK_VERTEX(vback[i]);
     }
 
     /* Associate the vertex geometry, CCW */
-    for (i = 0; i < n; i++) {
-	nmg_vertex_gv(vfront[i], &front[3 * (i)]);
+    for (i=0; i<n; i++) {
+	nmg_vertex_gv(vfront[i], &front[3*(i)]);
     }
-
-    for (i = 0; i < n; i++) {
-	nmg_vertex_gv(vback[i], &back[3 * (i)]);
+    for (i=0; i<n; i++) {
+	nmg_vertex_gv(vback[i], &back[3*(i)]);
     }
 
     /* Associate the face geometry */
-    for (i = 0; i < n + 2; i++) {
+    for (i=0; i < n+2; i++) {
 	if (nmg_fu_planeeqn(outfaceuses[i], tol) < 0) {
 	    failure = (-1);
 	    goto fail;
@@ -1349,7 +1147,7 @@
     }
 
     /* Associate vertexuse normals */
-    for (i = 0; i < n; i++) {
+    for (i=0; i<n; i++) {
 	struct vertexuse *vu;
 	struct faceuse *fu;
 	vect_t rev_norm;
@@ -1358,62 +1156,54 @@
 
 	/* do "front" vertices */
 	NMG_CK_VERTEX(vfront[i]);
-
 	for (BU_LIST_FOR(vu, vertexuse, &vfront[i]->vu_hd)) {
 	    NMG_CK_VERTEXUSE(vu);
 	    fu = nmg_find_fu_of_vu(vu);
 	    NMG_CK_FACEUSE(fu);
-
 	    if (fu->f_p == outfaceuses[0]->f_p ||
-	        fu->f_p == outfaceuses[1]->f_p ||
-	        fu->f_p == outfaceuses[n + 1]->f_p) {
-	        continue;    /* skip flat faces */
-	    }
+		fu->f_p == outfaceuses[1]->f_p ||
+		fu->f_p == outfaceuses[n+1]->f_p)
+		continue;	/* skip flat faces */
 
-	    if (fu->orientation == OT_SAME) {
-	        nmg_vertexuse_nv(vu, norms[i]);
-	    } else if (fu->orientation == OT_OPPOSITE) {
-	        nmg_vertexuse_nv(vu, rev_norm);
-	    }
+	    if (fu->orientation == OT_SAME)
+		nmg_vertexuse_nv(vu, norms[i]);
+	    else if (fu->orientation == OT_OPPOSITE)
+		nmg_vertexuse_nv(vu, rev_norm);
 	}
 
 	/* and "back" vertices */
 	NMG_CK_VERTEX(vback[i]);
-
 	for (BU_LIST_FOR(vu, vertexuse, &vback[i]->vu_hd)) {
 	    NMG_CK_VERTEXUSE(vu);
 	    fu = nmg_find_fu_of_vu(vu);
 	    NMG_CK_FACEUSE(fu);
-
 	    if (fu->f_p == outfaceuses[0]->f_p ||
-	        fu->f_p == outfaceuses[1]->f_p ||
-	        fu->f_p == outfaceuses[n + 1]->f_p) {
-	        continue;    /* skip flat faces */
-	    }
+		fu->f_p == outfaceuses[1]->f_p ||
+		fu->f_p == outfaceuses[n+1]->f_p)
+		continue;	/* skip flat faces */
 
-	    if (fu->orientation == OT_SAME) {
-	        nmg_vertexuse_nv(vu, norms[i]);
-	    } else if (fu->orientation == OT_OPPOSITE) {
-	        nmg_vertexuse_nv(vu, rev_norm);
-	    }
+	    if (fu->orientation == OT_SAME)
+		nmg_vertexuse_nv(vu, norms[i]);
+	    else if (fu->orientation == OT_OPPOSITE)
+		nmg_vertexuse_nv(vu, rev_norm);
 	}
     }
 
     /* Glue the edges of different outward pointing face uses together */
-    nmg_gluefaces(outfaceuses, n + 2, tol);
+    nmg_gluefaces(outfaceuses, n+2, tol);
 
     /* Compute "geometry" for region and shell */
     nmg_region_a(*r, tol);
 
-fail:
+ fail:
     /* free mem */
     bu_free((char *)front, "fastf_t");
     bu_free((char *)back, "fastf_t");
-    bu_free((char *)vfront, "vertex *");
-    bu_free((char *)vback, "vertex *");
-    bu_free((char *)vtemp, "vertex *");
+    bu_free((char*)vfront, "vertex *");
+    bu_free((char*)vback, "vertex *");
+    bu_free((char*)vtemp, "vertex *");
     bu_free((char *)norms, "rt_rhc_tess: norms");
-    bu_free((char *)outfaceuses, "faceuse *");
+    bu_free((char*)outfaceuses, "faceuse *");
 
     return failure;
 }
@@ -1432,13 +1222,10 @@
     union record *rp;
     vect_t v1, v2, v3;
 
-    if (dbip) {
-	RT_CK_DBI(dbip);
-    }
+    if (dbip) RT_CK_DBI(dbip);
 
     BU_CK_EXTERNAL(ep);
     rp = (union record *)ep->ext_buf;
-
     /* Check record type */
     if (rp->u_id != ID_SOLID) {
 	bu_log("rt_rhc_import4: defective record\n");
@@ -1454,18 +1241,16 @@
     xip->rhc_magic = RT_RHC_INTERNAL_MAGIC;
 
     /* Warning:  type conversion */
-    if (mat == NULL) {
-	mat = bn_mat_identity;
-    }
+    if (mat == NULL) mat = bn_mat_identity;
 
     if (dbip->dbi_version < 0) {
-	flip_fastf_float(v1, &rp->s.s_values[0 * 3], 1, 1);
-	flip_fastf_float(v2, &rp->s.s_values[1 * 3], 1, 1);
-	flip_fastf_float(v3, &rp->s.s_values[2 * 3], 1, 1);
+	flip_fastf_float(v1, &rp->s.s_values[0*3], 1, 1);
+	flip_fastf_float(v2, &rp->s.s_values[1*3], 1, 1);
+	flip_fastf_float(v3, &rp->s.s_values[2*3], 1, 1);
     } else {
-	VMOVE(v1, &rp->s.s_values[0 * 3]);
-	VMOVE(v2, &rp->s.s_values[1 * 3]);
-	VMOVE(v3, &rp->s.s_values[2 * 3]);
+	VMOVE(v1, &rp->s.s_values[0*3]);
+	VMOVE(v2, &rp->s.s_values[1*3]);
+	VMOVE(v3, &rp->s.s_values[2*3]);
     }
 
     MAT4X3PNT(xip->rhc_V, mat, v1);
@@ -1473,11 +1258,11 @@
     MAT4X3VEC(xip->rhc_B, mat, v3);
 
     if (dbip->dbi_version < 0) {
-	v1[X] = flip_dbfloat(rp->s.s_values[3 * 3 + 0]);
-	v1[Y] = flip_dbfloat(rp->s.s_values[3 * 3 + 1]);
+	v1[X] = flip_dbfloat(rp->s.s_values[3*3+0]);
+	v1[Y] = flip_dbfloat(rp->s.s_values[3*3+1]);
     } else {
-	v1[X] = rp->s.s_values[3 * 3 + 0];
-	v1[Y] = rp->s.s_values[3 * 3 + 1];
+	v1[X] = rp->s.s_values[3*3+0];
+	v1[Y] = rp->s.s_values[3*3+1];
     }
 
     xip->rhc_r = v1[X] / mat[15];
@@ -1504,20 +1289,12 @@
     struct rt_rhc_internal *xip;
     union record *rhc;
 
-    if (dbip) {
-	RT_CK_DBI(dbip);
-    }
+    if (dbip) RT_CK_DBI(dbip);
 
     RT_CK_DB_INTERNAL(ip);
-
-    if (ip->idb_type != ID_RHC) {
-	return -1;
-    }
-
+    if (ip->idb_type != ID_RHC) return -1;
     xip = (struct rt_rhc_internal *)ip->idb_ptr;
-    if (!rhc_is_valid(xip)) {
-	return -1;
-    }
+    RT_RHC_CK_MAGIC(xip);
 
     BU_CK_EXTERNAL(ep);
     ep->ext_nbytes = sizeof(union record);
@@ -1527,12 +1304,33 @@
     rhc->s.s_id = ID_SOLID;
     rhc->s.s_type = RHC;
 
+    if (MAGNITUDE(xip->rhc_B) < RT_LEN_TOL
+	|| MAGNITUDE(xip->rhc_H) < RT_LEN_TOL
+	|| xip->rhc_r < RT_LEN_TOL
+	|| xip->rhc_c < RT_LEN_TOL) {
+	bu_log("rt_rhc_export4: not all dimensions positive!\n");
+	return -1;
+    }
+
+    {
+	vect_t ub, uh;
+
+	VMOVE(ub, xip->rhc_B);
+	VUNITIZE(ub);
+	VMOVE(uh, xip->rhc_H);
+	VUNITIZE(uh);
+	if (!NEAR_ZERO(VDOT(ub, uh), RT_DOT_TOL)) {
+	    bu_log("rt_rhc_export4: B and H are not perpendicular!\n");
+	    return -1;
+	}
+    }
+
     /* Warning:  type conversion */
-    VSCALE(&rhc->s.s_values[0 * 3], xip->rhc_V, local2mm);
-    VSCALE(&rhc->s.s_values[1 * 3], xip->rhc_H, local2mm);
-    VSCALE(&rhc->s.s_values[2 * 3], xip->rhc_B, local2mm);
-    rhc->s.s_values[3 * 3] = xip->rhc_r * local2mm;
-    rhc->s.s_values[3 * 3 + 1] = xip->rhc_c * local2mm;
+    VSCALE(&rhc->s.s_values[0*3], xip->rhc_V, local2mm);
+    VSCALE(&rhc->s.s_values[1*3], xip->rhc_H, local2mm);
+    VSCALE(&rhc->s.s_values[2*3], xip->rhc_B, local2mm);
+    rhc->s.s_values[3*3] = xip->rhc_r * local2mm;
+    rhc->s.s_values[3*3+1] = xip->rhc_c * local2mm;
 
     return 0;
 }
@@ -1550,12 +1348,10 @@
     struct rt_rhc_internal *xip;
     fastf_t vec[11];
 
-    if (dbip) {
-	RT_CK_DBI(dbip);
-    }
+    if (dbip) RT_CK_DBI(dbip);
 
     BU_CK_EXTERNAL(ep);
-    BU_ASSERT_LONG(ep->ext_nbytes, == , SIZEOF_NETWORK_DOUBLE * 11);
+    BU_ASSERT_LONG(ep->ext_nbytes, ==, SIZEOF_NETWORK_DOUBLE * 11);
 
     RT_CK_DB_INTERNAL(ip);
     ip->idb_major_type = DB5_MAJORTYPE_BRLCAD;
@@ -1570,16 +1366,13 @@
     ntohd((unsigned char *)vec, ep->ext_buf, 11);
 
     /* Apply modeling transformations */
-    if (mat == NULL) {
-	mat = bn_mat_identity;
-    }
+    if (mat == NULL) mat = bn_mat_identity;
+    MAT4X3PNT(xip->rhc_V, mat, &vec[0*3]);
+    MAT4X3VEC(xip->rhc_H, mat, &vec[1*3]);
+    MAT4X3VEC(xip->rhc_B, mat, &vec[2*3]);
+    xip->rhc_r = vec[3*3] / mat[15];
+    xip->rhc_c = vec[3*3+1] / mat[15];
 
-    MAT4X3PNT(xip->rhc_V, mat, &vec[0 * 3]);
-    MAT4X3VEC(xip->rhc_H, mat, &vec[1 * 3]);
-    MAT4X3VEC(xip->rhc_B, mat, &vec[2 * 3]);
-    xip->rhc_r = vec[3 * 3] / mat[15];
-    xip->rhc_c = vec[3 * 3 + 1] / mat[15];
-
     if (xip->rhc_r <= SMALL_FASTF || xip->rhc_c <= SMALL_FASTF) {
 	bu_log("rt_rhc_import4: r or c are zero\n");
 	bu_free((char *)ip->idb_ptr, "rt_rhc_import4: ip->idb_ptr");
@@ -1601,31 +1394,44 @@
     struct rt_rhc_internal *xip;
     fastf_t vec[11];
 
-    if (dbip) {
-	RT_CK_DBI(dbip);
-    }
+    if (dbip) RT_CK_DBI(dbip);
 
     RT_CK_DB_INTERNAL(ip);
-
-    if (ip->idb_type != ID_RHC) {
-	return -1;
-    }
-
+    if (ip->idb_type != ID_RHC) return -1;
     xip = (struct rt_rhc_internal *)ip->idb_ptr;
-    if (!rhc_is_valid(xip)) {
-	return -1;
-    }
+    RT_RHC_CK_MAGIC(xip);
 
     BU_CK_EXTERNAL(ep);
     ep->ext_nbytes = SIZEOF_NETWORK_DOUBLE * 11;
     ep->ext_buf = (genptr_t)bu_malloc(ep->ext_nbytes, "rhc external");
 
+    if (MAGNITUDE(xip->rhc_B) < RT_LEN_TOL
+	|| MAGNITUDE(xip->rhc_H) < RT_LEN_TOL
+	|| xip->rhc_r < RT_LEN_TOL
+	|| xip->rhc_c < RT_LEN_TOL) {
+	bu_log("rt_rhc_export4: not all dimensions positive!\n");
+	return -1;
+    }
+
+    {
+	vect_t ub, uh;
+
+	VMOVE(ub, xip->rhc_B);
+	VUNITIZE(ub);
+	VMOVE(uh, xip->rhc_H);
+	VUNITIZE(uh);
+	if (!NEAR_ZERO(VDOT(ub, uh), RT_DOT_TOL)) {
+	    bu_log("rt_rhc_export4: B and H are not perpendicular!\n");
+	    return -1;
+	}
+    }
+
     /* scale 'em into local buffer */
-    VSCALE(&vec[0 * 3], xip->rhc_V, local2mm);
-    VSCALE(&vec[1 * 3], xip->rhc_H, local2mm);
-    VSCALE(&vec[2 * 3], xip->rhc_B, local2mm);
-    vec[3 * 3] = xip->rhc_r * local2mm;
-    vec[3 * 3 + 1] = xip->rhc_c * local2mm;
+    VSCALE(&vec[0*3], xip->rhc_V, local2mm);
+    VSCALE(&vec[1*3], xip->rhc_H, local2mm);
+    VSCALE(&vec[2*3], xip->rhc_B, local2mm);
+    vec[3*3] = xip->rhc_r * local2mm;
+    vec[3*3+1] = xip->rhc_c * local2mm;
 
     /* Convert from internal (host) to database (network) format */
     htond(ep->ext_buf, (unsigned char *)vec, 11);
@@ -1651,9 +1457,8 @@
     RT_RHC_CK_MAGIC(xip);
     bu_vls_strcat(str, "Right Hyperbolic Cylinder (RHC)\n");
 
-    if (!verbose) {
+    if (!verbose)
 	return 0;
-    }
 
     sprintf(buf, "\tV (%g, %g, %g)\n",
 	    INTCLAMP(xip->rhc_V[X] * mm2local),
@@ -1713,41 +1518,12 @@
 int
 rt_rhc_params(struct pc_pc_set *UNUSED(ps), const struct rt_db_internal *ip)
 {
-    if (ip) {
-	RT_CK_DB_INTERNAL(ip);
-    }
+    if (ip) RT_CK_DB_INTERNAL(ip);
 
     return 0;			/* OK */
 }
 
-static int
-rhc_is_valid(struct rt_rhc_internal *rhc)
-{
-    fastf_t mag_b, mag_h, cos_angle_bh;
 
-    RT_RHC_CK_MAGIC(rhc);
-
-    mag_b = MAGNITUDE(rhc->rhc_B);
-    mag_h = MAGNITUDE(rhc->rhc_H);
-
-    /* check for |H| > 0, |B| > 0, |R| > 0, c > 0 */
-    if (NEAR_ZERO(mag_h, RT_LEN_TOL)
-	|| NEAR_ZERO(mag_b, RT_LEN_TOL)
-	|| NEAR_ZERO(rhc->rhc_r, RT_LEN_TOL)
-	|| NEAR_ZERO(rhc->rhc_c, RT_LEN_TOL))
-    {
-	return 0;
-    }
-
-    /* check B orthogonal to H */
-    cos_angle_bh = VDOT(rhc->rhc_B, rhc->rhc_H) / (mag_b * mag_h);
-    if (!NEAR_ZERO(cos_angle_bh, RT_DOT_TOL)) {
-	return 0;
-    }
-
-    return 1;
-}
-
 /*
  * Local Variables:
  * mode: C
Index: src/librt/primitives/obj_vshot.c
===================================================================
--- src/librt/primitives/obj_vshot.c	(revision 53222)
+++ src/librt/primitives/obj_vshot.c	(working copy)
@@ -40,7 +40,7 @@
     if (segp) RT_CK_SEG(segp);
     if (ap) RT_CK_APPLICATION(ap);
 
-    /* should be improved, verify homogeneous collection */
+    /* should be improved, verify homogenous collection */
     id = stp[0]->st_id;
     if (id < 0)
 	return -2;
Index: src/nirt/if.c
===================================================================
--- src/nirt/if.c	(revision 53222)
+++ src/nirt/if.c	(working copy)
@@ -298,6 +298,8 @@
     new_ovlp->forw->backw = new_ovlp;
     ovlp_list.forw = new_ovlp;
 
+    bu_log("Does this one in IF gets called?\n");
+
     /* Match current BRL-CAD default behavior */
     return rt_defoverlap (ap, pp, reg1, reg2, InputHdp);
 }
